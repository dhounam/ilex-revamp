/* MainCreated 10.11.05Updated 12.11.08 (reset "tweak" to zero at line 909-912 in attempt to resolve hScale squeezing issue...)Updated 29.04.09 (sets g_appVersion)		21.7.09 (Ilex calls getPreliminaries at startup)Contains:- Ilex	(top-level controller)- drawTraces	decides/calls trace-drawing functions in style-specific modules- saveDraft	was first save to draft ("Chardat") folder; now redundant, I think- getOverallStyle	reduces sub-styles to general style (e.g. "ColSideBySide" etc to just "Col")- marginsPostAdjust	margin adjustment on hScale- restoreStructure	removes debris left by marginsPostAdjust- getBlobSpace	creates space for blobs above/right scale- breakTopScale	creates space to break scale at top/right*/// $.level=1;// ILEX// Called from AIPipe visible file// Top-level function controls ALL proceduresfunction Ilex(){	var s;	var isHP = true;		// half (default) or complete pie?	var isNHP = false;	// nested halfpie or not (default)	var i;	var sW;				// slot-width calculator	var yearIncr;			// 1/5/10 year flag	// Just set a few necessary globals (author & O.S.)	// (in Utilities)	if (!getPreliminaries()) {		return false;	}	// ******STARTUP******	// Procedures in their own module:	// 		read in paths	//		read in general preferences	//		read in chart-specific files	//		read in section preferences	//		check for existing panel or leave black page	if (!getStarted()) {return false};	// Mega-nasty post-REVAMP KLUDGE	// I don't know where I lost the alignment of IN chart visible panel	// to bottom of title... but it fell somewhere by the wayside. Rather	// than go digging back into Excel, I've given it a nasty kick...	//if (!g_isRevamp) {	//	if (g_sectionFile.split(".")[0] === "IN") {	//		if (g_onePanelVisible) {	//			g_extraTitle = -11;	//		}	//	}	//}	// NOTE: this proves unnecessary once I've fixed a bug in Background...	// So at this stage all the data to create the file has been read in	// If this is a chart, work out the broad styles:	if (!g_isTable) {		// General style (line/col/bar...) -- in this module		g_overallStyle = getOverallStyle();		if ((g_overallStyle[0] == undefined) && (g_overallStyle[1] == undefined)) {return false};	}	// ******PANELS******	// getStarted (called just above) will have tripped the panels flag	if (g_panelExists) {		// There is a panel to draw into		// So this is an existing chart: set status flag:		g_scratchFile = false;		// Reset any background strings, then create an inner box		// (preparePanel is in Panels module)		if (!preparePanel()) {			return false;		}	}	else {		// No existing panel; start from scratch on blank sheet		// Set status flag:		g_scratchFile = true;		// Take it as far as having an inner box ready for scales and traces		// (drawBackground in Background module)		if (!drawBackground()) {			return false;		}	}	// REVAMP: Jan 2016. Remember inner box coords before we start shrinking it...	// (For panels, this is the innerbox as reset by Panels.drawPanels, within active panel)	g_originalInnerBox = {		top: g_innerBox.top,		left: g_innerBox.left,		width: g_innerBox.width,		height: g_innerBox.height	};	// SO NOW I SHOULD BE STARING AT AN INNER BOX	// READY FOR SCALES AND TRACES...	// All background strings are set	// If there are visible panels, move context to the relevant layer	if (g_totalPanelNo > 1) {		pStr = c_panelN + g_thisPanelNo;		g_panelLayer = g_myDoc.layers[pStr];	}	else {		// No panels; try to stick with existing single layer		try {			g_panelLayer = g_myDoc.layers[c_onePanelLayerN];		}		catch (err) {			// Failing that, go with a numbered layer...			pStr = c_panelN + g_thisPanelNo;			g_panelLayer = g_myDoc.layers[pStr];		}	}	// REVAMP addition:	// If it's a thermometer, ask if user wants 'crossbar' style...	// ...but only for revamp:	if (g_isRevamp) {		var thermoCrossFlag = false;		// Checks for col/bar thermo clunk like hell...		if ((g_chartStyle[0] == c_colThermoConst) || (g_chartStyle[1] == c_colThermoConst)) {			thermoCrossFlag = true;		}		else if ((g_chartStyle[0] == c_barThermoConst) || (g_chartStyle[1] == c_barThermoConst)) {			thermoCrossFlag = true;		}		// Now ask:		if (thermoCrossFlag) {			g_thermoCross = confirm('Do you want to display crossbar-style thermometer markers...?', true, 'Thermometer option');		}	}// **************************************************	// THIS LOOKS LIKE THE SPOT TO FORK FOR CHARTS/TABLES	// **************************************************	if (!g_isTable) {		// ***SPACES FOR BLOBS AND SCALE BREAK***		// If there are blob values, make space		if (g_blobFlag) {			if (!getBlobSpace()) {				// Failure: alert, but carry on				msg = "Blobs may not be correctly drawn, but let's press on, hoping for the best...";				myAlert(msg, "Blobs error");			}		}		// If the scale breaks at the top, make space		if (!(g_breakTopScale == 0)) {			if (!breakTopScale()) {				// Failure: alert and carry on...				msg = "I failed to break the scale at the top; anyway let's pretend " &					"it didn't happen and press on, hoping for the best...";				// ...but don't break the trace				g_breakTopScale = 0;				myAlert(msg, "Scale error");			}		}		// REVAMP checks for 5 or less categories in a COLUMN chart, and sets a wider gap...		if (g_isRevamp) {			if ((g_overallStyle[0] == c_generalColConst) || (g_overallStyle[1] == c_generalColConst))  {				if (g_catArray.length <= 5) {					g_cbGap = g_cbWideGap;				}			}		}		// REVAMP fix ends		// And, while we're here and in REVAMP mode, can we replace "*" in stacked charts with zero:		/*		if (g_isRevamp) {			if (g_accumulate[0] || g_accumulate[1]) {				// Loop by series...				for (var sCount = 0; sCount < g_valArray.length; sCount++) {					var oneSeries = g_valArray[sCount];					for (i = 0; i < oneSeries.length; i ++) {						if (oneSeries[i] === '*') {							oneSeries[i] = 0;						}					}				}			}		}		*/		// ***SCALE FLIP***		// Does the horizontal scale flip?		// Only for accum'd lines...		/*		// *** Comm'd out Jan 2016: ALL ticks are outside the box, so NEVER flip		if ((g_overallStyle[0] == c_generalLineConst) || (g_overallStyle[1] == c_generalLineConst)) {			if (g_accumulate[0] || g_accumulate[1]) {g_hScaleFlip = true};		}		// ...and columns with a zero baseline (???)		else if ((g_overallStyle[0] == c_generalColConst) || (g_overallStyle[1] == c_generalColConst))  {			if ((g_lowA == 0) || (g_lowB == 0)) {g_hScaleFlip = true};		}		*/		// Left/right margins of horizontal scales will have to be adjusted for projecting scale strings		// or -- in the case of columns -- trace elements. This adjustment will be made either immediately before		// or immediately after the scale is drawn; so I need to know about any trace projection now...		// (columns set this to half a cluster width)		// By default:		g_traceProjection = 0;		// Bar chart issue 1.3.07. The flags that register whether there		// are values for A and B sides were previously set inside VScales.drawVScales		// which meant they never actually got set for bars! (At Eco, where scales default		// to right, the fact that they were undefined eval'd to false and all seemed well...)		// Well, that stopped working with FT's scale left default. So that section of code		// moved up here, so that bars encounter it...		// Also a pie issue; fix 18.3.07		if (g_chartStyle[1] == c_scatterConst) {			// Scatters: vertical scale is "B" set			if (!(g_incrementB == undefined)) {				g_dataAExists = false	// g_scaleLeft;				g_dataBExists = true	// (!g_scaleLeft);			}		}		else {			// Pies. Check chart styles (if not undefined) left and right			if (!(g_chartStyle[0] == undefined)) {				if (g_chartStyle[0].search(c_pieConst) > -1) {					g_dataAExists = true;				}			}			if (!(g_chartStyle[1] == undefined)) {				if (g_chartStyle[1].search(c_pieConst) > -1) {					g_dataBExists = true;				}			}		}		// If we emerged from these scatter/pie checks with g_dataAExists and g_dataBExists undefined,		//		if ((g_dataAExists == undefined) && (g_dataAExists == undefined)) {			g_dataAExists = (!(g_incrementA == undefined));			g_dataBExists = (!(g_incrementB == undefined));		}		/*		else if ((g_chartStyle[0].search(c_pieConst) > -1) || g_chartStyle[1].search(c_pieConst) > -1) {			// Pies/half/nested: although there's no left/right scale, style vars have a "side"			g_dataAExists = g_scaleLeft;			g_dataBExists = (!g_scaleLeft);		}		else {			alert(2)			// Lines/cols: check both sets			g_dataAExists = (!(g_incrementA == undefined));			alert(3)			g_dataBExists = (!(g_incrementB == undefined));			alert(4)		}		*/		// REVAMP: special code for LD charts: lines only		// Other types draw to Print (-ish) style, with Revamp fonts, etc		// So: line chart?		if ((g_overallStyle[0] == c_generalLineConst) || (g_overallStyle[1] == c_generalLineConst)) {			// Leader??			// REVAMP: Matt changed his mind! I'm forcing this flag off towards the			// beginning of function Ilex(), at the top of this module (approx line 66)			if (g_drawLeaderStyle) {				// Inferential code in new REVAMP component Leader.jsx				if (!doLeaderStuff()) {					return false;				}				if (!drawTraces()) {					return false;				}				// Now adjust the blobs: position and fill colour...				var blobsGroup = activeDocument.groupItems['Blobs: trace 1'].groupItems;				var bCol = makeColourObject(g_tLine1StrokeCMYK);				var blob = blobsGroup[blobsGroup.length - 1];				blob.left = g_innerBox.left;				blob.pathItems[0].fillColor = bCol;				blob = blobsGroup[0];				var loc = g_innerBox.left + g_innerBox.width;				blob.left = loc - 15;				blob.pathItems[0].fillColor = bCol;				// Tidying up duplicates code at bottom of this function				// Kill the inner box				if (g_innerBox != undefined) {					g_innerBox.remove();				}				// ***FONT SUBSTITUTIONS***				// Before prompting for save, let's see what we're dealing with...				redraw();				// ...and alert about any font substitutions				if (g_fontSubstitutions.length > 0) {					msg = "";					for (i = 0; i < g_fontSubstitutions.length; i ++) {						if (i > 0) {msg += "\n\n"};						msg += g_fontSubstitutions[i];					}					myAlert(msg,"These substitutions were made for fonts missing from your system:--");				}				// ******SAVE******				// Save routines in site-specific file				if ( ! doSiteSpecificSave() ) {return false};				// And finally...				return true;			}		}		// If we're still here, it ain't a Leader/lines. So continue as pre-REVAMP...		// (and remember: some of the Leader code just above is dup'd below)		// ******SCALES******		// LINES and COLUMNS draw:--		//		vertical values scale		//		horizontal date/names scale		if ((g_overallStyle[0] == c_generalLineConst) || (g_overallStyle[1] == c_generalLineConst) ||			(g_overallStyle[0] == c_generalColConst) || (g_overallStyle[1] == c_generalColConst))  {			// Vertical values scale			if (!drawVScales()) {				g_myDoc.close( SaveOptions.DONOTSAVECHANGES );				return false;			}			// Vertical thermometers?			if ((g_chartStyle[0] == c_colThermoConst) || (g_chartStyle[1] == c_colThermoConst)) {				if (!drawHScaleThermo()) {					return false;				}			}			else {				// Non-thermo columns drawn ON ticks need to know how far a cluster would project at left/right margin				// I set this value here; but date-series columns ignore it...				g_traceProjection = ((g_innerBox.width / g_catArray.length) / 2) - (g_cbGap / 2)				// Non-thermo horizontal category scales -- names, years or dates				// First NAMES				// Check against **element 1** of g_timeSeries				// 		(element 0 flags points; element 1 flags ticks)				if (g_timeSeries[1] == c_nameConst) {					// Arg flags names (not years)					if (!drawHScaleNames(0)) {						return false;					}				}				// YEARS (which includes number series)				// Test is more complex, since g_timeSeries can have "5" or "10" appended...				// Also have to allow for fact that a "complex" date can be going through as years...				else if (g_timeSeries[1].search(c_yearConst) > -1) {					// Ticks are by 5/10/years					// If points were years too...					if (g_timeSeries[0].search(c_yearConst) > -1) {						// Increment: "years", "5years" or "10years"?						if (g_timeSeries[1].search("10") > -1) {yearIncr = 3};						else if (g_timeSeries[1].search("5") > -1) {yearIncr = 2};						else {yearIncr = 1};						// Use "names" function with increment as argument						if (!drawHScaleNames(yearIncr)) {							return false;						}					}					// Otherwise a complex date					else {						if (!drawHScaleDates()) {							return false;						}					}				}				else {					if (!drawHScaleDates()) {						return false;					}				}			}		}		// BARS draw horizontal values scale only		else if ((g_overallStyle[0] == c_generalBarConst) || (g_overallStyle[1] == c_generalBarConst)) {			// Draw scale			if (!drawHScaleValues(true)) {				return false;			}		}		// SCATTERS draw vertical and horizontal values scales		else if ((g_overallStyle[0] == c_generalScatterConst) || (g_overallStyle[1] == c_generalScatterConst)) {			// Vertical values scale (VScales.drawVScales)			if (!drawVScales()) {				g_myDoc.close( SaveOptions.DONOTSAVECHANGES );				return false;			}			if (!drawHScaleValues(false)) {				return false;			}		}		// PIES draw neither...		else {			// ...but I need to tweak the top of the inner box			g_innerBox.top -= g_scaleSpaceAbove;			g_innerBox.height -= g_scaleSpaceAbove;			// and build array of centre positions			// Pie or Half-Pie?			if ((g_chartStyle[0] == c_pieConst) || (g_chartStyle[1] == c_pieConst)) {isHP = false};			// Nested HP?			if (isHP) {				if ((g_chartStyle[0] == c_nestedHalfPieConst) || (g_chartStyle[1] == c_nestedHalfPieConst)) {isNHP = true};			}			g_pieCentres = getPieCentres(g_valArray.length, isHP, isNHP);		}		// ***BROKEN SCALE***		// 2nd broken scale symbol function is in site module		// At Economist, does nothing		// At FT appends symbol to left/right h-scale tick		// (by the way, drawBrokenScale1 is called from VScales.drawVScales)		if ((g_isBS[0]) || (g_isBS[1])) {			if (!drawBrokenScale2()) {				myAlert ("Broken scale symbol (stage 2) not drawn...","Non-fatal error");				// Failure is not fatal			}		}			// ******TRACES******		// Fork procedure in this module calls individual styles functions		// Drawn within inner box (so all scale-drawing procs should leave inner box		// at correct size/position for traces...		if (!drawTraces()) {			return false;		}		// It there are blobs, move them to the front		try {			g_blobGroup.move(g_panelLayer, ElementPlacement.PLACEATBEGINNING);		}		catch (err) {};		// ***KEYS***		if (!drawKeys()) {			return false;		}		// CHARTS FORK ENDS	}	//	else {		// TABLES FORK BEGINS		if (!drawTable()) {			return false;		}		// TABLES FORK ENDS	}	//	// ************************	// CHARTS AND TABLES REJOIN	// ************************	// ***CHART NUMBER***	// Is the chart numbered?	// Function to draw number is in Site module	if (g_numberChart) {		drawChartNumber();	}	// ***INFERENTIAL TWEAKS***	// Function is site-specific	doInferentialTweaks()	// And for REVAMP thermometer tick tweaks:	if (g_isRevamp) {		if ((g_chartStyle[0] == c_colThermoConst) || (g_chartStyle[1] == c_colThermoConst)) {			tweakThermoTicks(true);		}		else if ((g_chartStyle[0] == c_barThermoConst) || (g_chartStyle[1] == c_barThermoConst)) {			tweakThermoTicks(false);		}	}	// ***FILE NAME***	// If this is a new file, convert filename embedded in DataB.txt to	// site-specific format (for details box and save).	// If getScratchName can't work out a good	// file name from the string passed by Excel, it returns a random name//	if (g_scratchFile) {g_chartName = getScratchName()};	// Kosher existing file uses its own name//	else {g_chartName = g_myDoc.name};	// ***DETAILS***	// Draw details layer (in Site module) if this chart was drawn from scratch//	if ((!g_panelExists) && (g_showDetails)) {//		if (!drawBoxes()) {//			return false;//		}//	}	// Whether details layer was created this time, or is a hang-over	// from original creation --//	try {//		g_myDoc.layers[c_detailsLayerN].locked = true;//	}//	catch (err) {};	// Kill the inner box	// if (!g_isTable) {	if (g_innerBox != undefined) {		g_innerBox.remove();	}	// }	// ***FONT SUBSTITUTIONS***	// Before prompting for save, let's see what we're dealing with...	redraw();	// ...and alert about any font substitutions	if (g_fontSubstitutions.length > 0) {		msg = "";		for (i = 0; i < g_fontSubstitutions.length; i ++) {			if (i > 0) {msg += "\n\n"};			msg += g_fontSubstitutions[i];		}		myAlert(msg,"These substitutions were made for fonts missing from your system:--");	}	// ******SAVE******	// Save routines in site-specific file	if ( ! doSiteSpecificSave() ) {return false};	return true;}// ILEX ends// DRAW TRACES// Called from Ilex. Note that this function also, somewhat implausibly, handles any duplicate baseline...function drawTraces(){	var i;								// counter	var lastTrace = false;				// flags last trace	var traceTotal = g_valArray.length;		// no. of traces	var pieCentres;						// array of pie centre points	var dupBase = false;					// if reset true, duplicate baseline	var base2;							// dup'd baseline	var accum;	var aLen;	// If (a) one trace, and	// (b) GP setting is for no gap between bars/columns if one trace,	// set gap global to zero	if (traceTotal == 1) {		if (g_oneTraceNoGap) {g_cbGap = 0};	}	// Set key attributes object array to length	// (Scatter "doubles up"; Pies.drawPie will override this with # of wedges)	if (g_overallStyle[0] == c_generalScatterConst) {g_keyArray = Array(traceTotal / 2)};	else {g_keyArray = Array(traceTotal)};	// Layer to insert traces	// (Previously built separate layer; but as of jan06 use active panel layer...)	g_traceLayer = g_panelLayer;					//activeDocument.layers.add();												//g_traceLayer.name = c_traceLayerN;												//setLayerColor(g_traceLayer,c_traceColor);	// Define array of styles	// Each element matches a trace and consists of 2 sub-elements:--	// 		style constant	//		flag whether attached to left or right scale	// 			(obviously irrelevant to some styles: bars, pies...)	var styleArray = Array(traceTotal);	g_allTraces = Array(traceTotal)	if (g_doubleScale > 0) {		// Double scale		//		for (i = 0; i < traceTotal; i++) {			if (i < g_doubleScale) {styleArray[i] = Array(g_chartStyle[0],true)};			else {styleArray[i] = Array(g_chartStyle[1],false)};		}	}	else {		// No double scale; check style --		if (g_overallStyle[0] == c_generalScatterConst) {	// just check one element for both			// Scatter:			for (i = 0; i < traceTotal; i++) {				styleArray[i] = Array(c_scatterConst,g_scaleLeft);				// (2nd array element merely for consistency, I think...)			}		}		else {			// Line/column/bar -- but attached to left or right scale?			if (g_dataAExists) {				// Left				for (i = 0; i < traceTotal; i++) {					styleArray[i] = Array(g_chartStyle[0],true);				}			}			else {				// Right				for (i = 0; i < traceTotal; i++) {					styleArray[i] = Array(g_chartStyle[1],false);				}			}		}	}	// Accumulation: initialise global holders for Column/Bar "remembered" positions	aLen = g_valArray[0].length;	g_prevTArray = new Array(aLen);		// actually redundant	g_prevTopsArray = new Array(aLen);	g_prevBottomsArray = new Array(aLen);	// For each trace, pass to the appropriate style handler:	//		the array of values	// 	    trace number	//		last trace flag	//		left/right flag	//		normal/stepline flag (line/stepline only)	//		sub-style (col/bar only)	for (i = 0; i < traceTotal; i++) {		if (i == (traceTotal - 1)) {lastTrace = true};		// Accumulate? By default --		accum = false;		// Doublescale: check by "side"		if (g_doubleScale > 0) {			// "Left"			if ((i > 0) && (i < g_doubleScale)) {				//alert("Left\n trace = " + (i + 1))				if (g_accumulate[0]) {					accum = true;				}			}			// Right			else if (i > (g_doubleScale)) {				//alert("Right\n trace = " + (i + 1))				if (g_accumulate[1]) {					accum = true;				}			}			// First trace, left or right			else {				//alert("Initial trace, left or right\n trace = " + (i + 1))				accum = false;			}		}		// Not doublescale		// (Redundantly resets flag every loop...)		else {			if (styleArray[i][1] && g_accumulate[0]) {				accum = true;			}			else if ((!styleArray[i][1]) && g_accumulate[1]) {				accum = true;			}			else {				accum = false;			}		}		// Call style handler		switch (styleArray[i][0]) {			// LINE/STEPLINE			// Args are: 	array of vals			//				trace number			//				last trace flag			//				left/right flag			//				normal/stepline flag			case c_lineConst:				// LINE				g_allTraces[i] = drawLine(g_valArray[i], i + 1, traceTotal, lastTrace, styleArray[i][1], false);				break;			case c_lineStackedConst:				// LAYER CAKE				// (same call as normal line; picks up on accumulation flag)				g_allTraces[i] = drawLine(g_valArray[i], i + 1, traceTotal, lastTrace, styleArray[i][1], false);				// Layer cakes have duplicate baseline. Since they must be zero-anchored, I think it's an				// unconditional set (REVAMP):				dupBase = true;				break;			case c_stepLineConst:				// STEPLINE				g_allTraces[i] = drawLine(g_valArray[i], i + 1, traceTotal, lastTrace, styleArray[i][1], true);				break;			// COLUMNS			// Args are:		array of values			// 				trace number			//				total number of traces			//				left/right flag			//				sub-style (side-by-side, overlap, stack, thermo)			case c_colSideBySideConst:				// COLUMN (side by side)				g_allTraces[i] = drawCols(g_valArray[i],i + 1,traceTotal,styleArray[i][1],c_colSideBySideConst);				// Cols have dupe baseline if either side isn't broken				if ((!g_isBS[0]) && g_dataAExists) {dupBase = true};				if ((!g_isBS[1]) && g_dataBExists) {dupBase = true};				break;			case c_colStackedConst:				// COLUMN (stack)				g_allTraces[i] = drawCols(g_valArray[i],i + 1,traceTotal,styleArray[i][1],c_colStackedConst);				if ((!g_isBS[0]) && g_dataAExists) {dupBase = true};				if ((!g_isBS[1]) && g_dataBExists) {dupBase = true};				break;			case c_colOverlapConst:				// COLUMN (overlap)				g_allTraces[i] = drawCols(g_valArray[i],i + 1,traceTotal,styleArray[i][1],c_colOverlapConst);				if ((!g_isBS[0]) && g_dataAExists) {dupBase = true};				if ((!g_isBS[1]) && g_dataBExists) {dupBase = true};				break;			case c_colThermoConst:				// COLUMN (thermo)				g_allTraces[i] = drawThermoColTrace(g_valArray[i],i + 1,traceTotal,styleArray[i][1],c_colThermoConst);				dupBase = true;				break;			// BARS			// Args are:	array of values			// 				trace number			//				total number of traces			//				sub-style (side-by-side, overlap, stack, thermo)			case c_barSideBySideConst:				// BAR (side by side)				g_allTraces[i] = drawBars(g_valArray[i],i + 1,traceTotal,c_barSideBySideConst);				// Bars have dupe baseline if either side isn't broken				if ((!g_isBS[0]) && g_dataAExists) {dupBase = true};				if ((!g_isBS[1]) && g_dataBExists) {dupBase = true};				break;			case c_barStackedConst:				// BAR (stack)				g_allTraces[i] = drawBars(g_valArray[i],i + 1,traceTotal,c_barStackedConst);				if ((!g_isBS[0]) && g_dataAExists) {dupBase = true};				if ((!g_isBS[1]) && g_dataBExists) {dupBase = true};				break;			case c_barOverlapConst:				// BAR (overlap)				g_allTraces[i] = drawBars(g_valArray[i],i + 1,traceTotal,c_barOverlapConst);				if ((!g_isBS[0]) && g_dataAExists) {dupBase = true};				if ((!g_isBS[1]) && g_dataBExists) {dupBase = true};				break;			case c_barThermoConst:				// BAR (thermo)				g_allTraces[i] = drawThermoBarTrace(g_valArray[i],i + 1,traceTotal,c_barThermoConst);				dupBase = true;				break;			// PIES			// Args are:	2 arrays of values			// 				trace number			//				total number of traces			//				true=pie; false=halfpie			case c_pieConst:				g_allTraces[i] = drawPie(g_valArray[i],i + 1,traceTotal,true, false);				break;			case c_halfPieConst:				g_allTraces[i] = drawPie(g_valArray[i],i + 1,traceTotal,false, false);				break;			case c_nestedHalfPieConst:				g_allTraces[i] = drawPie(g_valArray[i],i + 1,traceTotal,false, true);				break;			// SCATTER			// Args are:	2 arrays of values			// 				trace number			//				total number of traces			case c_scatterConst:				// Scatter values come in pairs; I send down 2 sets at once				if ((i % 2) == 0) {					g_allTraces[i] = drawScatter(g_valArray[i],g_valArray[i + 1],i + 1,traceTotal);				}				break;			// DEFAULT			default:				// If all else fails, draw line				msg="I am unable to determine style for trace " + i +					".\n Drawing line by default..."				myAlert(msg,"Trace style error")				g_allTraces[i] = drawLine(g_valArray[i],i + 1,lastTrace,styleArray[i][1],false);				break;		}	}	// More REVAMP fun: if it's a broken scale, I need to shorten the baseline	// (assuming there ARE ticks, of course!)	if (g_isRevamp && (typeof g_baselineTick !== 'undefined')) {		if (g_hScaleTickGroup !== undefined) {			if (g_hScaleTickGroup.pathItems.length > 1) {				// ... except bar charts...				if ((g_overallStyle[0] !== c_generalBarConst) || (g_overallStyle[1] !== c_generalBarConst)) {					if (g_isBS[0]) {						var p = g_baselineTick.pathPoints[0];						var pA = p.anchor;						// New left						pA[0] = g_hScaleTickGroup.left;		// g_innerBox.left - g_hScaleTickStrokeWidth;						p.anchor = pA;						p.leftDirection = pA;						p.rightDirection = pA;						p.pointType = PointType.CORNER;					}					if (g_isBS[1]) {						p = g_baselineTick.pathPoints[1];						pA = p.anchor;						// New width, to width of h-ticks + width of last tick (presumably group width comes up as core-to-core...						pA[0] = g_hScaleTickGroup.left + g_hScaleTickGroup.width + g_hScaleTickStrokeWidth;		//(g_innerBox.left + g_innerBox.width);						p.anchor = pA;						p.leftDirection = pA;						p.rightDirection = pA;						p.pointType = PointType.CORNER;					}				}			}		}	}	// Bars/cols and layercakes may need to duplicate baseline, in front of traces	if (dupBase) {		try{			base2 = g_baselineTick.duplicate(g_traceLayer, ElementPlacement.PLACEATBEGINNING);			base2.name = c_base2N;		}		catch (err) {alert("Failed to duplicate baseline\ng_baselineTick is " + g_baselineTick)};	}	return true;}// DRAW TRACES ends// SAVE DRAFT// Saves scratch or reflowed chart to first-instance folder// ("Chardat" at Economist; local folder at FT)// Called from above; ALSO from Indicators, to save tables to Eco Chardat top levelfunction saveDraft(chName, isScratch)// Args are 	name to save under//			true = scratch file; false = reflow{	var saveName;	var saveFile;	var saveFolder;	var saveOptions = new EPSSaveOptions();	alert("Running Main.saveDraft (approx line 731)... should this be happening?");	return false	try {		// Options:		saveOptions.cmykPostScript=true;		saveOptions.embedAllFonts=true;		// Next line covers a not-uncovered bug at FT        if (g_chardatPath == undefined) {g_chardatPath = g_cciPath};		// Chardat or CCI?		if (isScratch) {			// Save scratch chart to Chardat			saveName = checkSep(g_chardatPath);		// already verified			// Dated subfolder? If defined, named in DataB.			if (g_exportDated && (!(g_subFolderName==undefined))) {				saveName += g_subFolderName + c_pS;				if (!forceFolder(saveName)) {					saveName = checkSep(g_chardatPath);				}			}			saveName += chName;		}		// else if (c_CCI) {		else if (g_CCI) {			// Save reflowed chart to CCI, if possible			// Actually I don't think this ever happens!			myAlert ("Saving reflowed chart to CCI (in module \"Main.saveDraft\")...", "Unexpected turn of events");			saveName = checkSep(g_cciPath) + chName	;		}		else {			// Safety net			return false;		}		// I have to create a file before I can save to it, so...		saveFile = new File(saveName);		saveFile.write("");		saveFile.close();		g_myDoc.saveAs(saveFile, saveOptions);		// Annoyingly, AI insists upon appending a file name extension (".eps")		saveFile.rename(chName)		return true;	}	catch(err) {		unexpectedErrorAlert(err, "Main.saveDraft","Save error");		return false;	}}// SAVE DRAFT ends// GET OVERALL STYLE// Called from Main.Ilex to extract broad styles (line/col/bar...)// for left/right scale(s). Returns undefined if style is N/A.function getOverallStyle(){	var oS = Array(2);	var i;	var s;	// Extract 2 overall styles from chart style var (unless not defined)	for (i = 0; i < 2; i ++) {		if (!(g_chartStyle[i] == undefined)) {			s = g_chartStyle[i].toLowerCase()			if (s.search(c_generalLineConst) > -1) {				oS[i] = c_generalLineConst;			}			else if (s.search(c_generalColConst) > -1) {				oS[i] =  c_generalColConst;			}			else if (s.search(c_generalBarConst) > -1) {				oS[i] =  c_generalBarConst;			}			else if (s.search(c_generalPieConst) > -1) {				oS[i] =  c_generalPieConst;			}			else {				oS[i] =  c_generalScatterConst;			}		}	}	return oS;}// GET OVERALL STYLE ends// MARGINS POST-ADJUST// Called from HScales.drawHScaleDates to squeeze horizontal scale ticks and labels// and inner box into the appropriate margins.// This is only done for date scales; others (names / bars / scatters) call// a separate function, marginAdjust, BEFORE the horizontal scale is drawn...//	THIS FUNCTION DISREGARDS PROJECTION OF TRACE OBJECTS (which haven't been drawn yet)//	AND IS CONCERNED ONLY WITH PROJECTING STRINGS////	THERE ARE A LOT OF DEBUGGING ALERTS RATTLING AROUND, MOSTLY COMM'D OUT...//function marginsPostAdjust(onTs)// Args 		true if points are on ticks; false if between them (e.g. non-yearly-dated columns)//				(if cols are between ticks, I disregard any trace-element projection...)// g_traceArena, defined in HScales.drawHScaleDates is a 2-element array of desired left & right innerbox bounds// g_traceProjection is the distance any trace element(s) should project; but as of 15.4.06 this// is ignored.// Ticks are already grouped in g_hScaleTickGroup// Labels in g_hScaleStringGroup// Both in layer g_panelLayer{	var leftPos;			// perfect left coord	var rightPos;			// perfect right coord	var perfectWidth;	var excessL;			// excess on left	var excessR;			// excess on right	var excessWidth;	var x;				// rescale factor	var tempGrp;			// temporary group for calculating relative widths	var outlineGroup;		// outlines	var i;				// counters	var j;	var remStroke;	var myExcess;			// added 3.3.09 to reserve "outline" excess width before textRanges are moved into temp "squeeze" group...	// If I physically reset width, strokewidth seems to get screwed up	// so remember it:	try {		remStroke = g_hScaleTickGroup.pathItems[0].strokeWidth;	}	catch (err) {};	try {		// Temporary group to isolate squeezed elements		tempGrp = g_panelLayer.groupItems.add();		// Move ticks group and inner box to temp group		g_hScaleTickGroup.move(tempGrp, ElementPlacement.PLACEATEND);		g_innerBox.move(tempGrp, ElementPlacement.PLACEATEND);		// Make outline of strings group and add it to the temporary group		outlineGroup = makeOutline(g_hScaleStringGroup,false);		outlineGroup.move(tempGrp, ElementPlacement.PLACEATEND);		// Inherited "perfect" boundaries		leftPos = g_traceArena[0];		rightPos = g_traceArena[1];		perfectWidth = rightPos - leftPos;		excessL = (leftPos - tempGrp.left);		excessR = ((tempGrp.left + tempGrp.width) - rightPos);		excessWidth = excessL + excessR;		// Zero seems too tight for daily points drawn as months, so allow for slight overlap...		if (excessWidth <= 0) {			if (restoreStructure(outlineGroup)) {				return true;			}			else {				msg = "I tripped over my own feet and left some text outlines rattling around the horizontal scale. " +					"Please delete these manually and advise " + c_authorName + " that this error occurred...";				myAlert (msg, "Margin adjustment error");				return false;			}		}		// Get the percentage difference between actual and ideal width//		x = (perfectWidth / tempGrp.width) * 100;		x = (tempGrp.width / perfectWidth) * 100;		// Tweak is gap between strings group left and entire temp group left		// (use outline, since textRanges are unreliable)		var tweak = outlineGroup.left - tempGrp.left;		// **************************************************************		// As far as I can see, "tweak" only influences left margin --		// and for the worse! So overwritten to zero value		// TEMPORARY EXPEDIENT TO FIND OUT WHAT "TWEAK" IS ACTUALLY FOR...		// ...BECAUSE IT'S CAUSING EXCESS LEFT MARGINS ON SCALES		// (eg day points on monthly scale)		//alert("Debugging alert\nNote that I'm resetting the \"tweak\" value to zero " +		//	"(Main.jsx / marginsPostAdjust; line 912); but this doesn't solve my problem with right margin...")		tweak = 0		//		// **************************************************************		// Still here? Strings project. Now that we have our tweak,		// move actual scale strings to temp group for adjustment		// THIS COULD BE THE PROBLEM: I'M MOVING THE SCALE STRINGS INTO THE TEMP GROUP **BEFORE** THE TRANSFORMATIONS		// THIS MEANS THAT THE MISLEADING TEXT FRAME WIDTHS ENTER INTO THE EQUATION...		// MODS FOR THIS ARE DATED 3.3.09		// Comm'd out 3.3.09; this move is now done a few lines below...//		g_hScaleStringGroup.move(tempGrp, ElementPlacement.PLACEATEND);		// Move over on left		if (excessL > 0) {			// alert("Moved hScale from left by " + excessL + " points")			// Left projects: move everything to the right and squeeze on right...			tempGrp.left += (excessL + tweak);			// Mod 3.3.09: MOVE TEXT FRAME BY SAME AMOUNT			g_hScaleStringGroup.left += (excessL + tweak);		}		// Now check right		if (rightPos <= (tempGrp.left + tempGrp.width)) {			// Get projection of temp group beyond "perfect" width			myExcess = ((tempGrp.left + tempGrp.width) - rightPos);			// NOW move textFrames into temp group and tweak			g_hScaleStringGroup.move(tempGrp, ElementPlacement.PLACEATEND);			tempGrp.width -= myExcess;		}		// THAT ISN'T PERFECT, SINCE THE TWEAK IS TAKEN OFF THE FAKE TEXTFRAME WIDTH		// But it's probably close enough...		// COMM'D OUT 3.3.09		// I don't think we need a separate right-edge-only function...		// If we didn't move across from left, test for squeeze on right...//		else if (excessR > 0) {//			alert("Tweaking right margin only of horizontal scale...")//			// MOD 3.3.09: GET "OUTLINE" EXCESS//			g_hScaleStringGroup.move(tempGrp, ElementPlacement.PLACEATEND);////			//tempGrp.resize(x,100,true,false,false,false,false,Transformation.LEFT)//		}		// Tidy up		// I'm about to reset the squeezed text to 100%...		// HOWEVER, each text frame in the group is resized around its origin (centre point) and since		// it was resized from the extreme left, this causes an overlap --		//     |...x...| --original		//     |..x..|   --resized from left		//    |...x...|  --reset to 100% around centre point...		// So I need an additional tweak to reset left alignment		// Reserve existing (squeezed) left of first text frame		var leftA = g_hScaleStringGroup.textFrames[0].left		// Reset all text to 100%		for (i = 0; i < g_hScaleStringGroup.textFrames.length; i ++){			for (j = 0; j < g_hScaleStringGroup.textFrames[i].characters.length; j ++) {				g_hScaleStringGroup.textFrames[i].characters[j].horizontalScale = 100;			}		}		// Strongarm strokewidths		if (!(remStroke == undefined)) {			for (i = 0; i < g_hScaleTickGroup.pathItems.length; i ++) {				g_hScaleTickGroup.pathItems[i].strokeWidth = remStroke;			}		}		// Now get unsqueezed first text frame left		var leftB = g_hScaleStringGroup.textFrames[0].left		// Tweak entire group by difference...		tempGrp.left += (leftA - leftB)		// Tidy up (failure is non-fatal)		if (!restoreStructure(outlineGroup)) {			msg = "I tripped over my own feet and left some text outlines rattling around the horizontal scale. " +				"Please delete these manually and advise " + c_authorName + " that this error occurred..."			myAlert (msg, "Margin adjustment error")		}	}	catch (err) {		myAlert(err, "Unexpected margin adjustment error");		return false;	}	return true;}// MARGINS POST-ADJUST ends// RESTORE STRUCTURE// Called from marginsPostAdjust to tidy up after adjusting h-scale for margin protrusions...function restoreStructure(myOut)// Arg is text outline group to kill{	// Restore group/layer structure	try {		g_hScaleTickGroup.move(g_panelLayer, ElementPlacement.PLACEATBEGINNING);		g_hScaleStringGroup.move(g_panelLayer, ElementPlacement.PLACEATEND);		g_innerBox.move(g_backLayer, ElementPlacement.PLACEATEND);		myOut.remove();		return true;	}	catch (err) {		return false;	}}// RESTORE STRUCTURE ends// GET BLOB SPACE// Called from Main.Ilex to create space at top or right for// a stack of blob boxes. If boxes at side, also inserts space at topfunction getBlobSpace(){	// g_blobArray contains:	//	"col" 0 -- array of category strings	//	subsequent "cols" -- arrays of values / skipped-values (no commas)	var i;	var j;	var tempSize;	var n = 0;	var s;	// First, find the longest string (skip cats in "col" 1)	for (i = 1; i < g_blobArray.length; i ++) {		for (j in g_blobArray[i]) {			// Skip missing values			if (!(g_blobArray[i][j] == c_skipConst)) {				// While we're passing through, format values				g_blobArray[i][j] = FormatNumberBy3(g_blobArray[i][j]);				if (g_blobArray[i][j].length > n) {					s = g_blobArray[i][j];					n = g_blobArray[i][j].length;				}			}		}	}	// So s contains longest value	// Get its height and width	bSize = new getTFrameSize(s, g_blobFontName, g_blobFontSize, 100, true, true);	// Commas in the number string throw the size off, so...	if (s.search(",") > -1 ) {		tempSize = new getTFrameSize("0", g_blobFontName, g_blobFontSize, 100, true, true)		bSize.height = tempSize.height	}	// While we've got hold of the longest string, remember blob box width & height	// (plus inner margin)	// ((height gets overwritten on bars, which use cluster height))	// REVAMP: w/h array for margins from lookup:	g_blobSize[0] = bSize.width + (g_blobBoxMargin[0] * 2);	g_blobSize[1] = bSize.height + (g_blobBoxMargin[1] * 2);	// Adjust inner box by blob box size, plus outer margin (cols and lines)	if ( (g_overallStyle[0] == c_generalColConst) ||		(g_overallStyle[1] == c_generalColConst) ||		(g_overallStyle[0] == c_generalLineConst) ||		(g_overallStyle[1] == c_generalLineConst) ) {		if (g_blobHugCols == undefined) {			// Remember vert centre			// (allow for scale space-above, which is subtracted from top of inner box subsequently...)			g_blobSize[2] = g_innerBox.top - (g_scaleSpaceAbove + (g_blobSize[1] / 2));			n = g_blobSize[1] + g_blobColMargin;			g_innerBox.top -= n;			g_innerBox.height -= n;		}	}	else if ((g_overallStyle[0] == c_generalBarConst) || (g_overallStyle[1] == c_generalBarConst)) {		if (g_blobHugBars == undefined) {			// Remember horiz centre			g_blobSize[2] = (g_innerBox.left + g_innerBox.width) - (g_blobSize[0] / 2);			n = g_blobSize[0] + g_blobBarMargin;			g_innerBox.width -= n;		}	}	return true;}// GET BLOB SPACE ends// BREAK TOP SCALE// Called from Main.Ilex to create space to break the top of the values scale// at top (columns) or right (bars)function breakTopScale(){	var bSize;	var n;	// I'll use the value scale font attributes	// Get dimensions of max value string (in g_breakTopScale)	bSize = new getTFrameSize(g_breakTopScale, g_vScaleFontName, g_vScaleFontSize, 100, true, true);	if ( (g_overallStyle[0] == c_generalColConst) || (g_overallStyle[1] == c_generalColConst) ) {		// Add an arbitrary margin to label height (for column break)		n = bSize.height + 15;		// Reset break scale value to inner box top, then tweak inner box		g_breakTopScale = g_innerBox.top - g_scaleSpaceAbove;		g_innerBox.top -= n;		g_innerBox.height -= n;	}	else if ((g_overallStyle[0] == c_generalBarConst) || (g_overallStyle[1] == c_generalBarConst)) {		n = bSize.width + 7;		// Reset break scale value to inner box right, then tweak inner box		g_breakTopScale = g_innerBox.left + g_innerBox.width;		g_innerBox.width -= n;	}	return true;}// BREAK TOP SCALE ends