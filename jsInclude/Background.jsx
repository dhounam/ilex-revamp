/* Background boxesCreated 14/11/05Updated 20.01.17 (2nd generation revamp drawGlobalSubtitle)// BEWARE HARD CODING AT LINES 43-5Draws background elements on scratch chart:	background boxes	title, subtitle, etc.	panels(Reflow into existing panel is initialised separately, in Panels.preparePanel)Functions are:-	drawBackground	which calls:-		drawBackBox_1-		drawBackBox_2-		drawTitle-		drawGlobalSubtitle-			addValFormat-		drawSource-		drawFootnote-		checkSourceAndFootnote-		drawPanels	(in Panels)-		doHPanels-		doVPanels*/// $.level=1;// DRAW BACKGROUND// Called from Main.Ilex// Controls procedures to draw background boxes; main strings; panelsfunction drawBackground(){	var gutterNo;	var gutterTotal;	var bgCoords;	// Drawing starts in current background layer	// (current doc already assigned)	g_backLayer = g_myDoc.layers[c_backLayerN];	g_backLayer.locked = false;			// in case document is "dirty"	g_backLayer.name = c_backLayerN;	setLayerColor(g_backLayer,c_backColor);	// Background boxes are grouped	g_backGroup = g_backLayer.groupItems.add();	g_backGroup.name = c_backGroupN;	// Slap any comment on the page	drawComment(g_backLayer);	// For REVAMP, double scales get minimum extra space below subtitle	// And force extra chart height... pretty crudely!	if (g_isRevamp) {		if (g_doubleScale > 0) {			// Difference between			var extraSub = 10 - g_extraSubtitle;			g_extraSubtitle = 10;			if (extraSub > 5) {				var okToDeepen = confirm("Is it OK to increase chart height by 10pts to accomodate double scale labels below panel subtitle...?")			}			if (okToDeepen) {				if (extraSub > 15) {					g_chartHeight += 20;				}				else if (extraSub > 5) {					g_chartHeight += 10;				}			}		}	}	// Yet another inferential hack (Aug '18), for FN Buttonwood sub-style,	// which has zero margins, left and right	if (g_sectionFile.search('FN') == 0) {		if (g_ssLeftMargin == 0) {			g_innerBoxRightMargin = 0;			g_titleOriginX = 0;			g_subtitleOriginXNoPanel = 0;			g_subtitleOriginXPanel = 0;			g_sourceOriginX = 0;			g_footnoteOriginX = 0;			g_bb2OriginX = 0;			g_bb3OriginX = 0;		}	}	// BACKGROUND BOXES, PANELS, INNER BOX	// Background box_1	if (!drawBackBox_1(g_backGroup)) {		msg = "An error occurred drawing the first chart background box...";		myAlert(msg, "Background box 1 error");		return false;	}	// Draw new, 3rd box before 2nd, for stacking	// Background box_3	if (!drawBackBox_3(g_backGroup)) {		msg = "An error occurred drawing the third chart background box...";		myAlert(msg, "Background box 3 error");		return false;	}	// Background box_2	if (!drawBackBox_2(g_backGroup)) {		msg = "An error occurred drawing the second chart background box...";		myAlert(msg, "Background box 2 error");		return false;	}	// The three background boxes are in a group whose bounds should allow	// me to define the initial Inner Box. This shrinks as elements are	// added to the chart, until it finally defines the area within	// which the traces are drawn...	//	// The Inner Box (which is a global object) is a duplicate of Background Box 1	// Its size is that of the back boxes (bbs 1 & 2) group.	// But there's an FT bug: the bottom bb1 stroke is a dotted line, which	// projects beyond the path by half its stroke width, making the inner box marginally	// bigger at than the basic chart skeleton...	// So new fcn (in Utilities) added 5.3.07 gets skeleton, rather than stroked-path, sizes...	bgCoords = skeletonSize(g_backGroup);	g_innerBox = g_backBox1.duplicate(g_backGroup, ElementPlacement.PLACEATBEGINNING);	with (g_innerBox) {		name = c_innerBoxN;		stroked=false;		filled=false;		top = bgCoords[0];			//g_backGroup.top;		left = bgCoords[1];			//g_backGroup.left;		height = bgCoords[2];		//g_backGroup.height;		width = bgCoords[3];		//g_backGroup.width;		// So innerBox exists, with the same dimensions as the overall chart		// Now subtract outer margins (l/r) from inner box		// Use substyle override, if defined:		if (g_ssLeftMargin !== undefined) {			g_innerBoxLeftMargin = g_ssLeftMargin;		}		left += g_innerBoxLeftMargin;									// left		width -= (g_innerBoxLeftMargin + g_innerBoxRightMargin);		// width	}	// ZERO-MARGIN FIX: June 2017  // Mod for Espresso-DA, which has no margins. I'm only applying this to  // 'between' ticks. I modded the test conditions from HScales >	// It's a ghastly hack, but hey...	// Set a flag:	var marginAdj = false;	// First off, this only applies if there's no l/h scale...	if (typeof g_chartStyle[0] === 'undefined') {							// Maybe I can duck all this stuff...							// style.includes('line') ||							// style.includes('col') ||							// style.includes('scatter')		// ...and if left-margin is zero		if (g_innerBoxLeftMargin === 0) {			// So the scale is right-only... what's the style?			var style = g_chartStyle[1];			// For year-combinations...			if (g_timeSeries[0].search('years') >= 0) {				// If we draw years 'between' and it's a line chart				if (g_yearsBetween) {					// I'm not convinced that I have to check for a linechart...					// if (style === 'line') {					marginAdj = true;					// }				} else {					// Risky, but if years are 'on', the string should be wider than the dot!					marginAdj = false;				}			} else {				// Not years (days, weeks, etc implies a 'between' scale... I think...)				// There may be an exception with months. See if it helps. And see line 172, below				if (g_timeSeries[0].search('months') < 0) {					marginAdj = true;				}			}		}		// I REALLY DOUBT if it's this simple, but let's see how we go...	}	// Now check if there's an index blob. If not, just adjust for	// width of first tick...	if (marginAdj) {    var ibAdjust = 0;    if (g_isIndex) {			// This was another attempt at fixing the problem with index blob indentation:			//if (g_timeSeries[0] === g_timeSeries[1] === 'years') {			ibAdjust = g_indexWidth / 2;			//}    } else {      ibAdjust = g_hScaleTickStrokeWidth / 2;    }    if (ibAdjust > 0) {  		g_innerBox.left += ibAdjust;  		g_innerBox.width -= ibAdjust;    }  }	// ZERO-MARGIN FIX ends	// Add any additional space below title and subtitle	if (!isNaN(g_extraTitle)) {		g_subtitleOriginYNoPanel += g_extraTitle;		g_subtitleOriginYPanel += g_extraTitle;		g_panelSpaceAbove += g_extraTitle;	}	// Next lines only add extra space on initial chart creation	// (ie "subsequent" panels don't find this section of code, which is therefore dup'd elsewhere)	if (!isNaN(g_extraSubtitle)) {		g_scaleSpaceAbove += g_extraSubtitle;	}	// Title	if (!drawTitle(g_backLayer)) {		msg = "An error occurred drawing the title...";		myAlert(msg, "String error");		return false;	}	// Now source and footnote	// Initially these are drawn on the same line, which is set to	// whichever of the two is lower...	g_sourceFootnoteHeight = g_backBox1.top - g_backBox1.height;	g_sourceFootnoteHeight += Math.min(g_sourceOriginY, g_footnoteOriginY);	// Is there a URL strap? If so, increase height of background box 1	// (inner box height and source/footnote v-pos remain unchanged)	// and append the strap	if (g_drawStrap) {		g_backBox1.height += 10;		drawStrap(g_backLayer);	}	// This gets bottom margin issues out of the way before we have to wrestle	// with the relationship between possible panels and the subtitle...	// Source	if (!drawSource(g_backLayer,true)) {		msg = "An error occurred drawing the source string...";		myAlert(msg, "String error");		return false;	}	// Footnote	if (!drawFootnote(g_backLayer)) {		msg = "An error occurred drawing the footnote string...";		myAlert(msg, "String error");		return false;	}    // Move source/footnote up if they overlap	if (!checkSourceAndFootnote()) {		msg = "An error occurred positioning the source/footnote strings...";		myAlert(msg, "String error");		return false;	}	// So inner box is set at bottom.	// By default:	var hasGlobalSubtitle = true;	// REVAMP STUFF...	// If (a) this chart has panels and...	// ...(b) this is initiation (i.e. no existing panels on the chart)...	// ...do we want an overall subtitle? Let's ask...	if (g_totalPanelNo > 1) {		// Starting panel chart from scratch		if (!g_panelExists) {			msg = "I see you're starting a panel chart. If you want to insert a global subtitle above the panels, ";			msg += "enter it here, or 'Cancel' for no global subtitle..."			var oSub = prompt(msg, g_subtitle, "Just asking");			if (oSub !== null) {				// Subtitle				if (!drawGlobalSubtitle(g_backLayer, oSub)) {					msg = "An error occurred drawing the subtitle...";					myAlert(msg, "String error");					return false;				}			}			else {				// No global subtitle				hasGlobalSubtitle = false;			}		}	}	else if (!g_onePanelVisible) {		// Bugfix, 1.3.17. If there are NO multipanels, we set flag to False		// so that Panels > drawPanels doesn't allow extra space...		// provided, of course, that the single panel is non-visible		hasGlobalSubtitle = false;	}	// So if there are panels, user has been prompted for a global	// subtitle, which may or may not have been drawn. The point is:	// if we want a GS, it's been taken care of...	// Now draw panels, if any...	// I have an inner box, currently set to default margins left and right; and to:	//		title baseline	//		a margin above the bottom of chart or source/footnote	// I use the inner box as an area to determine one or more panels	// (hasGlobalSubtitle is a flag that determines whether drawPanels drops the top of	// 		the innerBox to allow for an overall subtitle)	if (!drawPanels(g_backGroup, hasGlobalSubtitle)) {		msg = "An error occurred drawing inner chart panel(s)...";		myAlert(msg, "Panel error");		return false;	}	// Panels have been drawn	// Append header to current panel (if any)	if (g_totalPanelNo > 1) {		drawPanelHeader(g_backLayer, g_subtitle);	}	// Subtitle	// Params are:	//		context	//		string to use	// The point is: if there are panels, the GS has been done	// So...	if (g_totalPanelNo < 2) {		if (!drawGlobalSubtitle(g_backLayer, g_subtitle)) {			msg = "An error occurred drawing the subtitle...";			myAlert(msg, "String error");			return false;		}	}	// If all has gone well, we've drawn:	//	- main boxes	//	- title, source and footnote	//	- panels (if any)	// Chart has a defined inner box and is now ready for scales, traces, etc.	return true;}// DRAW BACKGROUND ends// INDIVIDUAL ITEM-CONSTRUCTION HANDLERS//	BOXES//		drawBackBox_1//		drawBackBox_2//	STRINGS//		drawTitle//		drawGlobalSubtitle//		drawSource//		drawFootnote//		checkSourceAndFootnote//	PANELS//		drawPanels//		doHPanels//		doVPanels//	DRAW_STRAP//		added March 2013// DRAW_COMMENT//		added Feb 2014// DRAW COMMENT// Slaps any comment on to the pagefunction drawComment(bbG) {	var myOrigin, col, w;	if (g_comment === undefined) {return;}	if (g_comment.length > 0) {		myOrigin = [625,100];		col = [0,100,100,0];		w = 300;		commentRange = makeText(bbG, myOrigin, col,		"EconSansCndReg", 9, 9, 0, 0, 100,		w, false, g_comment, "Comment string", "Comment string", false);		alert("This chart has an attached comment, which will appear " +			"on the page, above the chart, and should be deleted before " +			"the file is saved to CCI...");	}}// DRAW STRAP// Draws URL strap across bottom of some charts (pref drawStrap in lookups = true/false)// Note that properties are hard-coded here...function drawStrap(bbG) {	var coords, strapRange, strapString, strapWidth;	var myOrigin = new Array(2);	var strapWidth;				// for wrapping (not that there is any)	var strapCol = [0,0,0,50];					// font colour	var strapFill = makeColourObject([0,0,0,0]);   // box fill	coords = skeletonSize(g_backBox1)	g_strapBox = g_backBox1.duplicate(g_backGroup, ElementPlacement.PLACEATBEGINNING);	with (g_strapBox) {		name = "Strap box";		stroked=false;		filled=true;		fillColor = strapFill;		top = (coords[0] - coords[2] + 10);	// top - height + 10		left = coords[1];		height = 10;		width = coords[3];	}	// So strapBox exists, 10pts deep at the bottom of the background box	// Now the text range:	strapString = "Economist.com/graphicdetail";	// Origin is relative to bottom left of strap range	myOrigin[0] = g_strapBox.top - 6.75;	myOrigin[1] = coords[1];		//g_backBox1.left;	strapWidth = g_strapBox.width;	strapRange = makeText(bbG, myOrigin, strapCol,		"OfficinaSanITC-Book", 6, 6, 0, 0, 100,		strapWidth, false, strapString, "Strap string", "Strap string", false);}// DRAW STRAP ends// TWO BACKGROUND BOX FUNCTIONS// DRAW BACKBOX_1// Draws first background box with optional lines at top and bottomfunction drawBackBox_1(bbG)// Arg is background items group{	var itemPoints;	var itemString;	var linePoints;			// separate line coords	var bb1Line;				// separate line(s)	var bbLineY;	var fillCMYK = g_bb1FillCMYK;	// Mod Mar 2013 allows different colour for panels background. A new property,	// panelBackBoxFillCMYK must be defined in the relevant lookup file (can be	// missing and therefore 'undefined')	if ((g_totalPanelNo > 1) || (g_onePanelVisible)) {		if (g_panelBackBoxFillCMYK !== undefined) {			fillCMYK = g_panelBackBoxFillCMYK;		}	}	// Position and size (top, left, width, height):	itemPoints = g_chartOrigin.reverse()	// reverse from x/y to rectangle method's preferred top/left	itemPoints=(itemPoints.concat(g_chartWidth)).concat(g_chartHeight);	// Name & note	itemString = c_backBoxN + "1";	// Create new rectangle object	g_backBox1 = makeRect(bbG, itemPoints, g_bb1FillFlag, fillCMYK,		g_bb1StrokeAll, g_bb1StrokeAllWidth, g_bb1StrokeAllCMYK,itemString,itemString,g_bb1StrokeAllDash);	// Check it exists, position:	if (!(g_backBox1 == undefined)) {		g_backBox1.moveToBeginning(bbG);		// Any strokes depend upon the existence of a background box		// Later I should revisit this...		if (g_bb1StrokeTop) {			//linePoints = Array(Array(itemPoints[1],itemPoints[0]),			//	Array(itemPoints[1] + itemPoints[2], itemPoints[0]))			// itemPoints[0] is top of backBox. Any top line moves down by half its width...			bbLineY = itemPoints[0] - (g_bb1StrokeTopWidth / 2);			linePoints = Array(Array(itemPoints[1],bbLineY),				Array(itemPoints[1] + itemPoints[2], bbLineY));			bb1Line = makeLine(bbG,linePoints, false, undefined,				true, g_bb1StrokeTopWidth, g_bb1StrokeTopCMYK, g_bb1StrokeTopEnd, c_defaultLineMiter,				c_defaultLineMiterLimit, c_bb1TopStrokeN, c_bb1TopStrokeN, g_bb1StrokeTopDash);		}		if (g_bb1StrokeBottom) {			//linePoints = Array(Array(itemPoints[1], itemPoints[0] - itemPoints[3]),			//	Array(itemPoints[1] + itemPoints[2], itemPoints[0] - itemPoints[3]))			// itemPoints[0] - itemPoints[3] is bottom of backBox; any line moves up by half its width...			bbLineY = itemPoints[0] - itemPoints[3] + (g_bb1StrokeTopWidth / 2);			linePoints = Array(Array(itemPoints[1], bbLineY),				Array(itemPoints[1] + itemPoints[2], bbLineY));			bb1Line = makeLine(bbG, linePoints, false, undefined,				true, g_bb1StrokeBottomWidth, g_bb1StrokeBottomCMYK, g_bb1StrokeBottomEnd, c_defaultLineMiter,				c_defaultLineMiterLimit, c_bb1BottomStrokeN, c_bb1BottomStrokeN, g_bb1StrokeBottomDash);		}		// Set view (in this module)		setView();		return true	}	else {		return false	}}// DRAW BACKBOX_1 ends// DRAW BACKBOX_2// Draws second background box (red flash)function drawBackBox_2(bbG)// Arg is background items group{	var itemPoints;	var itemString;	// If not drawn, leave now:	if (!g_bb2Flag) {return true};	// Position (relative to chart top left) and size:	itemPoints = new Array(g_backBox1.top + g_bb2OriginY, g_backBox1.left + g_bb2OriginX, g_bb2Width, g_bb2Height);	// Name & note	itemString = c_backBoxN + "2";	// Create new rectangle object	g_backBox2 = makeRect(bbG,itemPoints, g_bb2FillFlag, g_bb2FillCMYK,		g_bb2StrokeFlag, g_bb2StrokeWidth, g_bb2StrokeCMYK,itemString,itemString);	// Check it exists:	if (!(g_backBox2 == undefined)) {		g_backBox2.moveToBeginning(bbG);		return true	}	else {		return false	}}// DRAW BACKBOX_2 ends// DRAW BACKBOX_3// Draws third background box (new box). Called before BB2, so that it underlies...function drawBackBox_3(bbG)// Arg is background items group{	var itemPoints;	var itemString;	// If not drawn, leave now:	if (!g_bb3Flag) {return true};	// Width can be a percent of BB1...	if (isNaN(g_bb3Width)) {		if (g_bb3Width.search('%')) {			// Width is a percent; but there may be a margin to subtract, so...			// Split into an array: percent, any value to subtract			var wArray = g_bb3Width.split("-");			// Calculate width as % of chart			g_bb3Width = parseInt(wArray[0]) / 100 * g_chartWidth;			// And if there's a margin, subtract it			if (wArray.length === 2) {				g_bb3Width -= Number(wArray[1]);			}		}	}	// Position and size:	// itemPoints = new Array(g_backBox1.top, g_backBox1.left,g_bb3Width,g_bb3Height)	itemPoints = new Array(g_backBox1.top + g_bb3OriginY, g_backBox1.left + g_bb3OriginX, g_bb3Width, g_bb3Height);	// Name & note	itemString = c_backBoxN + "3";	var rectDash = {};	var rectRotate = 0;	// Create new rectangle object	g_backBox3 = makeRect(bbG,itemPoints, g_bb3FillFlag, g_bb3FillCMYK,		g_bb3StrokeFlag, g_bb3StrokeWidth, g_bb3StrokeCMYK,itemString,itemString,		rectDash,rectRotate,g_bb3Hidden);		// Note: undefined are dash and rotation	// Check it exists:	if (!(g_backBox3 == undefined)) {		g_backBox3.moveToBeginning(bbG);		return true	}	else {		return false	}}// DRAW BACKBOX_3 ends// DRAW PANEL-FLASH// Draws red flash on panelfunction drawPanelFlash(bbG, pNo)// Arg is background items group{	var itemPoints;	var itemString;	// If not drawn, leave now:	// Position (relative to IB top left) and size:	itemPoints = [		g_innerBox.top + g_panelFlashY,		g_innerBox.left + g_panelFlashX,		g_panelFlashWidth,		g_panelFlashHeight	];	// Name & note	itemString = c_panelFlashN + pNo;	// Create new rectangle object	var panelFlash = makeRect(bbG,itemPoints, true, g_panelFlashFillCMYK,		false, 0, g_panelFlashFillCMYK,itemString,itemString);	// Check it exists:	if (panelFlash !== undefined) {		panelFlash.moveToBeginning(bbG);		return true	}	else {		return false	}}// DRAW PANEL-FLASH ends// FIVE STRING FUNCTIONS// DRAW TITLE// Draws title string (scratch only)function drawTitle(bbG)// Arg is background group{	var myOrigin = new Array(2);	var titleWidth;				// for wrapping	var x;						// line count	var y;	g_titleRange = undefined;	// Translate special characters:	g_title = trans_String(g_title);	// Origin is relative to top left of chart	myOrigin[0] = g_backBox1.top - g_titleOriginY;	myOrigin[1] = g_backBox1.left + g_titleOriginX;	tString = c_titleN;	// Wrap width is oversimplified (see Loose ends note)	titleWidth = g_innerBox.width;	g_titleRange = makeText(bbG,myOrigin,g_titleFontCMYK,		g_titleFontName,g_titleFontSize,g_titleFontLeading,g_titleAlign,0,100,		titleWidth,false,g_title,tString,tString,false);	// Check it exists:	if (!(g_titleRange == undefined)) {		// Adjust inner box to title base line...		g_innerBox.top -= g_titleOriginY;		// Top		g_innerBox.height -= g_titleOriginY;	// Height		// Unless scale top is absolute, adjust for wrapped lines		if (!g_absoluteScaleTop) {			x = g_titleRange.lines.length - 1;			y = x * g_titleFontLeading;			g_innerBox.top -= y;			g_innerBox.height -= y;			// And drop subtitle and any panel			g_subtitleOriginYPanel += y;			g_subtitleOriginYNoPanel += y;			g_panelSpaceAbove += y;		}		return true;	}	else {		return false;	}}// End DRAW TITLE// DRAW GLOBAL SUBTITLE// Draws global subtitle string (scratch or into existing panels...)// (Actually called after source, footnote and any panels have been drawn)function drawGlobalSubtitle(bbG, subString)// Args: 	background group//				string{	var myOrigin = new Array(2);	var	tWidth = g_innerBox.width;	var stBottom;							// IB adjustment	var tweak;	var myX;	var subtitleID;	// Is subtitle in...?	//			no-panels or multi-panels -- false	//			single visible panel -- true	var panelFlag = false;	// Translate special characters...	subString = trans_String(subString)	// ...and append any thousand/million string	subString = addValFormat(subString)	// On-page ID	tString = c_overallSubtitleN;	// X and y origin is relative to title string	// NOTE: I need to check for a single visible panel. Meanwhile,	// the assumption is that this is a 'normal' global subtitle	// If no panel, origin is relative to title string in both vectors	// Otherwise, y-coord is relative to title; x-coord relative to active panel (i.e. inner box)	// Trip flag...	if (g_totalPanelNo > 1) {		// ...if more than one panel...		panelFlag = true;	}	else {		// ...or if single panels are visible		if (g_onePanelVisible) {			panelFlag = true;		}	}	// According to whether there's a visible panel or not	// set positions relative to title/panel and wrap width	if (panelFlag) {		// Panel subtitle Y-position		if (g_isRevamp) {			// myOrigin[0] = g_innerBox.top - g_subtitleOriginYPanel;			// See below: same problem			myOrigin[0] = g_titleRange.anchor[1] - g_subtitleOriginYNoPanel;		} else {			// Inner box is set to current panel, which may be in row 2+			// So rather than set subtitle vPos relative to title, set relative to inner box,			// tweaking by difference between default distances of subtitle and panel below title			//			// Here, 2.3.17, I'm re-doing a kludge that was, I think, designed to get me			// out of the bug in handling a global subtitle bug in Background			if (g_totalPanelNo === 1) {				// This is, specifically, for Indicators, where the (global) subtitle				// appears at top left of IB				tweak = g_subtitleOriginYPanel - g_panelSpaceAbove;				myOrigin[0] = g_innerBox.top - tweak;			} else {				// In other cases, global subtitle is relative to source				myOrigin[0] = g_titleRange.anchor[1] - g_subtitleOriginYNoPanel;			}		}		// X-pos		switch (g_subtitleAlign.toLowerCase) {			case c_rConst:								// right				myX = g_innerBox.left + tWidth;				break;			case c_cConst:								// centre				myX = g_innerBox.left + (tWidth / 2);				break;			default:										// left by default				myX = g_innerBox.left;				break;		}	}	else {		// No panel -- Position is relative to title position		// (AS SET IN PREFS; not current outline-tweaked title position)		// Y-pos		myOrigin[0] = g_titleRange.anchor[1] - g_subtitleOriginYNoPanel;		// X-pos		switch (g_subtitleAlign.toLowerCase) {			case c_rConst:									// right				myX = g_backBox1.left + g_titleOriginX - g_subtitleOriginXNoPanel;				break;			case c_cConst:									// centre				myX = g_backBox1.left + g_titleOriginX;				break;			default:											// left by default				myX = g_backBox1.left + g_titleOriginX + g_subtitleOriginXNoPanel;				break;		}	}	myOrigin[1] = myX;	g_subtitleRange = makeText(bbG, myOrigin, g_subtitleFontCMYK,		g_subtitleFontName, g_subtitleFontSize, g_subtitleFontLeading, g_subtitleAlign, 0, 100,		tWidth, false, subString, tString, tString, false);	// Check it exists:	if (g_subtitleRange !== undefined) {		// REVAMP: double scale headers. But NOT if this is the		// main subtitle on a multipanel chart...		if (g_isRevamp) {		// Reserve distance between this and current IB top			stBottom = g_subtitleRange.anchor[1];			stBottom -= ((g_subtitleRange.lines.length - 1) * g_subtitleFontLeading);			tweak = g_innerBox.top - stBottom;			g_innerBox.top -= tweak;			// Top			g_innerBox.height -= tweak;		// Height			if (g_totalPanelNo < 2){				if (g_doubleScale > 0) {					drawDoubleScaleDummyText(bbG);					// And add the possible extra depth below subtitle in "subsequent" panel					g_innerBox.top -= g_panelSubtitleExtra;					g_innerBox.height -= g_panelSubtitleExtra;				}			}		}		else {			// 'Print' chart...			// Kludge upon kludge! Subsequent panels get that special			// tweak to the IB...			if (g_panelExists) {				g_innerBox.top -= g_panelSubtitleExtra;				g_innerBox.height -= g_panelSubtitleExtra;			}			// Another kludge (25.10.16) for 'print' charts			// Allow for additional subtitle lines			// I think I let this get buried in 'isRevamp', above...			g_innerBox.top -= ((g_subtitleRange.lines.length - 1) * g_subtitleFontLeading);			g_innerBox.height -= ((g_subtitleRange.lines.length - 1) * g_subtitleFontLeading);		}		return true;	}	else {		return false;	}}// End DRAW GLOBAL SUBTITLE// DRAW DOUBLE SCALE DUMMY TEXT// Called from drawGlobalSubtitle. If doublescale, draw dummy text left and rightfunction drawDoubleScaleDummyText(context) {	// Left:	var anchor = [(g_innerBox.top - g_doubleScaleDummyBelowSubtitle), g_innerBox.left];	var tWidth = g_innerBox.width/2;	var name = 'Left doublescale header';	makeText(context, anchor,		g_doubleScaleLeftTextCMYK, g_doubleScaleHeaderFontName,		g_doubleScaleHeaderFontSize, g_doubleScaleHeaderLeading,		g_sourceAlign, 0, 100, tWidth, false, name, name, name, false);	// Right:	anchor[1] += g_innerBox.width;	var name = 'Right doublescale header';	makeText(context, anchor,		g_doubleScaleRightTextCMYK, g_doubleScaleHeaderFontName,		g_doubleScaleHeaderFontSize, g_doubleScaleHeaderLeading,		g_footnoteAlign, 0, 100, tWidth, false, name, name, name, false);}// DRAW DOUBLE SCALE DUMMY TEXT ends// ADD VAL FORMAT// Called from drawGlobalSubtitle to append '000/m string to subtitlefunction addValFormat(s){	var f = Math.max(g_numberFormat[0], g_numberFormat[1]);	if (f >0) { s += c_formatValStrings[f] };	return s;}// ADD VAL FORMAT ends// DRAW SOURCE// Called from above to draw source string into scratch chart// or from Panels.updateSource to enter additional source ranges in multipanelsfunction drawSource(bbG, isScratch)// Args	background group//		true=scratch chart; false=subsequent multipanel (i.e. source should already exist){	// Origin is relative to outer chart bounds	var myOrigin = new Array(2);	// No source?	if (!g_showSource) {return true};	if (g_source == undefined) {g_source = "Source: to come"};	// Translate special characters:	// (BTW: g_source is a string, not the source element)	g_source = trans_String(g_source);	// Do I need to trap a subsequent multipanel that doesn't find an existing source?	// Ignored for now...	// If scratch source:	if (isScratch) {		// Prefix source label -- singular or plural?		pattern = RegExp(c_sourceSep);		if (g_source.search(pattern) > 0) {			g_source = c_sourceN + "s: " + g_source;		}		else {			g_source = c_sourceN + ": " + g_source;		}		// Wrap to inner box, unless absolute baseline		var sWidth = g_innerBox.width;		if (g_absoluteBaseline) {sWidth = 0};		// Origin		// Initially, source & footnote at same height (whichever is lower)		myOrigin[0] = g_sourceFootnoteHeight;		if (g_sourceAlign == c_rConst) {			// Right			myOrigin[1] = (g_backBox1.left + g_backBox1.width) - g_sourceOriginX;		}		else {			// Left (or centre, if it contrives to get set that way)			myOrigin[1] = g_backBox1.left + g_sourceOriginX;		}		sString = c_sourceN;		g_sourceRange = makeText(bbG,myOrigin,g_sourceFontCMYK,			g_sourceFontName,g_sourceFontSize,g_sourceFontLeading,g_sourceAlign,0,100,			sWidth,true,g_source,sString,sString,false);		// Check it exists:		if (!(g_sourceRange == undefined)) {			return true;		}		else {			return false;		}	}	else {		// Append to existing source. Does it exist?		// If not, no worries...		try {			g_sourceRange = g_myDoc.textFrames[c_sourceN];		}		catch (err) {			msg = "No existing source range found to append new string..."			myAlert(msg, "String error");			return true;		}		// Still here? Existing range found. Append new content:		appendString(g_sourceRange, g_source, true);		return true;	}}// DRAW SOURCE ends// DRAW FOOTNOTE// Called from above to draw footnote string into scratch chart// or from Panels.updateSource to enter additional source ranges in multipanelsfunction drawFootnote(bbG, isScratch)// Args: 	background group//			true=new chart; false=subsequent multipanel{	// No footnote?	if (g_footnote == undefined) {return true};	// Origin is relative to outer chart bounds	var myOrigin = new Array(2);	if (!isScratch) {		// Multipanel.		// But is there an existing frame to update? If not, reset		// the inherited flag to create a scratch footnote		g_footnoteRange = undefined;		try {			g_footnoteRange = g_myDoc.textFrames[c_footnoteN];		}		catch (err) {			// No existing footnote range		}		if (g_footnoteRange == undefined) {isScratch = true};	}	// Translate special characters:	g_footnote = trans_String(g_footnote)	// If scratch note:	if (isScratch) {		// Wrap to inner box, unless absolute baseline		var fWidth = g_innerBox.width;		if (g_absoluteBaseline) {fWidth = 0};		// Initially, source & footnote at same height (whichever is lower)		myOrigin[0] = g_sourceFootnoteHeight;		// myOrigin[0] = (g_backBox1.top - g_backBox1.height) + g_sourceOriginY;		// myOrigin[0] = (g_backBox1.top - g_backBox1.height) + g_footnoteOriginY;		if (g_footnoteAlign == c_rConst) {			// Right			myOrigin[1] = (g_backBox1.left + g_backBox1.width) - g_footnoteOriginX;		}		else {			// Left (or centre, if it contrives to get set that way)			myOrigin[1] = g_backBox1.left + g_footnoteOriginX;		}		fString = c_footnoteN;		g_footnoteRange = makeText(bbG,myOrigin,g_footnoteFontCMYK,			g_footnoteFontName,g_footnoteFontSize,g_footnoteFontLeading,g_footnoteAlign,0,100,			fWidth,true,g_footnote,fString,fString,false);		// Check it exists:		if (!(g_footnoteRange == undefined)) {			return true;		}		else {			return false;		}	}	else {		// Append to existing note. Does it exist?		// If not, no worries...		try {//			g_sourceRange = bbG.textRanges[c_sourceN];			g_footnoteRange = g_myDoc.textFrames[c_footnoteN];		}		catch (err) {			msg = "No existing footnote range found to append new string..."			myAlert(msg, "String error");			return true;		}		// Still here? Existing range found:		appendString(g_footnoteRange, g_footnote, false);		return true;	}}// DRAW FOOTNOTE ends// APPEND STRING// Called from drawSource/Footnote to append additional elements to existing range on multipanelsfunction appendString(toRange, newS, isSource)// Args: 	range to update//			new text//			source/footnote flag{	var oldString = toRange.contents;			// existing string	var ucExisting = oldString.toUpperCase();	// existing source string in upper case	var sArray;								// new string, as array	var ucNew;								// individual new elements, in upper case	var i;									// array counter	var sFlag = false;						// changes flag	var oneSource = RegExp(c_1SourceLabel);		// singular source label	var twoSource = RegExp(c_2SourceLabel);		// multi-source label	var s;	if (isSource) {		// Strip any prefix from new source(s)		newS = newS.replace(twoSource,"");		newS = newS.replace(oneSource,"");		// Separate elements		sArray = newS.split(c_sourceSep);		// Isolate new sources and convert to U/C to see if they		// are already in the source...		for (i = 0; i < sArray.length; i ++) {			// Trap any string beginning with "?", since can't make RegExp			s = trimAll(sArray[i].toUpperCase());			if (s.charAt(0) == "?") {s = "to come"};			ucNew = RegExp(s);			if (ucExisting.search(ucNew) < 0) {				// New source NOT in existing string, append and trip flag				oldString += c_sourceSep + " " + trimAll(sArray[i]);				sFlag = true;			}		}	}	else {		// Footnote always appends (source update flag not tripped)		oldString += " " + newS;	}	// New sources appended? Make singular label plural...	if (sFlag) {		if (oldString.search(oneSource) > -1) {			oldString = oldString.replace(oneSource, c_2SourceLabel)		}	}	// Update referred range	toRange.contents = oldString	// And re-do any italicisations, etc.	// (Lost because I've gone back to element content)	doTextTweaks(toRange);}// APPEND STRING ends// CHECK SOURCE AND FOOTNOTE// Handles positioning of source and footnote ranges// Both have already been wrapped to inner box if necessary,// but both aligned on source y-Posfunction checkSourceAndFootnote(){	var ibMove;	var sfW;	var w;	var moveRange;		// string that moves up	var stayRange;		// string that doesn't move	var x;	var myMove;	var tweak;	// Inner box is currently set to chart bottom; allow for margin	// Set to shared baseline upon which source & footnote are initially positioned:	g_innerBox.height = g_innerBox.top - g_sourceFootnoteHeight;	// If neither range exists, bale out now	if ((g_sourceRange == undefined) && (g_footnoteRange == undefined)) {		return true;	}	// Absolute baseline?	if (g_absoluteBaseline) {		// Does either source or footnote move?		// (next 11 lines pretty much duplicated below in this function)		tweak = (g_footnoteOriginY - g_sourceOriginY);		if (tweak > 0) {			// Footnote moves			if (!(g_footnoteRange == undefined)) {				g_footnoteRange.top += tweak;				ibMove += tweak;			}		}		else {			// Source moves -- "tweak" is negative, so...			if (!(g_sourceRange == undefined)) {				g_sourceRange.top -= tweak;				ibMove -= tweak;			}		}		// Adjust inner box height by set amount...		g_innerBox.height -= g_sourceSpaceAbove;		// ...and bale out.		return true;	}	// Still here? Baseline is not absolute.	// Allow for the inner boxes margin above source/footnote baseline	// (sourceSpaceAbove is "shared" by source and footnote)	// ibMove assembles all distance to move inner box	ibMove = g_sourceSpaceAbove;	// Allocate primacy:	// (either may in fact be undefined)	if (g_footnoteMoves) {		moveRange = g_footnoteRange;		stayRange = g_sourceRange;	}	else {		moveRange = g_sourceRange;		stayRange = g_footnoteRange;	}	// Adjust IB to immobile range	if (!(stayRange == undefined)) {		x = stayRange.lines.length - 1;		var myMove = x * (stayRange.textRange.characterAttributes.leading);		g_innerBox.height -= myMove;		// If the other ranges doesn't exist, we're done here --		if (moveRange == undefined) {			g_innerBox.height -= ibMove;			return true;		}	}	else {		// Only secondary range exists		x = moveRange.lines.length - 1;		var myMove = x * (moveRange.textRange.characterAttributes.leading);		g_innerBox.height -= (myMove + ibMove);		// Since this is only range here, we're finished --		return true;	}	// Still here?	// Both ranges exist. IB is on base of first line of stay range	// The question is: do the ranges overlap, in which case	// the moveable range will move above the fixed range and the inner box will	// have to be adjusted accordingly...	// Check combined width of source and footnote against inner box	// (less a gutter -- use same val as panel gutter)	//		(I'm not sure that this test is quite right -- maybe only move	// 		if they actually DO touch/overlap -- see documentation)	sfW = g_sourceRange.width + g_footnoteRange.width;// alert(sfW)	// w = g_innerBox.width - g_gutterWidth;	// REVAMP, Jan 17. Panel gutter is now too wide for this, so I've	// introduced a new prop in GPs	w = g_innerBox.width - g_sourceFootnoteGap;	if (sfW >= w) {		x = stayRange.lines.length;										// lines in stay range		myMove = x * (stayRange.textRange.characterAttributes.leading);	// lines * leading		moveRange.top +=myMove											// move stay range up		//ibMove += myMove 												// adjust IB		//ibMove += (myMove - stayRange.textRange.characterAttributes.leading)	// adjust IB by 1 line less		//$.bp()		x = moveRange.lines.length		//x -= 1															// minus 1 to align to move Range baseline		myMove = x * (moveRange.textRange.characterAttributes.leading)		ibMove += myMove												// adjust margin for move range		//		// I may need to do more than this, but let's see what happens...	}	else {		// No overlap, so source and footnote are sitting on the same line		// However, one or the other may be hard-set above the other. So...		if (!(g_sourceOriginY == g_footnoteOriginY)) {			var tweak = (g_footnoteOriginY - g_sourceOriginY);			if (tweak > 0) {				// Footnote moves				g_footnoteRange.top += tweak;				ibMove += tweak;			}			else {				// Source moves -- "tweak" is negative, so...				g_sourceRange.top -= tweak;				ibMove -= tweak;			}		}	}	g_innerBox.height -= ibMove										// adjust inner box depth	return true // so far no error trapping}// CHECK SOURCE AND FOOTNOTE ends// SET VIEW// Called from ?? to centre view on chartfunction setView()// Arg is background box{	var iView = g_myDoc.views[0];	// current view	// For zoom:	var iZoom = iView.zoom;								// current zoom...	var currentW = iView.bounds[2] - iView.bounds[0] - 100;	// ...width...	var currentH = iView.bounds[1] - iView.bounds[3] - 100;	// ... & height (with margin)	var wPC = currentW / g_backBox1.width;	 				// box width & height	var hPC = currentH / g_backBox1.height;	// use smaller to reset zoom:	if (wPC < hPC) {iView.zoom = wPC * iZoom};	else {iView.zoom = hPC * iZoom};	// Centre on back box 1	var xPos = g_backBox1.left + (g_backBox1.width / 2);	var yPos = g_backBox1.top - (g_backBox1.height / 2);	iView.centerPoint = Array(xPos,yPos);}// SET VIEW ends