/* KeysCreated 19.01.06Updated 05.05.09 (modded drawKeys for proper looping back of Graphic Style numbers)Contains:- drawKeys	(top-level key-constructor)- makeEmphasis	(italicises or emboldens key label subrange)	(also called inferentially from Economist.jsx)- keyObject	(attribute-setter)- getKBlobStyle	(determines correct key style for different chart styles)*/// $.level=1;// DRAW KEYS// Called from Main.Ilex to draw key lines/boxesfunction drawKeys()/*This handler should find an array -- g_keyArray -- whichhas already been populated (in style-specific handlers) with detailsof key lines/boxes for each trace (or, if pies, wedge). Soit should just have to loop through the elements in the array,processing each sub-array and placing key lines/boxes/blobsoutside the chart...*/{	var i;			// counter	var thisKey;		// key set attributes object	var blobStyle;	// 0=line, 1=rect (col/bar/pie), 2=blob (scatter/thermo)	var keyItem;		// line/rect/blob object on page	var labelItem;	// string object on page	var allKeyGroup;		// all-keys group	var thisKeyGroup;	// key set group	var pArray;		// key line/rect/blob position & dimensions	// Graphic style numbers loop back after a certain number of traces:	var kStyleNo	// Only draw keys if more than one trace/wedge:	if (g_keyArray.length == 1) {return true};	// Group all keys	// Global g_keyArray is an array of objects whose attributes	// define an individual key set (line/rect/blob + string)7	for (i = 0; i < g_keyArray.length; i ++) {		if (g_keyArray[i] == undefined) {continue};		// Sub-group		// Extract current attributes object from array		thisKey = g_keyArray[i];		// Get style (line, rect or blob)		// (This can change from trace to trace on double scales)		blobStyle = getKBlobStyle(thisKey.koStyle, thisKey.koLeftScale);		if (blobStyle == 0) {			// Line			//	position and length -- ((x,y),(x,y))			//	(horizontal line's "top" is just its y coord)			pArray = new Array(1);			pArray[0] = Array(thisKey.koLeft, thisKey.koTop);			pArray[1] = Array(thisKey.koLeft + thisKey.koWidth, thisKey.koTop);			//	create (previously in "thisKeyGroup", now just in panel layer)			keyItem = makeLine(g_panelLayer, pArray,				false, thisKey.koFillCMYK,				true, thisKey.koStrokeWidth, thisKey.koStrokeCMYK,				c_defaultLineEnd, c_defaultLineMiter, c_defaultLineMiterLimit,				thisKey.koName, thisKey.koNote);			// Top is not reset (unlike other options)			if (g_tLineStyle) {				// Graphic style numbers loop back after a certain number of points				kStyleNo = i + 1;				while (kStyleNo > c_traceLoopNo) {kStyleNo -= c_traceLoopNo};				g_myDoc.graphicStyles[c_generalLineConst + " " + kStyleNo].applyTo(keyItem);			}		}		else if (blobStyle == 1) {			// Rect			//	position and size -- top/left/width/height			pArray = Array(3);			pArray[0] = thisKey.koTop;			pArray[1] = thisKey.koLeft;			pArray[2] = thisKey.koWidth;			pArray[3] = thisKey.koHeight;			// REVAMP mod for 'crossbar' thermometers			// Comm'd out: thermocross keys now have their own size property in GPs,			// picked up in keyObject...			// if (g_thermoCross) {			// 	pArray[2] = g_thermoCrossWidth;			// }			// Another REVAMP mod: if it's a pie chart, add a vestigial pointer:			if (typeof g_chartStyle[0] !== 'undefined') {				if (g_chartStyle[0].search(c_pieConst) >= 0) {					var pointerArray = [];					var keyBottom = pArray[0] - pArray[3];					pointerArray.push([ (pArray[1] + (g_keyLinkStrokeWidth/2)), keyBottom ]);					pointerArray.push([ (pArray[1] + (g_keyLinkStrokeWidth/2)), (keyBottom - 2) ]);					//					makeLine(g_panelLayer, pointerArray, false, g_keyLinkStrokeCMYK,					true, g_keyLinkStrokeWidth, g_keyLinkStrokeCMYK,					c_defaultLineEnd, c_defaultLineMiter, c_defaultLineMiterLimit,					thisKey.koName + '_pointer', thisKey.koNote + '_pointer');				}			}			//	create (previously in "thisKeyGroup", now just in panel layer)			keyItem = makeRect(g_panelLayer, pArray,			thisKey.koFillFlag, thisKey.koFillCMYK,			thisKey.koStrokeFlag, thisKey.koStrokeWidth, thisKey.koStrokeCMYK,			thisKey.koName, thisKey.koNote);			// Reset "top" to centre, for text position			thisKey.koTop -= (thisKey.koHeight / 2)			// At some point, set style here:			// if (g_tCBStyle) {....			// if (g_tPieStyle) {....		}		else {			// Circle (scatter/thermo)			//	position and size (convert top/left to centre)			pArray = Array(1);			pArray[0] = thisKey.koLeft;	// + (thisKey.koWidth / 2);			pArray[1] = thisKey.koTop;	// - (thisKey.koHeight / 2);			//	create (previously in "thisKeyGroup", now just in panel layer)			keyItem = makeEllipse(g_panelLayer, pArray,thisKey.koHeight,thisKey.koWidth,				thisKey.koFillFlag, thisKey.koFillCMYK,				thisKey.koStrokeFlag, thisKey.koStrokeWidth, thisKey.koStrokeCMYK,				thisKey.koName, thisKey.koNote);			// At some point, set style here:			// if (g_tScatterStyle) {....		}		// Text string		pArray = Array(1)		pArray[0] = thisKey.koTop		// Double scale: italicise labels -- not revamp		if (!g_isRevamp) {			if (g_doubleScale > 0) {				thisKey.ktString = c_italMarker + thisKey.ktString + c_italMarker;			}		}		// Filter special characters		thisKey.ktString = trans_String(thisKey.ktString)		var tweak = new getTFrameSize("M", thisKey.ktFontName, thisKey.ktFontSize, 100, true, false);		pArray[0] -= (tweak.height / 2)		pArray[1] = keyItem.left + keyItem.width + g_keyLabGap;		//	create (previously in "thisKeyGroup", now just in panel layer)		thisLabel = makeText(g_panelLayer, pArray,			thisKey.ktFontCMYK,thisKey.ktFontName, thisKey.ktFontSize, thisKey.ktFontLeading,			0, 0, 100, 0, false,			thisKey.ktString, thisKey.koName, thisKey.koNote, false);//		if (i == 1) {alert(thisLabel.contents)};		// Italicise or bold as required		makeEmphasis(thisLabel,0);		// Italics		makeEmphasis(thisLabel,1);		// Bold		// Or REVAMP inferential style		makeEmphasis(thisLabel,2);		// Light	}	return true;}// DRAW KEYS ends// MAKE EMPHASIS// Called from drawKeys to italicise/embolden subrange in key text rangefunction makeEmphasis(miRange, ib)// Args:		text frame object//					0=italics; 1=bold; 2=REVAMP special style{	var subRange;					// String sub-ranges	var delRange;					// Tag sub-ranges	var sArray;					// Found tag string	var iFlag = false;			// Italics on/off flag	var s = miRange.contents;		// Range string	// Italics, bold or REVAMP light/75K...?	var emph;	if (ib === 0) {		emph = c_italMarker;	}	else if (ib === 1) {		emph = c_boldMarker;	}	else {		emph = c_lightFontMarker;	}	// Reg expression	var myRe = RegExp(emph);	// Default start-point at head of string	var from = 0;	// Tag length	var tLen = emph.length;	// Look for tag in string; if not found, return	var tagFound = s.search(emph);	// Exit without passing through the gift shop...	if (tagFound == -1) {return miRange};	// Basically I extract the contents of the range to a string	// Find the tag in the string, then isolate the sub-string	// Italicise (or whatever) the corresponding sub-range	// Delete tag from range; update string for next loop...	// Loop while tag still exists in string	while ((sArray = myRe.exec(s)) != null) {		// Sub-range starts at inherited start-point		subRange = miRange.characters[from];		// Sub-range ends at index corresponding to next tag in string		subRange.length = (sArray.index - from);		// Italicise sub-range (or not)		if (iFlag) {			// Now filter on type of operation:			if (ib === 0) {				if (!italicise(subRange)) {					msg = c_I + " failed to italicise a section of this string. Please edit manually...";					myAlert(msg, s);				}			}			// I never did anything about bold...			else if (ib === 2) {				if (!enlighten(subRange)) {					msg = c_I + " failed to reformat a section of this string to revamp emphasis. Please edit manually...";					myAlert(msg, s);				}			}		}		// Find and delete tag marking end of sub-range		delRange = miRange.characters[sArray.index];		delRange.length = tLen;		if (delRange.contents = "<i>") {			delRange.remove();		}		// Allow for deleted tag		from = myRe.lastIndex - tLen;		// Redefine string to allow for deletion		s = miRange.contents;		// Switch italicisation flag		iFlag = !iFlag;	}	return miRange;}// MAKE EMPHASIS ends// KEY OBJECT// Called from trace object (line/bar/wedge/blob) constructors in style-specific modules// Object constructor creates attributes for the key for a single tracefunction keyObject(kNo, kStyle, tO, pieVal, leftScale)// Args:		trace (wedge for pie) number (from 1)//			trace style (one of the general style constants, passed//				with each trace to allow for line/col doublescales <wedge for pie>)//			the trace attributes object (why reinvent the wheel?)//			the value of any pie wedge...//			true=left scale; false = right//{	//listArgs(arguments);	// KEY OBJECT (line or box) attributes	// 	position depends upon shape of background box	//	(NB: "top" for lines...?	if (g_backGroup.width > g_backGroup.height) {		this.koLeft = g_innerBox.left;		this.koTop = g_backGroup.top - (g_backGroup.height +  c_keyMargin)			- ((kNo - 1) * c_keyVGap);	}	else {		this.koLeft = g_backGroup.left + g_backGroup.width + c_keyMargin;		this.koTop = g_innerBox.top - ((kNo - 1) * c_keyVGap);	}	// 	size	if (kStyle == c_generalLineConst) {		this.koWidth = g_keyLineLength;		// Accumulate draws a box; otherwise a line...		if (g_accumulate[0] || g_accumulate[1]) {this.koHeight = g_keyBoxSize[1]};		else {this.koHeight	= 0};	}	else if (g_thermoCross) {		// Before scatters, thermo-crossbar...?		// REVAMP: INFERENTIAL		this.koWidth = g_keyBoxSizeThermoCross[0];		this.koHeight = g_keyBoxSizeThermoCross[1];	}	else if (kStyle.toLowerCase() == c_generalScatterConst.toLowerCase()) {		// scatter		this.koWidth = g_tScatterSize;		this.koHeight = g_tScatterSize;	}	else if (kStyle.toLowerCase() == c_colThermoConst.toLowerCase()) {		// Col thermometer		this.koWidth = g_tScatterSize;		this.koHeight = g_tScatterSize;	}	else if (kStyle.toLowerCase() == c_barThermoConst.toLowerCase()) {		// Bar thermometer		this.koWidth = g_tScatterSize;		this.koHeight = g_tScatterSize;	}	else if (kStyle.toLowerCase() == c_pieConst.toLowerCase()) {		// pie uses revamped spec		this.koWidth = g_keyBoxSizePie[0];		this.koHeight = g_keyBoxSizePie[1];	}	else {		// bar, col		this.koWidth = g_keyBoxSize[0];		this.koHeight = g_keyBoxSize[1];	}	// 	inherited trace object attributes	this.koFillFlag = tO.fFlag;				// fill	this.koFillCMYK = tO.fCol;	this.koStrokeFlag = tO.sFlag;				// stroke	this.koStrokeWidth = tO.sWidth;	this.koStrokeCMYK = tO.sCol;	this.koLineEnd = tO.lineEnd;	this.koLineMiter = tO.lineMiter;	this.koMiterLimit = tO.miterLimit;	this.koName = c_keyN + (kNo);				// name/note	this.koNote = c_keyN + (kNo);	// Mod Jan 2016 to determine colour of string	// By default...	var keyFontColour = g_keyFontCMYK;	// KEY LABEL	// 	origin	// left is solid, but vPos will be tweaked when the label is slapped on the page	this.ktOrigin = Array(this.koLeft + this.koWidth + g_keyLabGap, this.koTop)	// 	attributes	//	String	if (kStyle == c_generalPieConst) {		// pie shows category string (which may be italicised and/or bold)		this.ktString = g_catArray[kNo - 1] + " ";		if (g_pieItalicValues && g_pieBoldValues) {			this.ktString += c_italMarker + c_boldMarker + pieVal + c_boldMarker + c_italMarker;		}		else if (g_pieItalicValues) {this.ktString += c_italMarker + pieVal + c_italMarker};		else if (g_pieBoldValues) {this.ktString += c_boldMarker + pieVal + c_boldMarker};		else if (g_pieLightValues) {this.ktString += c_lightFontMarker + pieVal + c_lightFontMarker};		else {this.ktString += pieVal};	}	else {		// others show header string		this.ktString = g_headArray[kNo - 1];				// label contents	}	// Font attributes	this.ktFontName = g_keyFontName;	// But lines, inferentially:	if (kStyle.toLowerCase().search('line' >= 0)) {		this.ktFontName = g_keyFontNameLines;	}	this.ktFontSize = g_keyFontSize;	this.ktFontLeading = g_keyFontLeading;	// Label colour is subject to doublescale override:	if (g_doubleScale == 0) {		// No double scale		// If (mod Jan 2016) we follow the series colour...		// (NB: thermometers -- in Columns.jsx -- send the c_generalScatterConst)		if (g_keyFontFollowsSeries) {			if ((kStyle == c_generalLineConst) || (kStyle == c_generalScatterConst)) {				this.ktFontCMYK = tO.sCol;			}			else {				this.ktFontCMYK = tO.fCol;			}		}		// Otherwise use default from GeneralPrefs		else {			this.ktFontCMYK = g_keyFontCMYK;		}	}	else {		// Double scale: use GP left/right colours		if (kNo <= g_doubleScale) {			this.ktFontCMYK = g_doubleScaleLeftTextCMYK		}		else {			this.ktFontCMYK = g_doubleScaleRightTextCMYK		}	}	// And pass on the style and scale flag	this.koStyle = kStyle;	this.koLeftScale = leftScale;}// KEY OBJECT ends// GET K-BLOB STYLE// Called from drawKeys. Passed a specific style constant, returns//		0 = line (non-accum)//		1 = col/bar/pie + accum'd lines (at Eco anyway)//		2 = scatter/thermofunction getKBlobStyle(ks, kL)// Args:	style constant//		True = left scale; false = right{		// Line, blob or rect?		switch (ks) {			// Line			// case c_lineConst :			case c_generalLineConst :				// How lines are keyed depends on whether accumulated or not ON "THIS" SIDE				// (prevents unstacked lines being keyed by rectangle because "other" side accumulates on double scales)				// PREVIOUSLY:				// if (g_accumulate[0] || g_accumulate[1]) {return 1};				if (g_accumulate[0] && kL) {return 1};				else if (g_accumulate[1] && (!kL)) {return 1};				else {return 0};			case c_stepLineConst :				return 0;			// Col/bar/pie			case c_colSideBySideConst :				return 1;			case c_colStackedConst :				return 1;			case c_colOverlapConst :				return 1;			case c_barSideBySideConst :				return 1;			case c_barStackedConst :				return 1;			case c_barOverlapConst :				return 1;			case c_pieConst :				return 1;			case c_halfPieConst :				return 1;			// Thermo and scatter (may be crossbar style)			case c_colThermoConst :				if (g_thermoCross) {					return 1;				}				else {					return 2;				}			case c_barThermoConst :				if (g_thermoCross) {					return 1;				}				else {					return 2;				}			case c_scatterConst :				if (g_thermoCross) {					return 1;				}				else {					return 2;				}			// Failing all else, assume rectangle			default :				return 1;		}}// GET K-BLOB STYLE ends