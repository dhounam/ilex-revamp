/* Log scalesCreated 19.01.06Updated 20.07.06 (alerts check)Contains handlers used to calculate log scalesActual drawing continues (hopefully) to be done by Lines and vScales*/// MAKE LOG-SCALE VALS// Called from ?// Contrives a plausible sequence of scale values for a log scale// Whether increment switches from one cycle to another depends upon// the number of ticks...// As of 23/1/06 this could still do with improvement. In particular,// to force the "5" interval in cycles...function makeLogScaleVals(high, low, incr){	var i;				// counter	var tickCount = 0;	// total number of ticks	var thisTNo = low;	var prevTNo = low;	var myIncr = incr;	// Allow twice as many ticks as default ideal	var maxTicks = g_idealVTicks * 2;	// Array of scale values to return	var tickList = Array();		// First run:	// try incrementing by default increment all the way	for (i = low; i <= high; i += incr) {		tickList[tickCount] = i;		// Too many ticks? Don't bother any more...		if (tickCount > maxTicks) {			break;		}		tickCount ++;	}	// If a consistent increment yielded a reasonable number	// of ticks, return array of tick values now	if (tickCount <= maxTicks) {		if (i == high) {			tickList[tickCount] = i;		}		return tickList;	}	// Still here? Too many ticks at default increment	// We'll have to change increment every cycle	tickList = Array();			// re-initialise	tickCount = 0;	thisTNo = low;	while (thisTNo < high) {		tickList[tickCount] = thisTNo;		tickCount ++;		if (isCycle(thisTNo, prevTNo, myIncr/100)) {			// Next may not be right.			// Perhaps I should force to increment by bottom-of-new-cycle value...?			myIncr = myIncr * 10;		}		prevTNo = thisTNo;		thisTNo += myIncr;			}	//if (thisTNo == high) {		tickList.push(thisTNo);	//}	return tickList;}// MAKE LOG-SCALE VALS ends// IS CYCLE// Returns true if a log cycle ends (eg 0.09/0.1 or 99/100)function isCycle(thisNo, prevNo, icIncr)// Args are current and previous values to compare;// and increment (as margin for fuzzy comparison){	var thisLen;	// string "lengths"	var prevLen;	if (thisNo < (1 - icIncr)) {		// Current val < 1		// Fuzzy comparison:		if (prevNo < (1 - icIncr)) {			// prevNo also < 1 -- count zeroes after dp (as it were)			thisLen = numberShape(thisNo, icIncr);				prevLen = numberShape (prevNo, icIncr);			if (prevLen < thisLen) {				// If previous val had MORE dps...				return true;			}			else {				// Same number of dps				return false;			};		}		// I shouldn't need an "else" case: Excel checked that high > low! 		// Will return undefined...	}	else {		// Current val >= 1		if (prevNo < (1 - icIncr)) {			// Prev val < 1...			return true;		}		else {			// Both vals > 1			// So it depends on the number of figures BEFORE the dp (appended to whole numbers)			thisLen = numberShape(thisNo, icIncr);			prevLen = numberShape (prevNo, icIncr);			if (prevLen < thisLen) {return true};			else {return false};		}	}}// IS CYCLE ends// NUMBER SHAPE// Called from isCycle// Returns://	- the length of the integer section of a number >= 1 as +value		(eg: 100 --> +3)//	- number of sig dec places of number < 1 as -value					(eg: 0.001 --> -3)function numberShape(n, nsIncr)// Args are number; and fuzzy margin (increment / 100){	nsCount= 0;	if ((n > (1 + nsIncr))  || (closeEnough(n, 1, nsIncr))) {		// >= 1		while ((n > 1) || (closeEnough(n, 1, nsIncr))) {			nsCount ++;			n = n / 10;			nsIncr = nsIncr / 10;		}	}	else {		// < 1		while (n < (1 - nsIncr)) {			nsCount --;			n = n * 10;			nsIncr = nsIncr * 10;		}	}	return nsCount;}// NUMBER SHAPE ends//function closeEnough(n, compareTo, margin)// Args are the number to check; the value to compare it with; and the margin of closeness//{//	if ((n > (compareTo - margin)) && (n < (compareTo + margin))) {return true};//	if (((n - compareTo) < margin) || ((compareTo - n) < margin)) {return true};//	else {return false};//}