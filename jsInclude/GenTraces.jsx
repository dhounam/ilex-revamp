/* General tracesCreated 10.01.06Updated 11.02.09 (drawBlobHeads will only draw one header)Contains functions shared by various trace modules- calcXValuePos	Calculates x-coord for bars and scatter blobscalcYValuePos	Calculates y-coord for line points, columns and scatter blobs*/// $.level=1;// CALC X-VALUE POS// Called from		Bars.tBarsObject//					Scatter.tScatObject// Calculates x-coord for bars and scatter blobs// Returns absolute co-ordinate; so Bar caller must adjust result to widthfunction calcXValuePos(p, isSetA)// Args are 		point value//				whether attached to "A" (bar) or "B" (scatter-vert) data{	// Skipped point	if (p == c_skipConst) {return undefined};	// Still here: return co-ord	if (isSetA) {		return (g_innerBox.width / (g_highA - g_lowA) * (p - g_lowA)) + (g_innerBox.left)	}	else {		return (g_innerBox.width / (g_highB - g_lowB) * (p - g_lowB)) + (g_innerBox.left)	}}// CALC X-VALUE POS ends// CALC Y-VALUE POS// Called from		Lines.tLineObject//					Columns.tColsObject//					Scatter.tScatObject//					GenScales.makeScaleArrayLog (tick positions)// Calculates y-coord for line points, columns and scatter blobsfunction calcYValuePos(p, isSetA)// Args are 		point value//				whether attached to "A" (left) or "B" (right [or scatter.vert]) data//				true for log scale{	var myH;		// left/right high and low	var myL;	var logUnit;	// basic unit of movement	var inverted;	// Which scale might I be inverting?	if (isSetA) {inverted = g_invertedScaleA};	else {inverted = g_invertedScaleB};	// Get local version of bottom of inner box:	var botInner = g_innerBox.top - g_innerBox.height;	// Skipped point	if (p == c_skipConst) {return undefined};	// Left or right high/low	if (isSetA) {		myH = g_highA;		myL = g_lowA;	}	else {		myH = g_highB;		myL = g_lowB;	}	// Still here: log or normal scale?	if (g_logScale) {		// Log scale		// Basic unit of movement:		logUnit = g_innerBox.height / (Math.log(myH) - Math.log(myL));		// Bottom of scale is always greater than zero; create a virtual zero baseline		botInner -= Math.log(myL) * logUnit;		// Return position relative to that virtual baseline		return (botInner) + ((Math.log(p) * logUnit));	}	else {		// Normal scale		if (inverted) {			return g_innerBox.top - (g_innerBox.height / (myH - myL) * (p - myL));		}		else {			return (g_innerBox.top - g_innerBox.height) + (g_innerBox.height / (myH - myL) * (p - myL));		}	}}// CALC Y-VALUE POS ends// DRAW BLOB HEADS// Called from various Line/col/bar-drawing functions to draw blob header just above chart// This is called on every trace, but flag ensures it only does the business once// Failure alerts but is non-fatal...function drawBlobHeads(){	// Trap Leader fake blobs, which have no header:	if (g_drawLeaderStyle) {		return;	}	var bBox;				// box object	var bPts = Array(3);		// box coords	var sPts = Array(1);		// string coords	var bCentre = Array(1);	// centre point	// REVAMP trap for fake Leader blobs, which have no header:	if (g_blobHeadArray === undefined) {return;}	// Blob headers are in g_blobHeadArray	// Only use first element	var bString = trans_String(g_blobHeadArray[0]);	// Group for this box and string:	// (not sub-grouped with blobs stack)	var bG = g_panelLayer.groupItems.add();	bG.name = c_blobHeaderGroupN;	// Only draw blob header once. So check flag:	if (g_blobHeadAlreadyDrawn) {return};	try {		// Box width (string width + margins)		var frameSize =  new getTFrameSize(bString, g_blobFontName, g_blobHeaderFontSize, 100, true, false);		// REVAMP: w/h array from lookup here and about 10 lines below:		var w =  frameSize.width + (g_blobBoxMargin[0] * 2);		var h =  frameSize.height + (g_blobBoxMargin[1] * 2);		// Further REVAMP mod, Jan 2017: height of blob header box set in GPs		if (g_blobHeaderBoxHeight !== undefined) {		 	h = g_blobHeaderBoxHeight;		}		// Box		// Position is arbitrary. Provisionally, let's stick it 15 pts		// above top of chart, centred	 	// Get centre point		bCentre[0] = g_chartOrigin[1] + (g_width / 2);		bCentre[1] = g_chartOrigin[0] + 15;		//		bPts[0] = bCentre[1] + (h / 2);	// top		bPts[1] = bCentre[0] - (w / 2);	// left		bPts[2] = w;					// width		bPts[3] = h;					// height		// Draw box		bBox = makeRect(bG, bPts, g_blobBoxFillFlag, g_blobBoxFillCMYK,			g_blobBoxStrokeFlag, g_blobBoxStrokeWidth, g_blobBoxStrokeCMYK,			bG.name, bG.name);		// String (centre aligned) -- I want x,y		sPts[1] = bCentre[0];		sPts[0] = bPts[0] - bPts[3] + g_blobBoxMargin[1]; // top - height + margin		// OpenType set to proportional for blob headers... I think...		bRange = makeText(bG, sPts, g_blobFontCMYK,			g_blobFontName, g_blobHeaderFontSize, g_blobHeaderFontLeading, c_cConst, 0, 100,			0, false ,bString, bG.name, bG.name, false);		vCentreTextOn(bRange, bBox);		// And reset flag after one header has been drawn		g_blobHeadAlreadyDrawn = true;	}	catch (err) {		myAlert("An error occurred drawing the blob header. " +			"Processing will continue, but you will have to add this header manually...",			"Non-fatal blob header error " + err);	}}// DRAW BLOB HEADS ends// --	PROBABLY DELETE THIS!!!!!!!!!!!!!!// IS FLIP// Called from tBarsObject and tColumnsObject// to recognise stacked 2-trace bars and columns that "flip" round the baselinefunction isFlip(thisVal,lastPos)// thisVal is the actual{}// IS FLIP ends