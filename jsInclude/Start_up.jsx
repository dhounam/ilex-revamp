/* StartupCreated 10.11.05Updated 22.04.13 (disabled getInstallationNo, since installation no is in DataB)Several lines around line 50 can delete once Chardat has been done away with and paths havesettled down...This script handles reading in path and preference filesProcedures are:-	getStarted	Controller of:-		getPaths-		getGeneralPrefs-		getDataB-		getSectionPrefs-		getDataA-		setUpDocument-		convertSizes			(converts mm to points if necessary; sadly this			is absolutely inferential...)*/// $.level=1;// GET STARTED// Called from Main.Ilex// Controls fetching in all prefs and data filesfunction getStarted(){	var opVisible;	// see below	// Installation number is in DataB, so retrieved just below...	//if (!getInstallationNo()) {	//	return false;	//}	// Read in a numbered paths file	//if (!getPaths()) {	//	return false;	//}	// MOD 29.07.09 OVERWRITES CHARDAT PATH STRING RETRIEVED FROM PATHS FILE	// THIS IS IN PREPARATION OF REMOVAL OF CHARDAT ALTOGETHER...	// DELETE THIS LINE ONCE IT'S DONE...	// CHANGED AGAIN JAN '10: ONLY SET CHARDAT PATH TO UNDEFINED IF IT'S DIFFERENT FROM CCI PATH	// THIS IS A KLUDGE TO GET ROUND THE FACT THAT FT IS STILL USING CHARDAT (DRAFT) PATH	//if (g_cciPath != g_chardatPath) {	//	g_chardatPath = undefined;	//}	// *** I ORIGINALLY READ IN GENERAL PREFS FIRST	// *** getDataB moved ahead, so that I have access to the name	// *** of the folder where I look for GeneralPrefs.txt...	// *** Mod: 15 Feb 2016	// DataB file (Research strings)	if (!getDataB()) {		return false;	}	// Is this a revamp chart? Set global flag that, hopefully, in/excludes revamp-specific code...	// ...or at least enables whatever workarounds I can come up with...	g_isRevamp = (g_installationFolder.search("Revamp") > -1);	// General preferences	if (!getGeneralPrefs()) {		return false;	}	// This is unfortunate but seems unavoidable. The onePanelVisible default is	// initially set in the SPs file; however, Excel can overwrite, appending the	// flag to the DataB file. The problem is that, since we rely upon DataB to	// tell us which SPs to use, the SPs are read in here *after* DataB...	// overwriting the flag! So reserve now and reset after SPs read in!	opVisible = g_onePanelVisible;	// DataB gives me what I need to identify and open the Section Prefs file	if (!getSectionPrefs()) {		return false;	}	//alert('Stop now')	//alert(g_tCBUnstacked1FillCMYK)	//alert(g_tCBUnstacked1StrokeCMYK)	//return false;	// Reset (see just above)	g_onePanelVisible = opVisible;	// DataA file (headers, categories and values)	if (!getDataA()) {		return false;	}	// Convert any dimensions in mm to points (in this module)	if (!convertSizes()) {		return false;	}	// Now prepare the existing/new document for the chart	// If there's no existing file, open template.	// If template is already open, delete contents.	// If ongoing file is open, look for a viable panel --	//		if there IS a viable panel, g_panelExists is set to true	//		if this is a restart from scratch, g_panelExists is false	// But if it's all a catastrophe, abandon ship	// (setUpDocument is in this module)	if (!setUpDocument()) {		return false;	}	return true;}// GET STARTED ends// GET PATHS// This gets paths from paths file in inclusions folder// Uses installation-number (1-3) in visible filefunction getPaths()// Arg is true to retrieve numbered path; false for old-style unnumbered// Eventually I can drop this option and go over to always retrieving *numbered* paths file{	var theFile;	var myStrings;	// *** Obsolete from July 2012, when the CCI and Admin paths are included in Ilex.jsx	alert("In obsolete function Start_up.getPaths");	return true;	// Path file depends on installation number	theFile = g_iFolder.absoluteURI + c_pS + "Paths" + g_installation + ".txt";	// Read in file	myStrings = readInFile(theFile);	if (myStrings) {		// Normal parse...?		if (!parseLookup(myStrings, c_pathsFile)) {			return false;		}		// Excel format:	resdesk==Research:RESDESK:		// JS format:		tempPath==/Applications/Ilex/temp/		// If we're in Excel format, colons-->slashes		// convertPath is in Utilities		g_cciPath = convertPath(g_cciPath);		if (g_cciPath == undefined) {return false};		g_adminPath = convertPath(g_adminPath);		if (g_adminPath == undefined) {return false};		// Validate paths (CCI is optional):		//if (!checkPath(g_chardatPath, true)) {		//	return false;		//}		// if (!checkPath(g_cciPath,  c_CCI)) {		if (!checkPath(g_cciPath,  g_CCI)) {			return false;		}		if (!checkPath(g_adminPath, true)) {			return false;		}	}	else {		// Invalid result:		myAlert ("Unable to retrieve basic paths \n (Start_up.getPaths)", "General error");		return false;	}	return true}// GET PATHS ends// GET GENERAL PREFS// Controls reading in General Preferences file and// assigning all values to global variablesfunction getGeneralPrefs(){	var theFile;	var myStrings;	var thisYear;	// Assemble file name; read in file	// Filename is Excel-set constant in visible file	// NOTE: modded 15.2.16 to include installation folder in path...	theFile = checkSep(c_adminPath) + g_installationFolder + c_pS +  c_generalPrefsFile;	myStrings = readInFile(theFile);	if (myStrings) {		if (!parseLookup(myStrings, c_generalPrefsFile)) {			return false;		}		// Specific checks:		// Insert current year in copyright string:		thisYear = new Date().getFullYear();		pattern = /yyyy/;		g_copyrightString = g_copyrightString.replace(pattern,thisYear); 	}	else {		// File not read in		msg = "Please check in the Excel module that the path to the Admin folder " +			"is correct; then check that the volume is mounted. If that doesn't fix it, please contact " + c_authorName;		myAlert(msg, "Failed to read in General Preferences file \'" + c_generalPrefsFile +"\'");		return false;	}	// Update my contact string:	g_contactDetails = "\n" + c_msgIndent + c_authorName +		"\n" + c_msgIndent + "email: " + g_authorEmail +		"\n" + c_msgIndent + "phone: " + g_authorPhone.slice(1,g_authorPhone.length-1);	return true;}// GET GENERAL PREFS ends// GET DATA_B// This controls reading in chart-specific (Research) preferences// and assigning values to variablesfunction getDataB(){	var theFile;	var myStrings;	// Assemble file name; read in file	// Filename is Excel-set constant in visible file	// theFile = checkSep(g_tempPath) + c_dataBFile;	//	// Superseded July 09: use constant in Ilex.jsx	theFile = checkSep(c_tempFolder) + c_dataBFile;	myStrings = readInFile(theFile);	if (myStrings) {		if (!parseLookup(myStrings, c_dataBFile)) {			return false;		}	}	else {		// File not read in		msg = "Please check in the Excel module that the path to the temporary folder " +			"is correct; then verify that the volume is mounted. If that doesn't fix it, please contact " + c_authorName;		myAlert(msg, "Failed to read in chart-specific preferences file \'" + c_dataBFile + "\'" );		return false;	}	// Failsafe to catch lost username (since fields can go blank in Excel...)	if (g_userName == undefined) {g_userName = ""};	// This file particularly contains the file name, which includes the section ID	return true;}// GET DATA_B ends// GET SECTION PREFS// Controls reading in section preferences file// Called from getStartedfunction getSectionPrefs(){	var theFile;	var myStrings;	theFile = checkSep(c_adminPath) + checkSep(g_installationFolder) + g_sectionFile;	myStrings = readInFile(theFile);	if (myStrings) {		if (!parseLookup(myStrings, g_sectionFile)) {			return false;		}	}	else {		// File not read in		msg = "Please check in the Excel module that the path to the Admin folder " +			"is correct; then verify that the volume is mounted. If that doesn't fix it, please contact " + c_authorName;		myAlert(msg, "Failed to read in section preferences file \'" + g_sectionFile + "\'");		return false;	}	return true;}// GET SECTION PREFS ends// GET DATA_A// This controls reading in main data block (headers, categories and values)// Data is parked in three variables://		g_headArray()//		g_catArray()//		g_valArray() (2-dimensional array of arrays)function getDataA(){	var theFile;	var myStrings;	// Assemble file name; read in file	// Filename is Excel-set constant in visible file	// theFile = checkSep(g_tempPath) + c_dataAFile;	//	// Superseded July 09: use constant in Ilex.jsx	theFile = checkSep(c_tempFolder) + c_dataAFile;	myStrings = readInFile(theFile);	if (myStrings) {		// I have a multiline string of tab-separated items		// Assign to arrays (function in Utilities)		if (!assignData(myStrings)) {return false};	}	else {		// File not read in		msg = "Please check in the Excel module that the path to the temporary folder " +			"is correct; then verify that the volume is mounted. If that doesn't fix it, please contact " + c_authorName;		myAlert(msg, "Failed to read in chart data file \'" + c_dataAFile + "\'");		return false;	}	// This file particularly contains the file name, which includes the section ID	return true;}// GET DATA_A ends// SET UP DOCUMENT// Called from getStarted// This checks for an ongoing chart or opens/clears the AI template (blank page)function setUpDocument(){	var theFile;		// complete path to template file	var openTFlag;	// flag determines whether we have to open the template file	// Multipanel chart info:	// (chartPanel values read in from current prefs)	g_thisPanelNo = g_panel[0];		// panel index, of...	g_totalPanelNo = g_panel[1];		// ...total panels...	g_panelRowNo = g_panel[2];			// ... on no. of rows	g_panelExists = false;			// panel flag default	// If I'm flowing data into a multipanel, I need to check whether user	// wants to either:	//		1) use inherited title string for main chart title and	//		   subtitle for panel heading	// 		2) combine title and subtitle as panel heading (on 2 lines)	// I'VE A FEELING THIS IS A PITA, SO COMM'D OUT DURING *REVAMP*	/*	if (g_totalPanelNo > 1) {		msg = "Shall I combine the title and subtitle in panel?\nI need you to tell me what to do with these strings:" +			"\n\n     Title: \"" + g_title + "\"" +			"\n     Subtitle: \"" + g_subtitle + "\"\n\n" +			"If you click \'Yes\', I'll combine them at the top of this panel. " +			"If you click \'No\', I'll ignore the title and " +			"insert only the subtitle in this panel...";		if (confirm(msg,true)) {			// Combine			g_subtitle = g_title + ", " + g_subtitle;			g_title = "To come";		}	}	*/	// Get path to template (using new c_adminPath constant)	theFile = checkSep(c_adminPath) + c_aiTemplateFolder + c_pS + g_aiTemplateFile;	// By default:	var openTFlag = false;	try {		// Are there any docs open?		if (documents.length>0) {			// There are open documents			// Is active doc an ongoing chart file?			// Function in site-specific library checks whether:			//		file name matches house style...			// 		other elements are consistent (e.g. excludes Economist maps)			if (isOngoingChart(app.activeDocument)) {				g_myDoc = app.activeDocument;				// Ongoing, so find slot matching the position in the prefs				if (matchSlot()) {					// MatchSlot (in Panels) set a flag: g_panelExists					// If this == true, there's a slot to draw data into					// If it's false, we start from scratch,					// with the template file					if (!g_panelExists) {						openTFlag = true					}					else {						// Since this seems as good a time as any,						// add "tweak", if any, for extra space below subtitle						// on "subsequent" panels...						g_panelSubtitleExtra += g_extraSubtitle;					}				}				else {					// matchSlot couldn't make sense of the file's contents					return false;				}			}			else {				// There are docs open; but active doc is not an ongoing chart				// So check if it is the template: the name of the template file to use				// was read in from the Section Prefs file...				try {					// Look for template among open docs					// If template isn't open, this sparks error 1302 ("No such element")					g_myDoc = documents.getByName(g_aiTemplateFile);					// Still here? Template is open -- bring it to front:					g_myDoc.activate();					// Now check for existing page items or more than 1 layer:					if ((g_myDoc.pageItems.length > 0) || (g_myDoc.layers.length > 1)) {						msg = "Template file is already open.\nIs it okay to delete ";						msg += "any items on the page and proceed with the new chart..?";						if (confirm(msg)) {							// Don't re-open template, but clear all layers and items							// except background							for (i = (g_myDoc.layers.length - 1); i >= 0; i--) {								if (!(g_myDoc.layers[i].name == c_backLayerN)) {									g_myDoc.layers[i].locked = false;									g_myDoc.layers[i].remove();								}							}							g_myDoc.pageItems.removeAll();							// No need to trip openTFlag, since template is open						}						else {							// Template is open but has page items							// that user doesn't want to delete. So abort:							return false;						}					}				}				catch (err) {					// If template was not among open docs, which sparked an error					// we jump to here					if (err.number = 1302) {						openTFlag = true;					}					else {						// Unknown error. Report and abort						msg = "This unexpected error occurred while " + c_I +							" was trying to set up the workspace..."						myAlert (msg, err + "(no. " + err.number + ")");						return false;					}				}			}		}		else {			// No docs open: set flag to open template			openTFlag = true;		}		// Check the flag:		if (openTFlag) {			// Template file isn't open. So open it	(-- readonly mod, Feb 09 --)			// Create a file object from the path; assign to global; then open that object			try{				g_myDoc = new File(theFile);				g_myDoc.readonly = true;				open(g_myDoc);				g_myDoc = activeDocument;		//Explicit pointer to document			}			catch (err) {				msg = "Please check that this file exists:\n\n" + theFile;				myAlert(msg, "Unable to open template file...");				return false;			}		}	}	catch (err) {		unexpectedErrorAlert(err, "Startup.setUpDocument", "Template error")		// Bounce the problem up the tree...		throw err;	}	return true;}// End SET UP DOCUMENT// CONVERT SIZES// Called from getStarted// Converts sizes in mm to points. Sadly this is just a long list,// which must be updated if new preferences are introduced...function convertSizes(){	var i;							// counter	var mm = "mm";	if (g_isMM) {		try {			// ------------------			// From General Prefs			g_oneLine *= c_mm	;			for (i in g_chartOrigin) {g_chartOrigin[i] *= c_mm};			for (i in g_detailsOrigin) {g_detailsOrigin[i] *= c_mm};			g_gutterWidth *= c_mm;			g_brokenScaleMargin *= c_mm;			g_brokenScaleSymbolHeight *= c_mm;			// Ticks			g_outTickMargin *= c_mm;			g_inTickMargin *= c_mm;			g_tickStart1 *= c_mm;			g_tickEnd1 *= c_mm;			g_tickStart2 *= c_mm;			g_tickEnd2 *= c_mm;			g_tickStart3 *= c_mm;			g_tickEnd3 *= c_mm;			g_tickStart4 *= c_mm;			g_tickEnd4 *= c_mm;			// Blob measures			g_blobColMargin *= c_mm;			g_blobBarMargin *= c_mm;			// Blob positions relative to col/bar ends can be undefined, so...			if (!g_blobHugCols == undefined) {g_blobHugCols *= c_mm};			if (!g_blobHugBars == undefined) {g_blobHugBars *= c_mm};			// REVAMP: now an array:		  for (i in g_blobBoxMargin) {g_blobBoxMargin[i] *= c_mm};			g_blobBoxStrokeWidth *= c_mm;			//			g_barLabelMargin *= c_mm;			g_indexWidth *= c_mm;			g_cbDefault *= c_mm;			g_cbGap *= c_mm;			g_cbWideGap *= c_mm;			for (i in g_barDepths) {g_barDepths[i] *= c_mm};			g_barDepthExtra *= c_mm;			// Keys			g_keyLineLength *= c_mm;			// Key box size is an array:			for (i in g_keyBoxSize) {g_keyBoxSize[i] *= c_mm};			g_keyLabGap *= c_mm;			g_keyLinkStrokeWidth *= c_mm;			// ------			// Data B			g_chartHeight *= c_mm;			g_chartWidth *= c_mm;			g_extraTitle *= c_mm;			g_extrasubTitle *= c_mm;			g_ssLeftMargin *= c_mm;			// -------------			// Section Prefs			// Boxes			g_height *= c_mm;			// (not actually used!)			g_width *= c_mm;			for (i in g_columns) {g_columns[i] *= c_mm};			g_bb1StrokeAllWidth *= c_mm;			for (i in g_bb1StrokeAllDash) {g_bb1StrokeAllDash[i] *= c_mm};			g_bb1StrokeTopWidth *= c_mm;			for (i in g_bb1StrokeTopDash) {g_bb1StrokeTopDash[i] *= c_mm};			g_bb1StrokeBottomWidth *= c_mm;			for (i in g_bb1StrokeBottomDash) {g_bb1StrokeBottomDash[i] *= c_mm};			g_bb2OriginX *= c_mm;		// relative to bb1			g_bb2OriginY *= c_mm;			g_bb2Width *= c_mm;			g_bb2Height *= c_mm;			g_bb2StrokeWidth *= c_mm;			// Title			g_titleOriginX *= c_mm;			g_titleOriginY *= c_mm;			g_subtitleOriginXNoPanel *= c_mm;			g_subtitleOriginYNoPanel *= c_mm;			g_subtitleOriginXPanel *= c_mm;			g_subtitleOriginYPanel *= c_mm;			// Source			g_sourceSpaceAbove *= c_mm;			g_sourceOriginX *= c_mm;			g_sourceOriginY *= c_mm;			// Footnote			g_footnoteOriginX *= c_mm;			g_footnoteOriginY *= c_mm;			// Inner box			g_innerBoxLeftMargin *= c_mm;			g_innerBoxRightMargin *= c_mm;			g_innerBoxBottomMargin *= c_mm;			// Panels			g_panelSpaceAbove *= c_mm;			g_panelStrokeWidth *= c_mm;			// Category scale string			g_catLabelSpaceAbove *= c_mm;			// Vertical Scale ticks			g_scaleSpaceAbove *= c_mm;			g_vScaleDefaultStrokeWidth *= c_mm;			g_vScaleIndexStrokeWidth *= c_mm;			g_vScaleBaseStrokeWidth *= c_mm;			g_vScaleLength *= c_mm;			// Horizontal/category scale			g_hScaleMainSpaceAbove *= c_mm;			g_hScaleInternalSpaceAbove *= c_mm;			// Horizontal/category scale strings			g_hScaleTickStrokeWidth *= c_mm;			// TRACES			// Lines			g_accumSetTopStrokeWidth *= c_mm;			g_accumSetOtherStrokeWidth *= c_mm;			g_tLine1StrokeWidth *= c_mm;			g_tLine2StrokeWidth *= c_mm;			g_tLine3StrokeWidth *= c_mm;			g_tLine4StrokeWidth *= c_mm;			g_tLine5StrokeWidth *= c_mm;			g_tLine6StrokeWidth *= c_mm;			g_tLine7StrokeWidth *= c_mm;			g_tLine8StrokeWidth *= c_mm;			g_tLine9StrokeWidth *= c_mm;			g_tLine10StrokeWidth *= c_mm;			// COLUMNS / BARS			g_tCB1StrokeWidth *= c_mm;			g_tCB2StrokeWidth *= c_mm;			g_tCB3StrokeWidth *= c_mm;			g_tCB4StrokeWidth *= c_mm;			g_tCB5StrokeWidth *= c_mm;			g_tCB6StrokeWidth *= c_mm;			g_tCB7StrokeWidth *= c_mm;			g_tCB8StrokeWidth *= c_mm;			g_tCB9StrokeWidth *= c_mm;			g_tCB10StrokeWidth *= c_mm;			// SCATTERS			g_tScatterSize *= c_mm;			g_tScatter1StrokeWidth *= c_mm;			g_tScatter2StrokeWidth *= c_mm;			g_tScatter3StrokeWidth *= c_mm;			g_tScatter4StrokeWidth *= c_mm;			g_tScatter5StrokeWidth *= c_mm;			g_tScatter6StrokeWidth *= c_mm;			g_tScatter7StrokeWidth *= c_mm;			g_tScatter8StrokeWidth *= c_mm;			g_tScatter9StrokeWidth *= c_mm;			g_tScatter10StrokeWidth *= c_mm;			// PIES			g_pieStrokeWidth *= c_mm;			// TABLES			g_tHeadSpaceAbove *= c_mm;			g_tRuleAWidth *= c_mm;			for (i in g_tRuleADash) {g_tRuleADash[i] *= c_mm};			g_tRuleBWidth *= c_mm;			for (i in g_tRuleBDash) {g_tRuleBDash[i] *= c_mm};			g_tRuleBelow==2.25;			return true;		} // Try ends		catch (err) {			myAlert("I failed to convert measurements from millimetres to points. Sorry...", "Measurements failure")			return false;		}	} // If ends	else {		// Points: no conversion -- apart from overall height and width		// if they include "mm"		try{			if (g_chartHeight.toString().search(mm) > -1) {				g_chartHeight = trimAll(g_chartHeight.toString().replace(mm,""));				g_chartHeight *= c_mm;			}			if (g_chartWidth.toString().search(mm) > -1) {				g_chartWidth = trimAll(g_chartWidth.toString().replace(mm,""));				g_chartWidth *= c_mm;			}			return true;		} // Try ends		catch (err) {			alert(err)			myAlert("I failed to convert chart size from millimetres to points. Sorry...",				"Measurement conversion failure")			return false;		}	} // Else ends}// CONVERT SIZES ends// REDUNDANT// GET INSTALLATION NO.// Either:// 1) --// 	Called from getStarted for scratch files, in which case it looks in the Ilex// 	application folder(the parent of the hard-coded "temp" folder [prev'y jsInclude])//	 for the file "Local Prefs.txt". Extracts the installation number (1-3) and// 	parks it in the global g_installation...// 2) --//	Called from SaveCCI for existing file, in which case it looks for an installation//	number in a layer in the file... (if this fails, recurses to 1)function getInstallationNo()// Arg 1:	true on initial chart processing, which refers to Local Prefs file// 			false if existing chart is being saved to CCI (refers to Originator layer)// Arg 2:	undefined in first case; a document object in 2nd case{	var lpFile;		// local prefs file name	var iStrings;		// text in local prefs file	var i;			// counter	var n;			// looping layer name	var oString;		// originator layer name	var pattern;	var s;	var splitFlag = false;	var oLayerFound = false;	var oLayer;	var iNoGot;	alert("Called redundant function getInstallationNo");	return;	// Find application folder (containing prefs file), which is parent of	// hard-coded Temp folder (prev'y Include)...	// g_iFolder = new Folder(checkSep(c_includeFolder)).parent;	g_iFolder = new Folder(checkSep(c_tempFolder)).parent;	// Initial chart processing looks in Local Prefs file	if (fromPrefs) {		// Local Prefs file:		lpFile = g_iFolder.absoluteURI + c_pS + c_localPrefsFile;		// Read in about six lines of text		iStrings = readInFile(lpFile);		if (iStrings) {			if (!parseLookup(iStrings, c_localPrefsFile)) {				return false;			}		}		else {			// Invalid result:			myAlert ("Unable to retrieve installation number \n (Start_up.getInstallationNo)", "General error");			return false;		}	}	else {		// Saving *existing* file to CCI		// Loop through layers to identify Originator layer --		for (i = 0; i < aDoc.layers.length; i ++) {			n = aDoc.layers[i].name;			if (n.search(c_originatorLayerN) == 0) {				// Originator layer identified by label -- assign				oLayer = aDoc.layers[i];				oString = n;			}		}		// If I find an originator layer and it has a valid separator -- "(" -- trip flag		if (oString != undefined) {			if (oString.search(/\(/) != -1) {				splitFlag = true;			}		}		if (splitFlag) {			// Originator string found, in format "Researcher: Name (1) // Cartographer: Name"; [or 2, or 3]			//s = oString.split("//")[0];			s = oString.split("(")[1];			g_installation = s.charAt(0);		}		else {			// Installation number not found; recurse using alternative arguments			// to search Local Prefs file			msg = "I think I'm supposed to be re-saving this file to the drop folder, but I can't find " +				"the installation number that should be embedded in the file. So I'm digging " +				"out a number from the current preferences and saving to the corresponding location..."			myAlert(msg,"Drop folder problem");			iNoGot = getInstallationNo(true, undefined);			if (iNoGot) {				if (oLayer != undefined) {					// Append install number to file					var isL = oLayer.locked;					oLayer.locked = false;					oLayer.name = oLayer.name + " (" + g_installation + ")";					oLayer.locked = isL;				}			}			return iNoGot;		}	}	// Check that g_installation now contains a valid number between 1 and 3	if (!isNaN(g_installation)) {		if ((g_installation > 0) && (g_installation < 4)) {			return true;		}	}	// Still here?	return false;}// GET INSTALLATION NO. ends