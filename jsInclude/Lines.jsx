/* Line/stepline tracesCreated 15.12.05Updated 05.05.09 (modded drawLine for proper looping back of Graphic Style numbers)- drawLine	Controls drawing of ONE trace line/stepline- drawIndexButton	Creates index blob- tLineObject	Creates a JS object whose properties define a trace line- stepPoints	Converts regular line trace points to points for a stepline- calcXPoints	Generates array of horizontal positions for points	(Is this called from other modules?)- addLineBreakBox	draws blob if line breaks scale*/// Local globals to accumulate values...var local_accumulatedPointsStroke;var local_accumulatedPointsFill;// $.level = 1;// DRAW LINE// Called from Main.drawTraces to draw ONE trace (line or stepline)// Creates trace line object whose properties define this line trace// Calls line constructor to draw actual linefunction drawLine(pts, tNo, allT, lT, toLeft, isStep)// Args are 		array of points (actual values or "*" for blanks)//				trace number (from 1)//				number of traces//				last trace flag//				left/right scale flag//				stepLine flag{	var thisTLineA;	// objects whose properties define the line	var thisTLineB;	// (thisTLineA defines fill; thisTLineB defines stroke)	var myTLine;		// path object	var keyObj;		// path object (line or fill) to pass to key constructor	var myBlobs;	var i;			// counter (blobs)	var accum = false;	var j = 0;		// another blobs counter (see below)	var keyStyling;    // Graphic style numbers loop back after a certain number of traces	var tStyleNo = tNo;	while (tStyleNo > c_traceLoopNo) {tStyleNo -= c_traceLoopNo};	var initAccumArray = false;	if (toLeft) {		if (g_accumulate[0]) {accum = true;}	}	else {		if (g_accumulate[1]) {accum = true;}	}	// Initialise arrays for accumulation of values, left/right	if (accum) {		if (g_doubleScale > 0) {			if (toLeft && (tNo === 1)) {				initAccumArray = true;			}			else if (!toLeft && (tNo === g_doubleScale)) {				initAccumArray = true;			}		}		else {			if (tNo === 1) {				initAccumArray = true;			}		}	}	if (initAccumArray) {		local_accumulatedPointsStroke = [];		local_accumulatedPointsFill = [];	}	// Accumulation	if (accum && !g_accumKeyByLines) {		// If keyed by fill, I need separate, grouped fill and line pathItems		// Group fill and stroke		g_accumGroup = g_traceLayer.groupItems.add();		g_accumGroup.name = c_accumGroupN + tNo;		// Create two objects: fill and stroke -- fill first		thisTLineA = new tLineObject(pts,tNo,false,true,lT,toLeft,isStep,true);		// fill		// Primitive constructor		myTLine = makeLine(g_accumGroup,thisTLineA.points,thisTLineA.fFlag,thisTLineA.fCol,			thisTLineA.sFlag,thisTLineA.sWidth,thisTLineA.sCol,thisTLineA.lineEnd,thisTLineA.lineMiter,			thisTLineA.miterLimit,thisTLineA.name,thisTLineA.note);		// -- now stroke		thisTLineB = new tLineObject(pts,tNo,true,false,lT,toLeft,isStep,true);		// stroke		myTLine = makeLine(g_accumGroup,thisTLineB.points,thisTLineB.fFlag,thisTLineB.fCol,			thisTLineB.sFlag,thisTLineB.sWidth,thisTLineB.sCol,thisTLineB.lineEnd,thisTLineB.lineMiter,			thisTLineB.miterLimit,thisTLineB.name,thisTLineB.note);		// Each group is placed immediately before vertical scale ticks (behind any prev. accumGroups)...		g_accumGroup.move(g_vScaleTickGroup, ElementPlacement.PLACEBEFORE);		// But on last trace, move top stroke to front:		if (tNo == allT) {			g_accumGroup.pathItems[0].move(g_traceLayer, ElementPlacement.PLACEATBEGINNING);		}		// Remember fill attributes for key object construction call below		keyObj = thisTLineA;		// Accumulated: fool the key generator into matching fill...		keyStyling = c_generalColConst;	}	else {		// Non-accumulated		// Do we have a fill?		if (g_nonAccumLineFill) {			thisTLineA = new tLineObject(pts,tNo,false,true,lT,toLeft,isStep,false)			// Primitive constructor			myTLine = makeLine(g_traceLayer,thisTLineA.points,thisTLineA.fFlag,thisTLineA.fCol,				thisTLineA.sFlag,thisTLineA.sWidth,thisTLineA.sCol,thisTLineA.lineEnd,thisTLineA.lineMiter,				thisTLineA.miterLimit,thisTLineA.name,thisTLineA.note);				// Send to behind h-Scale ticks				myTLine.move(g_vScaleTickGroup, ElementPlacement.PLACEAFTER)		}		// Always stroke:		thisTLineB = new tLineObject(pts,tNo,true,false,lT,toLeft,isStep,false)		myTLine = makeLine(g_traceLayer,thisTLineB.points,thisTLineB.fFlag,thisTLineB.fCol,			thisTLineB.sFlag,thisTLineB.sWidth,thisTLineB.sCol,thisTLineB.lineEnd,thisTLineB.lineMiter,			thisTLineB.miterLimit,thisTLineB.name,thisTLineB.note,thisTLineB.lineDash);		// Graphic style? (over-rides existing line attributes)		// (Note: line Style must not have built-in fill, which would cover objects below)		if (g_tLineStyle) {			g_myDoc.graphicStyles[c_generalLineConst + " " + tStyleNo].applyTo(myTLine);		}		// Index (non-accumulated only)		if (lT && g_isIndex) {			drawIndexButton(thisTLineB.points[0]);		}		// Remember stroke attribues for key object construction call below		keyObj = thisTLineB;		keyStyling = c_generalLineConst;	}	// Stepline: run through filter in site-specific module	if (isStep) {		steplineFilter(myTLine)	}	// Insert blobs where line breaks scale? (if, of course, it does...)	if (!(g_breakTopScale == 0)) {		for (i = 0; i < myTLine.pathPoints.length; i ++) {			if (myTLine.pathPoints[i].anchor[1] > g_innerBox.top) {				addLineBreakBox(myTLine.pathPoints[i].anchor[0], pts[i])			}		}	}	// Blobs	// Blobs for this trace? (all done together for lines)	myBlobs = traceHasBlobs(tNo, allT);	// left undefined if no blobs (function in Utilities)	if (myBlobs !== undefined) {		// Set up a group		g_blobGroup = g_panelLayer.groupItems.add();		g_blobGroup.name = c_blobGroupN + tNo;		// Blob headers(s) (in GenTraces)		drawBlobHeads()		// To draw blobs, loop on blob strings		// (I originally assumed same no. of blobs as points; but this won't wash. If the data includes "blank" ["*"] points,		//		the array of trace points [thisTLineA/B] only contains as many elements as there are actual points.		//		So I have a separate counter [j] which keeps track of all [existing or "skipped"] points...)		for (i = 0; i < myBlobs.length; i ++) {		// for (i = 0; i < thisTLineB.length; i ++) {			// Check that this isn't a skipped point in the original, complete points array			if (pts[i] !== c_skipConst) {				// "Actual" point exists, so blob is a possibility				// (I call same function as columns; fcn in Columns module)				//				// Kludge, 31.8.16				// My counters are getting out of step. So if the last point in the 'j' cycle comes up				// undefined, use last available...				var jPoint = thisTLineB.points[j];				if (jPoint === undefined) {					jPoint = thisTLineB.points[thisTLineB.points.length - 1];				}				addColBlob(jPoint[0], j + 1, myBlobs[i], jPoint[1]);				// addColBlob(thisTLineB.points[i][0], i + 1, myBlobs[i], thisTLineB.points[i][1]);				j ++;	// Increment counter used to extract points from trace object (which excludes "skipped" points)			}		}	}	// Add key object to array...	g_keyArray[tNo-1] = new keyObject(tNo, keyStyling, keyObj, 0, toLeft);	if (accum && !g_accumKeyByLines) {		return g_accumGroup;	}	else {		return myTLine;	}}// DRAW LINE ends// DRAW INDEX BUTTON// Called from drawLine to draw Index buttonfunction drawIndexButton(c)// Arg is centre point of button{	// Only drawn if width > 0	if (g_indexWidth > 0) {		g_indexBlob = makeEllipse(g_traceLayer,c,g_indexWidth,g_indexWidth,			true,g_indexCMYK,			false,undefined,undefined,			"","");	}}// DRAW INDEX BUTTON ends//$.level = 1;// T-LINE OBJECT// Called from drawLine// Constructor for an object whose properties define a trace linefunction tLineObject(ptArray,tNo,hasStroke,hasFill,isLast,toLeft,isStep, accumulated)// Args are: 		array of *raw* trace values//				trace number//				stroke?//				fill?//				last trace?//				left/right scale//				stepline? (or "normal"?)//				accumulation flag{	var i;	var j = 0;	// Line styles loop after a certain point...	var tStyleNo = tNo;	var thisBase;	var accArray;	var clonePtArray = ptArray.slice(0);	var initAccumArray = false;	if (hasStroke) {accArray = local_accumulatedPointsStroke;}	else {accArray = local_accumulatedPointsFill;}	//	if (accumulated) {		if (g_doubleScale > 0) {			if (toLeft && (tNo === 1)) {				initAccumArray = true;			}			else if (!toLeft && (tNo === g_doubleScale)) {				initAccumArray = true;			}		}		else {			if (tNo === 1) {				initAccumArray = true;			}		}	}	while (tStyleNo > c_traceLoopNo) {tStyleNo -= c_traceLoopNo};	// Coordinates	var xArray = new Array(clonePtArray.length);		// horizontal coords	var yArray = new Array(clonePtArray.length);		// vertical coords	// What I want is an array, each of whose elements is a 2-slot array	// consisting of a vertical and horizontal co-ordinate	var lineArray = new Array(clonePtArray.length);	//	//$.bp();	// Y-coords within g_InnerBox. And	for (i = 0; i < clonePtArray.length; i ++) {		// Accumulation:		if (accumulated) {			// Set up default on first left/right loop			if (initAccumArray) {				accArray.push(0);			}			if ( (clonePtArray[i] !== "*") && (accArray[i] !== "*") ) {				clonePtArray[i] += accArray[i];				accArray[i] = clonePtArray[i];			}		}		yArray[i] = calcYValuePos(clonePtArray[i],toLeft);	}	// Pass back:	if (hasStroke) {local_accumulatedPointsStroke = accArray;}	else {local_accumulatedPointsFill = accArray;}	// X-coords	xArray = calcXPos(clonePtArray.length);	// Combine arrays	for (i = 0; i < clonePtArray.length; i ++) {		// If there is a skipped value ("*"), don't pass to		// combined array, which is shortened by 1 element		if (yArray[i] == undefined) {			lineArray.pop();		}		else {			// Combined array uses separate counter to allow for skipped values			lineArray[j] = Array(xArray[i],yArray[i]);			j ++;		}	}	// If stepline, filter points (array is modded by ref)	if (isStep) {lineArray = stepPoints(lineArray)};	// If the path has a fill, anchor to baseline by adding 3 more points:	// I want h-coords of 1st and last points (since line may not	// extend entire width of inner box)	if (hasFill) {		var a = lineArray[0][0];		var b = lineArray[lineArray.length - 1][0];		if (accumulated) {			// Accum'd anchors to bottom of chart			lineArray.push(Array(b, g_innerBox.top - g_innerBox.height));			lineArray.push(Array(a, g_innerBox.top - g_innerBox.height));			lineArray.push(Array(a, lineArray[0][1]));		}		else {			// Mod for inverted line fills (attach to top!), Oct 2008			if (toLeft) {				if (g_invertedScaleA) {					// Inverted, left					thisBase = g_innerBox.top;					// if (g_isBS[0]) {thisBase -= g_brokenScaleMargin};				}				else {					// Non-inverted, left					thisBase = g_cbBase[0];					if (g_isBS[0]) {thisBase -= g_brokenScaleMargin};				}			}			else {				if (g_invertedScaleB) {					// Inverted, right					thisBase = g_innerBox.top;					// if (g_isBS[1]) {thisBase -= g_brokenScaleMargin};				}				else {					// Non-inverted, right					thisBase = g_cbBase[1]					if (g_isBS[1]) {thisBase -= g_brokenScaleMargin};				}			}			lineArray.push(Array(b, thisBase));	//g_innerBox.top - g_innerBox.height));			lineArray.push(Array(a, thisBase));	//g_innerBox.top - g_innerBox.height));			lineArray.push(Array(a, lineArray[0][1]));		}	}	this.points=lineArray;	// Fill depends upon accumulation and style; set fill anyway	this.fFlag = hasFill;	if (accumulated) {		// Accumulated fills rotate		eval("this.fCol = g_tLine" + tStyleNo + "FillCMYK");	}	else {		// Non-accumulated fills (if they exist) are all the same		this.fCol = g_nonAccumLineFillCMYK;	}	// Stroke (again, set stroke and fill anyway)	this.sFlag = hasStroke;	if (accumulated) {	// Accumulation stroke		if (g_accumKeyByLines) {			// Accumulation is keyed by lines, so use line trace prefs			eval("this.sWidth = g_tLine" + tStyleNo + "StrokeWidth");			eval("this.sCol = g_tLine" + tStyleNo + "StrokeCMYK");		}		else {			// Accumulation is keyed by fill, so use set strokes			if (isLast) {				this.sWidth = g_accumSetTopStrokeWidth;				this.sCol = g_accumSetTopStrokeCMYK;			}			else {				this.sWidth = g_accumSetOtherStrokeWidth;				this.sCol = g_accumSetOtherStrokeCMYK;			}		}	}	else {		// Non-accum stroke		// Width		eval("this.sWidth = g_tLine" + tStyleNo + "StrokeWidth");		// Colour is subject to double-scale override:		if (g_doubleScale > 0) {			// Double scale			if (tNo == 1) {				// Left-scale trace 1 uses Left1				this.sCol = g_doubleScaleLeftTrace1CMYK;			}			else if (tNo <= g_doubleScale) {				// Other left-scale series				this.sCol = g_doubleScaleLeftTrace2CMYK;			}			else if (tNo === (g_doubleScale + 1)) {				// Right-scale trace 1 uses Left1				this.sCol = g_doubleScaleRightTrace1CMYK;			}			else {				// Other right-scale series				this.sCol = g_doubleScaleRightTrace2CMYK;			}		} else {			// Non-double: use trace-numbered colour			eval("this.sCol = g_tLine" + tStyleNo + "StrokeCMYK");		}		// Pre-revamp:		/*		if ((g_doubleScale > 0) && (tNo == 1)) {			// Doublecscale trace 1 uses Left1			this.sCol = g_doubleScaleLeft1TraceCMYK;		}		else if ((g_doubleScale > 0) && (tNo == (g_doubleScale + 1))) {			// Doublecscale trace 1 uses Left1			this.sCol = g_doubleScaleRight1TraceCMYK;		}		else {			// Non-double and/or all traces after second use trace-numbered colour			eval("this.sCol = g_tLine" + tStyleNo + "StrokeCMYK");		}		*/	}	// Trace-specific line ends and dash	// this.lineEnd = g_tLineEnd;	eval("this.lineEnd = g_tLine" + tStyleNo + "End");	eval("this.lineDash = g_tLine" + tStyleNo + "Dash");	// Other	this.lineMiter = g_tLineMiter;	this.miterLimit = g_tLineMiterLimit;	if (hasFill) {this.name = c_tLineN + "fill " + tNo};	else {this.name = c_tLineN + "stroke " + tNo};	this.note = this.name;}// LINE OBJECT ends// STEP POINTS// Called from lineObject// Converts a regular array of line co-ords into stepline,// dropping superfluous points (value doesn't change)function stepPoints(spArray)// Arg is array of coords{	var preVal;		// holds value from previous loop	var i;			// counters	var j = 0;	var temp = new Array();	for (i = 0; i < spArray.length; i++) {		// Loop through points...		if (i == 0) {			// Always create first point			temp[j] = Array(spArray[i][0],spArray[i][1]);			j ++		}		else if (i == spArray.length - 1) {			// Always draw last point			// But if final value changed, insert preceding to make step			if (!(spArray[i][1] == preVal)) {				// value changes: draw step point at previous value				temp[j] = Array(spArray[i][0],preVal);				j ++			}			// Final point			temp[j] = Array(spArray[i][0],spArray[i][1]);			j ++		}		else {			// Subsequent points			if (!(spArray[i][1] == preVal)) {				// value changes: draw step points at previous and new values				temp[j] = Array(spArray[i][0],preVal);				j ++				temp[j] = Array(spArray[i][0],spArray[i][1]);				j ++			}		}		// Always remember current value for next loop...		preVal = spArray[i][1]	}	// // // PREVIOUS CODE DID NOT DISCARD UNCHANGED POINTS	//		if ((i > 0) &&  (!(spArray[i][1] == preVal))) {	//			temp[j] = Array(spArray[i][0],preVal);	//			j ++;	//		}	//		// "Current" value	//		temp[j] = Array(spArray[i][0],spArray[i][1]);	//		j ++;	//		preVal = spArray[i][1];	// remember this value for next loop	return temp;}// STEP POINTS ends// CALC X-POSfunction calcXPos(pNo)// Arg is the number of points{	var i;										// counter	var xpArray = Array(pNo);					// array to return	var xMove = g_innerBox.width / (pNo - 1);	// x-distance between points	var thisP = g_innerBox.left;				// current position	for (i = 0; i < pNo; i ++) {		xpArray[i] = thisP;		thisP += xMove;	}	return xpArray;}// CALC X-POS ends// ADD LINE BREAK BOX// Draws a "blob" if line breaks scale topfunction addLineBreakBox(xPos, s)// Args are		horizontal (x) centre//				string{	var bG;						// group	var bBox;					// box	var bRange;					// text range	var bPts = Array(3);			// box coords	var sPts = Array(1);			// text anchor	var bCentre = Array(1);		// centre coords	var bSize;					// string size	var tempSize;	// Force s to string:	s += ""	// Group for this box and string:	bG = g_traceLayer.groupItems.add();	bG.name = "Line break label";	// Get actual size of string	bSize = new getTFrameSize(s, g_blobFontName, g_blobFontSize, 100, true, false);	// Commas in the number string throw the size off, so...	if (s.search(",") > -1 ) {		tempSize = new getTFrameSize("0", g_blobFontName, g_blobFontSize, 100, true, false)		bSize.height = tempSize.height	}	// Calculate box width & height (actual text size plus inner margin)	// REVAMP: w/h array from lookup:	g_blobSize[0] = bSize.width + (g_blobBoxMargin[0] * 2);	g_blobSize[1] = bSize.height + (g_blobBoxMargin[1] * 2);	// Get centre point	// Vertical position above inner box top (REVAMP: lookup is array)	bCentre[1] = g_innerBox.top + g_blobBoxMargin[1] + (g_blobSize[1] / 2);	// horizontal centre	bCentre[0] = xPos;	bPts[0] = bCentre[1] + (g_blobSize[1] / 2);	// top	bPts[1] = bCentre[0] - (g_blobSize[0] / 2);	// left (yes, I know there's redundancy here...)	bPts[2] = g_blobSize[0];						// width	bPts[3] = g_blobSize[1];						// height	// Draw box	bBox = makeRect(bG, bPts, g_blobBoxFillFlag, g_blobBoxFillCMYK,		g_blobBoxStrokeFlag, g_blobBoxStrokeWidth, g_blobBoxStrokeCMYK,		bG.name, bG.name);	// String (centre aligned)	sPts[1] = bCentre[0];	sPts[0] = bCentre[1] - (bSize.height / 2);	bRange = makeText(bG, sPts, g_blobFontCMYK,		g_blobFontName, g_blobFontSize, g_blobFontSize, c_cConst, 0, 100,		0, false ,s, bG.name, bG.name, true);}// ADD LINE BREAK BOX ends