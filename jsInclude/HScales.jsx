/* Horizontal scalesonticksCreated 12.12.05Updated 13.01.09 	(Mods to marginAdjust hopefully tweak margins more accurately for label/cluster width)                  (BUT BEWARE OF SOME POSSIBLY INFERENTIAL CODE)Updated 14.01.09	Mods to drawHValScale to draw global minus on all-negative scales (ie zero is top val)Updated 27.01.09	More mods to marginAdjust, which I need to keep an eye on...Updated 03.02.09	Mods to drawHValScale to reduce fontsize of global +/–Updated 04.02.09	Mod to yString kluges string valuesUpdated 11.02.09	Bugfix in drawHValScale (global +/–)Updated 08.07.09	drawHVTicks trips flag to generate duplicate baseline...- drawHScaleDates	top-level: h-scales with date series- drawHScaleNames	top-level: h-scales with names- drawHScaleValues	top-level: h-scales with values (bars and scatters)- drawHScaleThermo	top-level: thermometer scale- makeLabel	draws actual label (and returns textframe object)- mOrQString	formats month/quarter strings (Mmm/M/Qn…)- yString	formats year strings (yyyy/yy)- makeTick	draws actual tick- testBound	determines date changes and tick lengths- getMyQ	converts month (1-12) to quarter (1-4)- createFakeDate	creates false dates at start & end of series, for comparison- marginAdjust	tweaks left and right margins	I MAY WANT TO DROP THIS AND TWEAK HORIZONTAL SCALES RETROSPECTIVELY…- scaleAttributes	sets scale level and increment properties- setLevel	calculates level/increment from time series- populateHScale	creates array of values & tick positions for bar/scatter scales- drawHValScale	called from drawHScaleValues to draw the actual scale- makeBarLabelSpace	calculates width of labels margin on bar scales- drawHVTicks	draws bar/scatter ticks*/// $.level=1;// DRAW H-SCALE DATES// Controls all horizontal scale procedures// Called from Main.Ilexfunction drawHScaleDates(){	var pointSeries;		// series by which points are drawn	var tickSeries;		// by which ticks are drawn	var labelSeries;		// by which labels are drawn	var myScale;			// attributes holder	var localCatArray;	// array of cat values, with "fake" value prefixed	var catTotal;	var slotWidth;	var i;				// counters	var j;	var thisDate;		// current and next dates in series	var nextDate;	var tickBound;		// levels at which ticks and labels are drawn...	var labelBound;	var slotPos;			// slot hPos	var tCount = 1;					// counter values appended to tick/label name/note	var lCount = 1;	var lPosCount = Array(0,0,0);		// counters for label_1/2/3 positioning (multiples of slotWidth)	var labelLine;					// controls which scale line label is drawn on	var finalPoint = false;			// flags final point (to force end tick/label)	var onTicks = false;				// flags labels on ticks	var vertPos;	var firstLabel = true;			// tripped when first label is drawn	var tickFlag = true;				// disallows ticks for column / zero baseline / "on" ticks	var thisSymbol;					// Individual footnote symbols extracted from array	var thisLabel;					// Textframe returned by makeLabel	var thisTick;					// Pathitem returned by makeTick	var fSymbAnchor;					// A label text frame that could have a footnote attached...									// ...or a tick or trace point relative to which it is positioned...	var symbFrame;					// Symbol text frame and co-ords	var symbOrigin;// If scale is at top, labels are drawn in descending rows	// if (g_scaleTop) {g_hScaleInternalSpaceAbove = (0 - g_hScaleInternalSpaceAbove)};	// Series at three levels: points, ticks & labels	pointSeries = g_timeSeries[0];	tickSeries = g_timeSeries[1];	labelSeries = tickSeries;		// by default	// Create object with properties point/tick/label___Level/Increment	myScale = new scaleAttributes(pointSeries, tickSeries, labelSeries);	// I'm not entirely sure about this, but...	// If the label width check (in vScales!) said "no sub-scale",	// shift the "level" up one notch (unless already at top)...	if ((g_line2ScaleFormat == 0 ) && (myScale.labelLevel < 4)) {		myScale.labelLevel += 1;		myScale.labelIncrement = 1;	}	// Inner margin(s) at side(s)	// Check increments to verify if sides exist:	if (g_incrementA !== undefined) {		// Left scale exists		g_innerBox.left += g_inTickMargin;		g_innerBox.width -= g_inTickMargin;	}	else {		// No left scale (and therefore no BS)		g_innerBox.left += g_inTickOtherMargin;		g_innerBox.width -= g_inTickOtherMargin;	}	if (g_incrementB !== undefined) {		// Right scale exists		g_innerBox.width -= g_inTickMargin;	}	else {		// No right scale		g_innerBox.width -= g_inTickMargin;	}	// But REVAMP needs to check for width of any broken scale symbol	// If there's a broken scale symbol, this is the margin it requires (from edge of 'original' inner box):	if (g_isRevamp) {		var bsMargin = g_brokenScaleSymbolWidth + g_inTickMargin;		if (g_isBS[0]) {			// Left scale breaks (and therefore, presumably, exists...)			// Get the margin I set just above:			var currentMargin = g_innerBox.left - g_originalInnerBox.left;			// Is that current margin less than a BS requires?			var marginDiff = bsMargin - currentMargin;			if (marginDiff > 0) {				g_innerBox.left += marginDiff;				g_innerBox.width -= marginDiff;			}		}		// and...		if (g_isBS[1]) {			// Right scale			// Get right margin (original right - current right)			currentMargin = (g_originalInnerBox.left + g_originalInnerBox.width) - (g_innerBox.left + g_innerBox.width);			// If BS needs more space, deliver it:			marginDiff = bsMargin - currentMargin;			if (marginDiff > 0) {				g_innerBox.width -= marginDiff;			}		}	}	// So innerbox is now at "ideal" left and right margins. Since the inner box will be	// thrown around the place, remember these positions so that margins can, if	// necessary, be adjusted after scale has been drawn	g_traceArena = Array(g_innerBox.left, g_innerBox.left + g_innerBox.width)	// ON or BETWEEN ticks?	// If this is a line/stepline/scatter(?) chart,	// labels are drawn "on" ticks for all names; and for years if GP set to "on"	if (		(			// Whacky formatting, hopefully to clarify conditions...			(g_chartStyle[0] == c_lineConst) || (g_chartStyle[1] == c_lineConst) ||			(g_chartStyle[0] == c_lineStackedConst) || (g_chartStyle[1] == c_lineStackedConst) ||			(g_overallStyle[0] == c_generalColConst) || (g_overallStyle[1] == c_generalColConst) ||			(g_chartStyle[0] == c_stepLineConst) || (g_chartStyle[1] == c_stepLineConst) ||			(g_chartStyle[0] == c_scatterConst) || (g_chartStyle[1] == c_scatterConst)			)			&&			((pointSeries == c_yearConst) && (!g_yearsBetween))			// ...ends		) {		onTicks = true;		catTotal = g_catArray.length;		// Columns ON tick: allow for cluster width		if ((g_overallStyle[0] == c_generalColConst) || (g_overallStyle[1] == c_generalColConst)) {			// If there is just one trace, there may be no gap between clusters...			if ((g_valArray.length == 1) && (g_oneTraceNoGap)) {				// No gap				slotWidth = (g_innerBox.width) / catTotal;				slotPos = g_innerBox.left + (slotWidth/2);				// Adjust inner box to first and last ticks:				g_innerBox.left = slotPos;				g_innerBox.width -= (slotWidth);			}			else {				// One or more traces, with gap...				slotWidth = (g_innerBox.width + g_cbGap) / catTotal;				slotPos = g_innerBox.left - (g_cbGap / 2) + (slotWidth/2);				g_innerBox.left = slotPos;				g_innerBox.width -= (slotWidth - g_cbGap);			}		}		else {			slotPos = g_innerBox.left;			slotWidth = g_innerBox.width / (catTotal - 1);		}		localCatArray = g_catArray;	}	else {		// "Between" ticks		// Prefix "fake" slot to array of categories		nextDate = createFakeDate(new Date(g_catArray[0]), myScale, false);		localCatArray = Array(nextDate);		localCatArray = localCatArray.concat(g_catArray);		catTotal = localCatArray.length;		slotWidth = g_innerBox.width / (catTotal - 1);		// Adjust inner box to mid-slot, both ends		g_innerBox.left += slotWidth/2;		g_innerBox.width -= slotWidth;		// "Fake" tick is one slot left of inner box		slotPos	= g_innerBox.left-slotWidth;		// Prefix element to footnote symbols array to match "fake" slot		g_catFootnotes.splice(0,0,"") // (should 3rd arg be 'undefined'?)	}	// GROUPS	// Create ticks group...	g_hScaleTickGroup = g_panelLayer.groupItems.add();	g_hScaleTickGroup.name = c_hScaleTickGroupN;	// ... and labels group	g_hScaleStringGroup = g_panelLayer.groupItems.add();	g_hScaleStringGroup.name = c_hScaleStringGroupN;	// Ticks are NOT drawn if the following are ALL true:	//		style = column (any sort)	//		lowest value > 0 (i.e. scale broken or from zero)	//		points are ON ticks	if (		(g_overallStyle[0] == c_generalColConst) || (g_overallStyle[1] == c_generalColConst) &&		onTicks &&		((g_lowA == undefined) || (g_lowA >= 0)) &&		((g_lowB == undefined) || (g_lowB >= 0))	)	{		tickFlag = false;		// Flag is checked before drawing ticks inside loop, below	}	// Set flag that indicates whether footnote symbols attach to:	//		2 = labels	//		1 = ticks	//		0 = trace points	if (myScale.labelLevel == myScale.pointLevel) {		g_catSymbolAttachLevel = 2;		// 	UNSURE ABOUT THIS ADJUSTMENT:::::::::::::::::::::::::::::::::::		//	At least, couldn't it be more elegant? The idea is that if		//	we're quarterly we won't find monthly ticks/labels to anchor on		//	and should move down to ticks/points level...		if (myScale.tickIncrement > 1) {			g_catSymbolAttachLevel = 0;		}		if (myScale.labelIncrement > 1) {			g_catSymbolAttachLevel = 1;		}		//	:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::	}	else if (myScale.tickLevel == myScale.pointLevel) {		g_catSymbolAttachLevel = 1;		if (myScale.tickIncrement > 1) {g_catSymbolAttachLevel = 0}	}	else {		g_catSymbolAttachLevel = 0;	}	// DEBUGGING ALERT (comm'd out 17.7.07)	// This verifies that footnote symbols are correctly attached/positioned	msg = "Footnote symbols attach to:\n"	switch (g_catSymbolAttachLevel) {		case 2:			msg += "scale labels...";			break;		case 1:			msg += "ticks above baseline...";			break;		default:			msg += "individual trace points...";	}	msg += "\n\n(development alert in HScales.drawHScaleDates, line 291 or thereabouts)";	msg += "\n\nThis message matters: check that footnote symbol attachment matches the way in which the horizontal scale is drawn...";	// alert(msg);	// DEBUGGING ENDS	// Loop by points	for (i = 0; i < catTotal; i++) {		// Footnote symbol, if any; omitting first ("fake") point:		if (i > 0) {thisSymbol = g_catFootnotes[i]};		// For each point, I need 2 dates -- this and the next		thisDate = new Date(localCatArray[i]);		if (i < (catTotal - 1)) {			nextDate = new Date(localCatArray[i + 1]);		}		else {			// final point: create "fake" val			nextDate = createFakeDate(thisDate, myScale, true);			finalPoint = true;		}		// So I've 2 point dates: this and next		// I compare them in order to decide whether I want to draw a tick and/or label for the current point		// What I am looking for is the "highest" level of difference on a scale of 1=hours to 4=years		// This flags whether tick and/or label is drawn		if (i == 0) {			// First tick --			// Mod (Oct 06) sets default level on first tick to point level			// This (hopefully) has the effect of forcing a tick on first point...			tickBound = testBound(thisDate, nextDate, myScale.tickLevel, myScale.tickIncrement,				myScale.pointLevel, myScale.pointLevel, true, onTicks);			if (onTicks) {				// Label is forced to top level if on ticks...				labelBound = c_topLevel;				firstLabel = false;		// (and first label flag reset)			}			else {				// ...no label if between (this is the "fake" slot)				labelBound = 0;			}		}		else if (finalPoint) {			// Last tick			// Next line prev'y used myScale.tickLevel as arg 3; revised to myScale.pointLevel to force a final tick when			// tick level is set "higher" than point level (e.g. monthly points on year scale...)			tickBound = testBound(thisDate, nextDate, myScale.pointLevel, myScale.tickIncrement, myScale.tickLevel, myScale.pointLevel, true, onTicks);			labelBound = c_topLevel		}		else {			tickBound = testBound(thisDate, nextDate, myScale.tickLevel, myScale.tickIncrement, 0, myScale.pointLevel, true, onTicks);			// First label TO APPEAR overrides any increment that might prevent it appearing			if (firstLabel) {				labelBound = testBound(thisDate, nextDate, myScale.labelLevel, 1, 0, myScale.pointLevel, false, onTicks);				if (labelBound > 0) {				//if (labelBound >= myScale.labelLevel) {					// When first label is set to appear, reset flag					firstLabel = false;				}			}			else {				// Labels after first-to-appear follow normal rules				labelBound = testBound(thisDate, nextDate, myScale.labelLevel, myScale.labelIncrement, 0, myScale.pointLevel, false, onTicks);			}		}/*    // DIDN'T HELP, SO COMM'D OUT    // Another REVAMP kludge. This is to deal with monthly and quarterly    // datapoints on 5/10 years. If labels are between ticks, I want two    // long ticks bounding the 5/10-year label...    if ((g_timeSeries[0] === "months") || (g_timeSeries[0] === "quarters")) {      if (g_isRevamp && !onTicks) {        if (g_timeSeries[1] === "5years") {          if (thisDate.getFullYear() % 5 === 0) {            tickBound = 4;          }          if (nextDate.getFullYear() % 5 === 0) {            tickBound = 4;          }        }        if (g_timeSeries[1] === "10years") {          if (thisDate.getFullYear() % 10 === 0) {            tickBound = 4;          }          if (nextDate.getFullYear() % 10 === 0) {            tickBound = 4;          }        }      }    }*/		// Have boundary, now appropriate ticks...    // REVAMP, Jan 17: another kludge to move from mapped    // hour/day/month/year ticks to 3 levels...    // Check granularity		// $.bp()    if (g_isRevamp) {      // NOTE: for REVAMP I tried forcing 10/5years...      // but this just messed labels up. So dropped.      if (tickSeries === 'years') {        if (tickBound === 4) {          tickBound = 3;        }      }      // Months seems OK...      else if (tickSeries === 'days') {        if (tickBound === 3) {          tickBound = 4;        } else if (tickBound = 2) {          tickBound = 3;        }      }      else if (tickSeries === 'hours') {        if (tickBound === 2) {          tickBound = 4;        } else if (tickBound = 1) {          tickBound = 3;        }      }    }    // Revamp kludge ends		if (tickBound > 0) {			if (tickFlag) {        //if ((thisDate.getFullYear() % 5 === 0)) {        //tickBound = 4;        //}				// Tick subject to conditions -- see above				thisTick = makeTick(slotPos, tickBound, tCount, onTicks, slotWidth);				tCount++;        // REVAMP KLUDGE, JAN 2017:        // Filter tick lengths for style (at bottom of this module)        if (g_isRevamp) {          revampFilterTick(thisTick, tickSeries, tickBound);        }			}			// ...and labels (on 2 lines)			// Labels are only possible IF there is a tick			if (labelBound > 0) {			//if (labelBound >= myScale.labelLevel) {				vertPos = g_hScaleMainSpaceAbove;					// label vert pos				labelLine = (c_topLevel + 1) - myScale.labelLevel;	// determines label line				for (j = myScale.labelLevel; j <= labelBound; j++) {					thisLabel = makeLabel(thisDate, slotPos, j, lCount, labelLine, lPosCount, slotWidth, onTicks, vertPos, true);					// If this is highest-level label, it's a potential anchor for a footnote symbol					if (j == myScale.labelLevel) {fSymbAnchor = thisLabel};					labelLine --;					vertPos += g_hScaleInternalSpaceAbove;			// adjust label vert pos for 2ndary label(s)				}				lCount++;			}			else {				// The reason there may be no label may be that the incrementation skips for this point				// at this level. But I may still have to reset label position counters (which are otherwise				// reset by makeLabel, called just above)					labelLine = (c_topLevel + 1) - myScale.tickLevel;					for (j = myScale.tickLevel; j <= tickBound; j++) {						if (labelLine == 1) {lPosCount[0] = 0};						else if (labelLine == 2) {lPosCount[1] = 0};						//else if (labelLine == 3) {lPosCount[2] = 0};						else {lPosCount[2] = 0};						labelLine -- ;					}			} 		} 		try {			// Footnote symbols 			// Depending on flag, either attached to label (thisLabel); drawn above tick (thisTick); or 			// drawn above baseline h-aligned to point 			if (!(thisSymbol == undefined)) {				switch (g_catSymbolAttachLevel) {					case 2:						// Attach to current label						fSymbAnchor.contents += thisSymbol						// Ideally I'd adjust label position...						break;					case 1:						// "Tick" - above baseline, aligned to point						fSymbAnchor = Array(g_baselineTick.top + 5, slotPos)						symbFrame = makeText(g_panelLayer, fSymbAnchor,							g_hScaleFontCMYK, g_hScaleFontName, g_hScaleSecondaryFontSize, g_hScaleSecondaryFontSize,							c_cConst, 0, 100, 0, false, thisSymbol, "Footnote symbol", "Footnote symbol", false)						break;					default:						// "Point" - above baseline, aligned to point						fSymbAnchor = Array(g_baselineTick.top + 5, slotPos)						symbFrame = makeText(g_panelLayer, fSymbAnchor,							g_hScaleFontCMYK, g_hScaleFontName, g_hScaleSecondaryFontSize, g_hScaleSecondaryFontSize,							c_cConst, 0, 100, 0, false, thisSymbol, "Footnote symbol", "Footnote symbol", false)				} 			} 		} 		catch (err) {};		lPosCount[0] ++;	// increment label position counters		lPosCount[1] ++;	// on every point		lPosCount[2] ++;	//		// Increment point position		slotPos += slotWidth;	}	// Ends loop-by-points	// Scale has been drawn. Now adjust so that any label strings	// don't encroach into left and right margins -- but pass onTicks	// so that between-tick columns don't allow for column-projection into margins...	// 	(note that complex dates don't use the marginAdjust function,	//	 since I can't predict in advance what will hit the page...)	// In Main:	if (!marginsPostAdjust(onTicks)) {		// Error is (hopefully) non-fatal		msg = "I made a mess of the left and right margins for the horizontal scale. " +			"The chart will probably draw okay, but you may have to adjust the scale " +			"and traces by hand. Please let " + c_authorName + " know the name of " +			"the chart you were processing when this error was reported..."		myAlert (msg, "Non-fatal horizontal scale error")	}	return true;}// DRAW H-SCALE DATES ends// DRAW H-SCALE NAMES// Called from Main.Ilex// Controls horizontal scale procedures for names and years/values (treated as strings)function drawHScaleNames(nIncr)// Arg flags:		0 = names//				1 = years/values by 1//				2 = years/values by 5//				3 = years/values by 10{//	var pointSeries;		// series by which points are drawn//	var tickSeries;		// by which ticks are drawn//	var labelSeries;		// by which labels are drawn	var catTotal;	var slotWidth;	var i;				// counters	var thisCat;			// category string (label)	var tickBound;		// levels at which ticks and labels are drawn...	var labelBound;	var slotPos;			// slot hPos	var tCount = 1;					// counter values appended to tick/label name/note	var lCount = 1;	var lPosCount = Array(0,0,0);		// counters for label_1/2/3 positioning (multiples of slotWidth)	var labelLine;					// controls which scale line label is drawn on	var finalPoint = false;			// flags final point (to force end tick/label)	var onTicks = true;				// labels "on" ticks	var vertPos;	var tickFlag = true;	var goLabel = true;				// for 1/5/10-increment years/values, flags *labels* on/off	// NEW FLAG ADDED 9.12.08: sets long/short ticks independently of labels on/off	var longTick;	var rightmostCat;		// Final category for width check											// (allows substit'n of "yy" for "yyyy"	// Series at three levels: points, ticks & labels	// Check margins; this adjusts inner box to allow for width of first	// and last strings	catTotal = g_catArray.length;	if (catTotal > 1) {		// Final string --		rightmostCat = g_catArray[catTotal - 1];		// If we're years, final label may want to be only 2 figures (ie "08", not "2008")		if (nIncr > 0) {			// Not names			if (g_timeSeries[0] == c_yearConst) {				// But only shorten if we're not changing century (ie I want "2000" not "00")				if ((rightmostCat.substr(0,2)) == (g_catArray[catTotal - 2].substr(0,2))) {					rightmostCat = rightmostCat.substr(2,2);				}			}		}		// (Note that actual final category string hasn't changed)		// REVAMP: if this is a year scale, filter labels for yyyy/yy conversion	  var isYears = ( (g_timeSeries[0]===c_yearConst) || (g_timeSeries[1]===c_yearConst));		if (isYears) {			g_catArray = filterHScaleLabelStrings(c_topLevel, g_catArray);		}		// Margin adjusts now		if (!marginAdjust(g_catArray[0], rightmostCat, catTotal, true)) {return false};		slotPos = g_innerBox.left;			// Start position		slotWidth = g_innerBox.width / (catTotal - 1);	}	else {		// Only one point: arbitrarily...		slotPos = g_innerBox.left + (g_innerBox.width / 2);		slotWidth = 10;	}	// Create ticks group...	g_hScaleTickGroup = g_panelLayer.groupItems.add();	g_hScaleTickGroup.name = c_hScaleTickGroupN;	// ... and labels group	g_hScaleStringGroup = g_panelLayer.groupItems.add();	g_hScaleStringGroup.name = c_hScaleStringGroupN;	// Ticks are not drawn if the following are all true:	//		style = column (any sort)	//		lowest value > 0 (i.e. scale broken or from zero)	//		points are ON ticks (this is true by definition for names, so not tested)	// Unless the REVAMP override is True...	//	// First, let's get a few flags to clarify the if/else structure	var isColChart = (g_overallStyle[0] == c_generalColConst) || (g_overallStyle[1] == c_generalColConst);	var isColBroken = ( (g_lowA == undefined) || (g_lowA > 0) && (g_lowB == undefined) || (g_lowB > 0) );	var isColZero = ( (g_lowA == undefined) || (g_lowA === 0) && (g_lowB == undefined) || (g_lowB === 0) );	if (isColChart) {		// So: column chart		if (isColBroken) {			// Broken scale, so no ticks:			tickFlag = false;		}		else if (isColZero) {			// 'Zeroed' scale, so use the revamp flag			tickFlag = g_forceColumnTicks;		}	}	// Flag has been set, therefore, before drawing ticks inside loop, below...	// Loop by points	for (i = 0; i < catTotal; i++) {		thisCat = trans_String(g_catArray[i]);		// For years/values, check whether there's a 5/10 increment that would turn this label off...		if (nIncr > 1) {			// First and last always appear:			if ((i == 0) || (i == (catTotal - 1))) {				goLabel = true;				// Tick length is checked independently of label on/off on first/last ticks				longTick = checkGoLabel(thisCat,nIncr)			}			// Otherwise do increment check:			else {				goLabel = checkGoLabel(thisCat,nIncr);				longTick = goLabel;			}		}		// Append footnote symbol (usually empty)		// Note that if there is just a single stacked column, g_catFootnotes will be *entirely* undefined;		// hence first condition:--		if (!(g_catFootnotes == undefined)) {			if (!(g_catFootnotes[i] == undefined)) {				thisCat += g_catFootnotes[i];			}		}		if (i == (catTotal - 1)) {finalPoint = true};		tickBound = c_topLevel;		if (!longTick) {tickBound-- }		labelBound = c_topLevel;    // REVAMP Jan 2017 KLUDGE...    // Different rules seem to apply for 5- and 10-year charts. So I    // reduce tick length again...!    if (g_isRevamp) {      if (nIncr > 1) {        tickBound --;      }    }		if (tickFlag) {			// Tick subject to conditions -- see above			makeTick(slotPos, tickBound, tCount, onTicks, slotWidth);			tCount++;		}		vertPos = g_hScaleMainSpaceAbove;					// label vert pos		labelLine = 1;	// determines label line		// Actual label (no reformatting)		if (goLabel) {			makeLabel(thisCat, slotPos, c_topLevel, lCount, labelLine, lPosCount, slotWidth, onTicks, vertPos, false);		}		lPosCount[0] ++;	// increment label position counters		lPosCount[1] ++;	// on every point		lPosCount[2] ++;	//		// Increment tick position		slotPos += slotWidth;	}// alert ('In HScales > drawHScaleNames, group has ' + g_hScaleTickGroup.groupItems.length + ' groupItems');	return true;}// DRAW H-SCALE NAMES ends// DRAW H-SCALE VALUES// Called from Main.Ilex// Controls horizontal scale procedures for values (bar and scatter charts)function drawHScaleValues(isBar, interval)// Arg: true=bar; false=scatter{	var hi;	var lo;	var incr;	var catTotal;	var onTicks = true;					// flags labels on ticks	var acrossScale;	// Bar-specific:	if (isBar) {		// Margin above scale		g_innerBox.top -= g_scaleSpaceAbove;		g_innerBox.height -= g_scaleSpaceAbove;		// Reserve left origin for LEFT-aligned labels see just below if right-aligned)		g_barLabelLeft = g_innerBox.left;		// Redraw inner box to exclude labels		if (!makeBarLabelSpace()) {return false};		// If bar labels align right, their origin is relative to the redefined inner box		if (!g_barLabelsAlignLeft) {			g_barLabelLeft = (g_innerBox.left);	// - g_barLabelMargin);		}		acrossScale = g_barHScaleAcross	}	else {		// Scatter		acrossScale = g_scatterHScaleAcross	}	// Originally, if labels were left/right of ticks (i.e. not centred), ticks	// ran to edge of current inner box. So I remembered it...	g_preScaleLabelPos = Array(g_innerBox.top, g_innerBox.top - g_innerBox.height);	// I still remember it, but it isn't actually used by drawHVTicks...	// Broken scale?	// (I don't actually draw broken scale until later)	g_isBS  = isBrokenScale();	if (isBar) {		if ((g_isBS[0]) || (g_isBS[1])) {			g_innerBox.left += g_brokenScaleMargin;			g_innerBox.width -= g_brokenScaleMargin;		}	}	else {		// Scatter -- hScale is anomalous "right"...		// Mod 17.7.07 -- for scatters, only tweak left margin by		// inner tick margin: aligns to Eco baseline (FT has no baseline)		if (g_isBS[1]) {			g_innerBox.left += g_inTickMargin;			g_innerBox.width -= g_inTickMargin;		}	}	// Check margins; this adjusts inner box to allow for width of first	// and last strings	if (!(g_incrementA == undefined)) {		lo = g_lowA;		hi = g_highA;		incr = g_incrementA;	}	else {		lo = g_lowB;		hi = g_highB;		incr = g_incrementB;	}	// Margins adjust left and right now:	if (!marginAdjust(lo, hi, catTotal, (!isBar))) {return false};	// Populate scale (values and h-coords)	if (!populateHScale(lo, hi, incr, acrossScale)) {return false};	catTotal = g_hArray.length - 1;	// Scale at top or bottom?	var tOrB = false;		// by default	if ((g_overallStyle[0] == c_generalBarConst) || (g_overallStyle[1] == c_generalBarConst)) {		tOrB = g_barScaleTop;	}	else if ((g_overallStyle[0] == c_generalScatterConst) || (g_overallStyle[1] == c_generalScatterConst)) {		tOrB = g_scaleTop;	}	// Draw scale (labels and ticks)...	if (!drawHValScale(g_hArray, tOrB, isBar)) {return false};	// Adjust for non-scale side margin at top or bottom	g_innerBox.height -= g_inTickOtherMargin;	if (!tOrB) {g_innerBox.top -= g_inTickOtherMargin};	return true;}// DRAW H-SCALE VALUES endsfunction getMinOfArray(numArray) {  return Math.min.apply(null, numArray);}function getMaxOfArray(numArray) {  return Math.max.apply(null, numArray);}// DRAW H-SCALE THERMO// Called from Main.Ilex// Draws horizontal array of bars for "column" thermometer chartsfunction drawHScaleThermo(){	var catTotal;	var slotWidth;	var i;			// counter	var thisCat;		// current and next dates in series	var slotPos;		// slot hPos	var tCount = 1;	// counter values appended to tick/label name/note	var lCount = 1;	var lPosCount = Array(0,0,0);		// counters for label_1/2/3 positioning (multiples of slotWidth)	var labelLine = 4;							// controls which scale line label is drawn on	var onTicks = true;							// flags labels on ticks	var vertPos;	// var graphicStyle;						// graphic style for thermo bars	var tPoints;	var graphicStyle, graphicStyleBack, graphicStyleFront;	// Check margins; this adjusts inner box to allow for width of first	// and last strings	catTotal = g_catArray.length;	// REVAMP	// Filter cat strings to displayable format (eg 'yyyy' to 'yy')	// BEFORE we do length-testing...	g_catArray = filterHScaleLabelStrings(c_topLevel, g_catArray);	// Now adjust margins:	if (!marginAdjust(g_catArray[0], g_catArray[catTotal - 1], catTotal, true)) {return false};	slotPos = g_innerBox.left;			// Start position	slotWidth = g_innerBox.width / (catTotal - 1);	// Create thermo group...	g_hScaleTickGroup = g_panelLayer.groupItems.add();	g_hScaleTickGroup.name = c_hScaleTickGroupN;	// ... and labels group	g_hScaleStringGroup = g_panelLayer.groupItems.add();	g_hScaleStringGroup.name = c_hScaleStringGroupN;	// Graphic styles: back and front for revamp; one style for 'old'  if (g_isRevamp) {  	try {  		graphicStyleBack = g_myDoc.graphicStyles[c_thermoBack];  	}  	catch (err) {graphicStyleBack = undefined};  	try {  		graphicStyleFront = g_myDoc.graphicStyles[c_thermoFront];  	}  	catch (err) {graphicStyleFront = undefined};  }  else {    graphicStyle = g_myDoc.graphicStyles[c_thermoN];  }	// Loop by points	for (i = 0; i < catTotal; i++) {		thisCat = g_catArray[i];		tPoints = Array(Array(slotPos,g_innerBox.top),Array(slotPos,g_innerBox.top - g_innerBox.height))		// Draw lines. Fourth param is the group to append to...    // Again, fork on REVAMP    if (g_isRevamp) {      // ...5th is a new flag, false for back, true for front...	    makeThermoTick(tPoints, tCount, graphicStyleBack, g_hScaleTickGroup, false);      makeThermoTick(tPoints, tCount, graphicStyleFront, g_hScaleTickGroup, true);    }    else {      makeThermoTick(tPoints, tCount, graphicStyle, g_hScaleTickGroup, true);    }		tCount++;		vertPos = g_hScaleMainSpaceAbove;					// label vert pos		labelLine = 1;	// determines label line		makeLabel(thisCat, slotPos, c_topLevel, lCount, labelLine, lPosCount, slotWidth, onTicks, vertPos, false);		// Increment tick position		slotPos += slotWidth;	}	// Scale has been drawn. Now adjust so that any label strings	// don't encroach into left and right margins	return true;}// DRAW H-SCALE THERMO ends// REVAMP, March 2016//// FILTER H-SCALE LABEL STRING// New function to handle string filtering (eg 'yyyy' to 'yy' before margins are adjusted)function filterHScaleLabelStrings(level, catArray) {	var i, cat, labS, filteredArray=[];	for (i = 0; i < catArray.length; i++) {		cat = catArray[i];		// Actual string to show:		switch (level) {			case 1:		// hours				labS = cat.getHours();				break;			case 2:		// days/weeks				labS = cat.getDate();				break;			case 3:		// months/quarters				labS = mOrQString(cat);				break;			case 4:		// names / years (or values)				if ((g_timeSeries[0] == c_nameConst)) {					// Names: don't fiddle					labS = cat				}				else {					// Years or values						labS = yString(cat);						// After first year label, turn off global "yyyy" flag						if (g_yFlag) {g_yFlag = false};				}				break;		}		filteredArray.push(labS);	}	return filteredArray;}// FILTER H-SCALE LABEL STRING ends// *********************************************************************************************// MAKE LABEL// Called from drawHScale<whatever> to draw actual labelfunction makeLabel(labS, hPos, lLevel, labelNo, lineNo, labCountArray, sWidth, drawOnTick, vPos, needsFormatting)// Args are:		category string (already filtered, ready to be drawn)//				horizontal position//				label level (h/d/m/y)//				label number (for name/note)//				line number (1 or 2)//				array of 3 slot counters//				slot width//				on/between flag//				vertical margin relative to baseline//				if needsFormatting is true, run the pre-REVAMP code to format string to 'date' level//					(required for call from drawHScaleDates){	var labS;	var labOrigin;	var yPos;	var labObj;	var labSize;	// REVAMP stuff. This isn't pretty, but life is short.	// This 'switch' was originally unconditional: passed a single category string, I	// triaged by 'level' to get the appropriate y/m/d/h or 'name' string.	// Because I needed to calculate right margin on the final *displayed* string, I	// set up another version of this for col-thermos: filterHScaleLabelStrings gets passed	// the entire array of category strings and formats them before margins are calculated...	// The trouble is: that approach won't work with dates, where we change 'level' from	// one item to the next. So, sadly, I've just stuffed this 'switch' back in here,	// dependent upon a condition that is true only if the call is from drawHScaleDates...	if (needsFormatting) {		switch (lLevel) {			case 1:		// hours				labS = labS.getHours();				break;			case 2:		// days/weeks				labS = labS.getDate();				break;			case 3:		// months/quarters				labS = mOrQString(labS);				break;			case 4:		// names / years (or values)				if ((g_timeSeries[0] == c_nameConst)) {					// Names: don't fiddle					labS = labS				}				else {					// Years or values						labS = yString(labS);						// After first year label, turn off global "yyyy" flag						if (g_yFlag) {g_yFlag = false};				}				break;		}	}	// Horizontal positions:	// hPos is point position, from which I want to subtract (no. of slots * slotWidth) / 2 / INCREMENT (new)	// for each label line	// Place:	// Which line of scale?	// lineNo is 2+ for subsidiary scale line; 1 for main line (years)	if (g_scaleTop) {		yPos = g_hScaleBase + vPos;	}	else {		yPos = g_hScaleBase - vPos;	}	if (lineNo == 1) {		if (!drawOnTick) {hPos -= (((labCountArray[0]-1) * sWidth) / 2)};		labCountArray[0] = 0;			// reset label position counter for this line										// (to zero because calling loop increments it)		labSize = g_hScaleMainFontSize;	}	else if (lineNo == 2) {		if (!drawOnTick) {hPos -= (((labCountArray[1]-1) * sWidth) / 2)};		labCountArray[1] = 0;			// reset label position counter for this line										// (to zero because calling loop increments it)		labSize = g_hScaleSecondaryFontSize;	}	else if (lineNo == 3) {		if (!drawOnTick) {hPos -= (((labCountArray[2]-1) * sWidth) / 2)};		labCountArray[2] = 0;				// reset label position counter for this line										// (to zero because calling loop increments it)		labSize = g_hScaleSecondaryFontSize;	}	else {		// At level 4 -- hourly -- I'm assuming that there is always		// a label in each slot...		// ...so I draw in slot position		// if (!drawOnTick) {hPos -= (sWidth / 2)};		// if (lineNo == 3) {labCountArray[2] = 0};		labSize = g_hScaleSecondaryFontSize;	}	labOrigin = Array(yPos,hPos);	labObj = makeText(g_hScaleStringGroup,labOrigin,g_hScaleFontCMYK,		g_hScaleFontName,labSize,labSize,g_hScaleAlign,		0,g_hScaleHScale,		0,true,labS,c_hScaleStringN,c_hScaleStringN,    true);  // Opentype/tabular	return labObj;}// MAKE LABEL ends// M-OR-Q STRING// Called from makeLabel// Converts date to "January", "Jan", "J" or "Q1"function mOrQString(mq)// Arg is date object{	var mNo = mq.getMonth();		// number, 0-11	if (g_timeSeries[1] == c_quarterConst) {		// quarters		if (mNo < 3) {return "Q1"};		else if (mNo < 6) {return "Q2"};		else if (mNo < 9) {return "Q3"};		else {return "Q4"};	}	else {		// months		return monthName(mNo,g_line2ScaleFormat);	// in Utilities		// Prev'y hard-wired:		//return monthName(mNo,2);	// in Utilities	}}// M-OR-Q STRING ends// Y STRING// Called from makeLabel// Determines whether years display as "yyyy" or "yy" in scale labelsfunction yString(y)// Arg is date object or number-string{	var cStr = y.constructor.toString();		// passed object's constructor, as string	var yStr;								// year string extracted from any passed date object	// Superseded:	// Check arg length, which is undefined if it's a date object (or a number)	// This is flaky! Surely there's a proper object type check...	//if (y.length == undefined) {	//	// Instead:	// Aha! It looks like we can check the object's constructor...	if (cStr.search("Date") > -1) {		// Date		yStr = y.getFullYear();		if (g_yFlag) {return yStr};				// first label:	"yyyy"		if ((yStr % 100) == 0) {return yStr};		// new century:	"yyyy"		return (yStr.toString()).slice(-2);		// otherwise;		"yy"	}	else {		// String		// This may be value or a year...		if (g_yFlag) {return y};					// first label:	return unaltered		// Assume 4 chars = "yyyy"		if (y.length == 4) {			if ((y % 100) == 0) {return y};		// new century:	"yyyy"			return y.slice(-2);					// otherwise;		"yy"		}		// Anything else (short years or values) returned unaltered		else {return y};	}}// Y STRING ends// INDIVIDUAL TICK-DRAWING FUNCTIONS://	makeTick//	makeThermoTick// MAKE TICK// Called from drawHScale to draw actual tick (which it returns)function makeTick(hPos, tLevel, tNo, onPos, sWidth)// Args are:		horizontal position//				tick level//				tick number//				ticks on/between//				slot width{	var aTick;	var mtName = c_hScaleTickN + tNo;	// for name/note	var tPoints;						// coords array	var tStart;						// start and end of tick	var tEnd;	// Tick start and end positions (y-coord)	// Eval is evil, so:	// eval("tStart = g_hScaleBase + g_tickStart" + tLevel);	tStart = g_hScaleBase + this["g_tickStart" + tLevel];	// Tweak start to align with bottom of baseline stroke...	// Comm'd out for REVAMP: stick with baseline core	if (!g_isRevamp) {		tStart -= (g_vScaleBaseStrokeWidth / 2);	}	// *** Shouldn't happen, since 'flip' has been comm'd out in Main > Ilex...	// Scale may "flip"	if (g_hScaleFlip) {		eval("tEnd = g_hScaleBase - g_tickEnd" + tLevel);	}	else {		eval("tEnd = g_hScaleBase + g_tickEnd" + tLevel);	}	// Tick x-coord -- in or between slots?	if (!onPos) {hPos += sWidth / 2};	tPoints = Array(Array(hPos,tStart),Array(hPos,tEnd));	aTick = makeLine(g_hScaleTickGroup, tPoints, false, undefined, true, g_hScaleTickStrokeWidth,		g_hScaleTickCMYK, c_defaultLineEnd, c_defaultLineMiter, c_defaultLineMiterLimit, mtName, mtName);	return aTick;}// MAKE TICK ends// MAKE THERMO TICK// Called from drawHScaleThermo to draw actual thermometer "ticks"// Also draws them for bars, so should move to another module...function makeThermoTick(endsArray, tNo, gStyle, context, isFront)// Args are:		double-array of tick line end coords//				tick number//				graphic style (string or undefined)//				context is the group to append to...//				flag if this is a 'front' tick{	var aTick;	var tPoints;	if (isFront) {		var mtName = c_thermoFront + tNo;	// for name/note	}	else	{		var mtName = c_thermoBack + tNo;	// for name/note	}	// Note, BTW, that these are counter from 1...	aTick = makeLine(context, endsArray, false, undefined, true, g_hScaleTickStrokeWidth,		g_hScaleTickCMYK, c_defaultLineEnd, c_defaultLineMiter, c_defaultLineMiterLimit, mtName, mtName);	// *** Look for THERMOMETER graphic style ***	// Comment out to disable...	if (!(gStyle == undefined)) {		gStyle.applyTo(aTick);	}	// *** Ends}// MAKE THERMO TICK ends// TEST BOUND// Called from drawHSCale// Returns the boundary level (1=hour - 4=year) for ticks and labels by// calculating the highest level at which two dates differfunction testBound(aDate, bDate, testLevel, testIncr, defLev, pLevel, isTick, labOnTick)// Args are:		this date;//				next date//				the level at which to compare them;//				the increment at that level;// 				default value (which may be changed) to return//				points level//				tick/label flag//				on/between flag{	// Loop from top (year) level to inherited tick level, breaking at	// highest level at which the dates differ	var thisVal;	var nextVal;	var tempIncr;	testLoop:	for (i = c_topLevel; i >= testLevel ; i--) {		if (i > testLevel) {			tempIncr = 1		}		else {			tempIncr = testIncr		}		switch (i) {			// LEVEL 4: YEARS			case 4:				// If the year changes...				if (bDate.getFullYear() > aDate.getFullYear()) {					if (labOnTick) {				// points on ticks						if (isTick) {			// drawing tick -- long or short							if ((aDate.getFullYear() % tempIncr) == 0) {defLev = 4};							else {defLev = 3};						}						else {					// drawing label - format as year or omit							if ((aDate.getFullYear() % tempIncr) == 0) {defLev = 4};							else {defLev = 0};						}					}					else {						// points between ticks						if (isTick) {			// all ticks are long							defLev = 4;						}						else {					// labels are year format or omitted							if ((aDate.getFullYear() % tempIncr) == 0) {defLev = 4};							else {defLev = 0};						}					}					break testLoop;				}				break;			case 3:				// LEVEL 3: MONTHS				if (tempIncr == 3) {					// quarters					thisVal = getMyQ(aDate)					nextVal = getMyQ(bDate)					if (nextVal > thisVal) {						defLev = 3;						break testLoop;					}				}				else {					// months					if (bDate.getMonth() > aDate.getMonth()) {						defLev = 3;						break testLoop;					}				}				break;			case 2:				// LEVEL 2: DAYS				if (bDate.getDate() > aDate.getDate()) {					defLev = 2;					break testLoop;				}				break;			case 1:				// LEVEL 1: HOURS				if (bDate.getHours() > aDate.getHours()) {					defLev = 1;					break testLoop;				}				break;		}	// End SWITCH	} // End FOR	return defLev;}// TEST BOUND ends// GET MY Q// Called from testBound// Returns quarter (1-4) into which a date object's month (0-11) fallsfunction getMyQ(m){	m = m.getMonth()	if (m<3) {return 1};	else if (m<6) {return 2};	else if (m<9) {return 3};	else {return 4};}// GET MY Q ends// CREATE FAKE DATE// Called from drawHScale// Creates fictitious next date at beginning or end of series by de/incrementing at the points levelfunction createFakeDate(fDate, scObj, isNext)// Args are:	final genuine date in series;//				scale attributes object;//				true to get next date; false to get previous{	// Pass to local var via primitive, to prevent new date being passed back	// to original date by reference	var myDate = new Date(fDate.getTime());	var d;	switch (scObj.pointLevel) {		case 1:		// hours			d = myDate.getHours();			if (isNext) {d += scObj.pointIncrement};			else {d -= scObj.pointIncrement};			myDate.setHours(d);			break;		case 2:		// days			d = myDate.getDate();			if (isNext) {d += scObj.pointIncrement};			else {d -= scObj.pointIncrement};			myDate.setDate(d);			break;		case 3:		// months			d = myDate.getMonth();			if (isNext) {d += scObj.pointIncrement};			else {d -= scObj.pointIncrement};			// Previous year has to be strong-armed:			if (d < 0) {				d +=12;				m = myDate.getFullYear() - 1;				myDate.setFullYear(m);			}			myDate.setMonth(d);			break;		case 4:		// years			d = myDate.getFullYear();			if (isNext) {d += scObj.pointIncrement};			else {d -= scObj.pointIncrement};			myDate.setFullYear(d);			break;	}	return myDate;}// CREATE FAKE DATE ends// MARGIN ADJUST// Called from drawHScaleNames, drawHScaleValues (ie Bar or Scatter h-Scale), drawHScaleThermo// Adjust LEFT/RIGHT margins for width of first/last strings on name and year series//		DO I REALLY NEED TO USE THE g_inTickMargin MINIMUM --//		ON BROKEN HORIZONTAL SCALES ON SCATTERS, ANYWAY...?function marginAdjust(lStr, rStr, slotTotal, addDefaultMargin)// Args are:	first string//			last string (note that for years this seems to come through, correctly, as "yy")//			number of slots// 			true if default margin to be allowed for (currently, Jan 09, false for bar scales only...){	var lTweak;	// Amounts to adjust left and right	var rTweak;	// Default margins from Prefs (left and/or right) are based on two variables:	// inTickMargin & inTickOtherMargin (scale & non-scale side)	// Which do I want on either side...?	// Check increments to verify if sides exist:	if (!(g_incrementA == undefined)) {		// Left scale exists		lTweak = g_inTickMargin;    // But, for REVAMP scatter charts: another KLUDGE forces to zero default margin:    if (g_isRevamp) {      if ((g_overallStyle[0] == c_generalScatterConst) || (g_overallStyle[1] == c_generalScatterConst)) {        lTweak = 0;        }    }	}	else {		// No left scale		lTweak = g_inTickOtherMargin;	}	if (!(g_incrementB == undefined)) {		// Right scale exists		rTweak = g_inTickMargin;	}	else {		// No right scale		rTweak = g_inTickOtherMargin;	}	// Only one point, don't hang around:	if (slotTotal == 1) {		g_innerBox.left += lTweak;		g_innerBox.width -= lTweak;		g_innerBox.width -= rTweak;		return true;	}	// Default margins determined for each side	// Now examine label widths...	var halfLLabWidth;			// l/r margins based on half label width	var halfRLabWidth;	var halfClusterWidth = 0;		// half cluster width (cols only); default is zero	var lWidth;	var rWidth;	var ibLessGaps;				// used to calculate cluster widths	// Get half-width of first and last labels	// Call function to plonk down first and last strings;	// create and measure outlines; delete strings afterwards	halfLLabWidth = new getTFrameSize(lStr,g_hScaleFontName, g_hScaleMainFontSize,		g_hScaleHScale, true, true).width / 2;	halfRLabWidth = new getTFrameSize(rStr,g_hScaleFontName, g_hScaleMainFontSize,		g_hScaleHScale, true, true).width / 2;	// Default margins	// *********************************************************************************************	// This has an INFERENTIAL feel about it: it only seems to apply to single scale, drawn right...	// What happens if scale is left or double??	// *********************************************************************************************	// addDefaultMargin is false for bars, provisionally	if (addDefaultMargin) {		g_innerBox.width -= g_inTickMargin;	}	// Columns only: inner box width, and allow for clusters being wider than labels	if ((g_overallStyle[0] == c_generalColConst) || (g_overallStyle[1] == c_generalColConst)) {		// Thermo?		if ( (g_chartStyle[0] !== c_colThermoConst) && (g_chartStyle[1] !== c_colThermoConst) ) {			// Cluster width may exceed label width, so get half-width of one cluster			// Half cluster width = (width of IB) - (combined widths of all gaps) divided by 2			ibLessGaps = g_innerBox.width - ((slotTotal - 1)* g_cbGap);			halfClusterWidth = ibLessGaps / (slotTotal * 2);		}		else {			if (g_thermoCross) {				// If it's a crossbar thermo, check against crossbar projection:				halfClusterWidth = g_thermoCrossLength / 2;			}			else {				// Standard thermo				halfClusterWidth = g_tScatterSize / 2;			}		}	}	// Compare first and last label/cluster;	// in each case, reserve greater half-width...	// (if not cols, half-cluster-width is default zero)	lWidth = Math.max(halfLLabWidth, halfClusterWidth);	rWidth = Math.max(halfRLabWidth, halfClusterWidth);	// Subtract from IB left and right (if greater than existing margin)	if (lWidth > lTweak) {			// Left		g_innerBox.left += lWidth;		g_innerBox.width -= lWidth;	}	else {		g_innerBox.left += lTweak;		g_innerBox.width -= lTweak;	}	// Mod Jan 09. Previously I tested on greater of default and calculated right margin, however, I already	// seem to allow for default margin above (line 1217ff). So comm'd out; just adjust for calculated	// half label width...	//if (rWidth > rTweak) {			// Right	//	g_innerBox.width -= rWidth;	//}	//else {	//	g_innerBox.width -= rTweak;	//}	//	// Just subtract half label width...	g_innerBox.width -= rWidth;	// ...and:	return true;}// MARGIN ADJUST ends// WHAT'S THIS?function maFormat(maVal){	alert("Unknown function\nPlease advise Donald Hounam that vestigial function HScales.maFormat (HScales line 1275) was called...");	return getFullYear(maVal);}// SCALE ATTRIBUTES// Object constructor, called from controlHScales// Creates scaleAttributes object whose properties define level and increment// for points, ticks and labelsfunction scaleAttributes(points, ticks, labels)// Args are strings stating inherited time series for points, ticks and labels{	var sArray = new Array(0);	sArray = setLevel(points)	this.pointLevel = sArray[0]	this.pointIncrement= sArray[1]	sArray = setLevel(ticks)	this.tickLevel = sArray[0]	this.tickIncrement= sArray[1]	sArray = setLevel(labels)	this.labelLevel = sArray[0]	this.labelIncrement= sArray[1]}// SCALE ATTRIBUTES ends// SET LEVEL// Called from scaleAttributes// Arg is a time-series constant (names, years, quarters...)// In each case this function sets://		the level (1=hours, 2=days, 3=months, 4=years) that defines the series//		an increment (used for comparing subsequent dates)//	thus quarters are level 3 (months) incrementing by 3function setLevel(it){	switch (it) {		case c_nameConst:			level = 4;			incr = 1;			break;		case "10" + c_yearConst:			level = 4;			incr = 10;			break;		case "5" + c_yearConst:			level = 4;			incr = 5;			break;		case c_yearConst:			level = 4;			incr = 1;			break;		case c_quarterConst:			level = 3;			incr = 3;			break;		case c_monthConst:			level = 3;			incr = 1;			break;		case c_weekConst:			level = 2;			incr = 7;			break;		case c_dayConst:			level = 2;			incr = 1;			break;		case c_hourConst:			level = 1;			incr = 1;			break;	}	return Array(level, incr);}// SET LEVEL ends// POPULATE H-SCALE// Called from drawHScaleValues// Define array for bar scales. This will be 2-dimensional://		dim 1: each element = one scale tick//		dim 2: three elements -- value; horizontal co-ord; tick style (default/index/zero/baseline)// Call drawScale to draw actual scale(s)function populateHScale(l, h, i, runsAcross)// Args are:	low, high and increment{	//listArgs(arguments)	// makeArray populates an array with label values and anchor positions	// (in GenScales)	g_hArray = makeScaleArrayNormal(l, h, i, false, runsAcross, true);	// If array was created, draw scale	if (g_hArray == undefined) {return false};	else {return true};}// POPULATE H-SCALE ends// DRAW HVAL-SCALE// Called from drawHScaleValues// Draws horizontal values scale for bars and scattersfunction drawHValScale(hvArray, isTop, isBar)// Args are:		array of values & x-coords//				true if scale drawn at top//				true=bar; false=scatter{	var labHeight;					// for height of scale label	var myS;	var sOrigin = new Array(1)		// anchor	var n;							// counter	var str;							// name/note string	var align;						// align string (centre hard-wired at present)	var pmOrigin;						// zero label origin for global +/–	var midZero = false;				// Flags zero mid- or top-of-scale (for global +/–)	var pmSize;						// Size of global +/–	// Draw scale strings, anchored horizontally on my array of co-ords	// and vertically on the inner box top/bottom	// Scale string group	g_hScaleStringGroup = g_panelLayer.groupItems.add();	g_hScaleStringGroup.name = c_hScaleStringGroupN;	// Scale tick group	g_hScaleTickGroup = g_panelLayer.groupItems.add();	g_hScaleTickGroup.name = c_hScaleTickGroupN;	// Label height	labHeight = new getTFrameSize("0", g_hScaleFontName, g_hScaleMainFontSize, g_hScaleHScale, true, false);	// Origin and alignment	// Also, adjust inner box to tick ends...	if (isBar) {		// Bars		if (isTop) {			// If bar chart draws scale at top of chart...			// I originally drew the gap below the subtitle to the top (x-height)			// of the scale labels. But the REVAMP wants the 15pt gap to measure			// from subtitle baseline to scale-label baseline.			// So this comm'd out...			// sOrigin[0] = g_innerBox.top - labHeight.height;			// g_innerBox.top -= (labHeight.height + g_outTickMargin);			// g_innerBox.height -= (labHeight.height + g_outTickMargin);			// ...and replaced with (i.e. no allowance for labHeight)			sOrigin[0] = g_innerBox.top;			g_innerBox.top -= g_outTickMargin;			g_innerBox.height -= g_outTickMargin;		}		else {			sOrigin[0] = g_innerBox.top - g_innerBox.height;			g_innerBox.height -= (labHeight.height + g_outTickMargin);		}	}	else {		// Scatters		if (isTop) {			sOrigin[0] = g_innerBox.top - labHeight.height;			g_innerBox.top -= (labHeight.height + g_outTickMargin);			g_innerBox.height -= (labHeight.height + g_outTickMargin);		}		else {			sOrigin[0] = g_hScaleBase - g_hScaleMainSpaceAbove;			//sOrigin[0] = g_innerBox.top - (g_innerBox.height + g_hScaleMainSpaceAbove);			//g_innerBox.height -= (labHeight.height + g_outTickMargin);		}	}	if (g_hScaleLabelAlign < 0) {		// Label is to left of tick		align = c_rConst;	}	else if (g_hScaleLabelAlign == 0) {		// Label is centred on tick		align = c_cConst;	}	else {		// Label is to right of tick		align = c_rConst;	}	// Name and note	str = c_hScaleStringN;	n = 1;	for (i = 0; i < hvArray.length; i ++) {		sOrigin[1] = (hvArray[i][1] + g_hScaleLabelAlign);		// Remember zero for global +/-		if (hvArray[i][0] == 0) {			// If I'm doing global +/-...			if (g_globalPlusMinus) {				// If the zero NOT first val...				if (i > 0) {					// Remember location of zero textrange					pmOrigin = sOrigin[1];					// If zero is midrange...					if (i < (hvArray.length - 1)) {						midZero = true						// (If zero is scale high, keeps default false)					}				}			}		}		// Draw label		// BY THE WAY, AM I REMOVING CHECKING STRINGS FOR GLOBAL MINUS?		myS = makeText(g_hScaleStringGroup,sOrigin,g_hScaleFontCMYK,			g_hScaleFontName,g_hScaleMainFontSize,g_hScaleMainFontSize,align,0,100,			0,false,hvArray[i][0],str + n,str + n, true);		n ++;	}	// Global plus/minus?	if (pmOrigin != undefined) {		// Fontsize for +/–		// Trap possibility that pref var added Feb 09 hasn't made it into		// lookup file; but basically, subtract amount from scale font size...		if (g_plusMinusSmallerBy == undefined) {			pmSize = g_hScaleMainFontSize		}		else {			pmSize = g_hScaleMainFontSize - g_plusMinusSmallerBy		}		// Get a horizontal distance from 2 elements in the array:		tweak = (hvArray[1][1] - hvArray[0][1]) / 2;		// Use coords from last label drawn		// V-pos stet; overwrite H-pos with +/- position between labels		if (midZero) {			// Zero in midrange: draw "+"			sOrigin[1] = pmOrigin + tweak;			myS = makeText(g_hScaleStringGroup,sOrigin,g_hScaleFontCMYK,				g_hScaleFontName,pmSize,pmSize,align,0,100,				0,false,"+","","",false);		}		sOrigin[1] = pmOrigin - tweak;		myS = makeText(g_hScaleStringGroup,sOrigin,g_hScaleFontCMYK,			g_hScaleFontName,pmSize,pmSize,align,0,100,			0,false,"–","","",false);	}	// Now, ticks	// These use same h-coords, with inner box top/bottom	if (!drawHVTicks(g_hScaleTickGroup, isTop, isBar)) {return false};	// Bars only: tweak inner box again, to arena for actual traces	if (isBar) {		if (isTop) {			g_innerBox.top -= g_inTickMargin;			g_innerBox.height -= g_inTickMargin;		}		else {			g_innerBox.height -= g_inTickMargin;		}	}	// Still here?	return true;}// DRAW HVAL-SCALE ends// MAKE BAR LABEL SPACE// Called from drawHScaleValues// Gets width of longest bar label outline (max width is half inner box)// Adjusts inner box, but reserves original left for label originsfunction makeBarLabelSpace(){	var i;						// counter	var maxLen = 0;				// string length	var labSize					// holder for label width/depth	// Extract each cat string from array and get widest outline	for (i = 0; i < g_catArray.length; i ++) {		labSize = new getTFrameSize(g_catArray[i], g_hScaleFontName, g_hScaleMainFontSize, g_hScaleHScale, true, false);		if (labSize.width > maxLen) {			maxLen = labSize.width + g_barLabelMargin;		}	}	// So maxLen is width of longest string; but don't allow it to be more than half inner box width	if (maxLen > (g_innerBox.width / 2)) {		maxLen = (g_innerBox.width / 2);	}	g_innerBox.left += maxLen;	g_innerBox.width -= maxLen;	// Later when I drop labels in (Bars.drawBars) I'll want the height of the label	// and an adjustment for the difference between a textRange anchorpoint and the bottom of the outline	// Use u/c character to get full height without descenders	labSize = new getTFrameSize("M", g_hScaleFontName, g_hScaleMainFontSize, g_hScaleHScale, true, false);	g_barLabelHeight = labSize.height;	g_barLabelTweak = labSize.tweak	return true;}// MAKE BAR LABEL SPACE ends// DRAW HV-TICKS// Called from vScaleTicks to draw bar/scatter horizontal scale ticksfunction drawHVTicks(tGrp, drawTop, isB)// Args are group context; top/bottom scale flag; true=Bar{	var hvtAcross;	var aTick;	var tPoints;	var start;	var end;	var i;	var myT;	var myB;	var loopDrawsBase = false;	// flags loop on which baseline is drawn	var dotArray;	// This is a REVAMP kludge for bar charts with scale at top, to get	// tick ends a set margin below strings. Defaults to zero...	var revampBarAtTopTweak = 0;	// g_hArray contains label positions, which include h-coord	// depending on whether labels are centred or left/right of ticks,	//		v-coord is based on remembered or current inner box	// Tick position and length	// Draw across?	/* Horizontal value scale, bars and scatters only. At Eco, bars are across; scatters are short.	*/	if ((g_overallStyle[0] == c_generalBarConst) || (g_overallStyle[1] == c_generalBarConst)) {		// Bar chart		hvtAcross = g_barHScaleAcross;		// REVAMP kludge: if it's an across bar scale, at top of chart, drop tick ends clear of strings...		if (g_isRevamp) {			if (hvtAcross && drawTop) {				revampBarAtTopTweak = g_revampBarAtTopTweak;			}		}	}	else if ((g_overallStyle[0] == c_generalScatterConst) || (g_overallStyle[1] == c_generalScatterConst)) {		// Scatter		hvtAcross = g_scatterHScaleAcross;	}	/* Top and bottom positions, depending on whether labels are beside ticks or centered	if (g_hScaleLabelAlign == 0) {		// centred: use current inner box, which has been adjusted for label depth		myT = g_innerBox.top;		myB = g_innerBox.top - g_innerBox.height;	}	else {		// labels are beside ticks; use remembered top and bottom		myT = g_preScaleLabelPos[0];		myB = g_preScaleLabelPos[1];	}	*/	// Originally, if labels were beside ticks, I adjusted the top/bottom positions of the ticks	// to align with the labels. But FT (which is what I was working around) want ticks clear of	// labels; so in all cases...	myT = g_innerBox.top;	// Mod July 07 uses reserved baseline!	myB = g_hScaleBase;	// However this won't exist for bars, so:	if (myB == undefined) {myB = g_innerBox.top - g_innerBox.height};	// Set tick start/ends	if (hvtAcross) {		start = myT;		end = myB;	}	else {		if (drawTop) {			start = myT;			end = myT - g_tickEnd3;		}		else {			start = myB;			end = myB + g_tickEnd3;		}	}	// REVAMP tweak	start -= revampBarAtTopTweak;	for (i = 0; i < g_hArray.length; i++) {		str = c_hScaleTickN + (i + 1);		tPoints = new Array(Array(g_hArray[i][1],start),Array(g_hArray[i][1],end));		// Width & colour    // REVAMP KLUDGE for scatters, which don't highlight base zero    if (!isB && g_scatterHScaleAcross) {      g_hArray[i][2] = 0;    }		switch (g_hArray[i][2]) {			case 2:		// index or (zero for +/- scale)				sW = g_vScaleIndexStrokeWidth;				sCol = g_vScaleIndexCMYK;				// Zero trips baseline duplication flag				if (isB && (g_hArray[i][0] == 0)) {loopDrawsBase = true};				dotArray = undefined;				break;			case 1:		// zero baseline				sW = g_vScaleBaseStrokeWidth;				sCol = g_vScaleBaseCMYK;				if (isB) {loopDrawsBase = true};				dotArray = undefined;				break;			default:				sW = g_vScaleDefaultStrokeWidth;				sCol = g_vScaleDefaultCMYK;				dotArray = g_hScaleDefaultStrokeDash;		}		if (dotArray === undefined) {			lineEnd = c_defaultLineEnd;		}		else {			// Dotted line forces round line end			lineEnd = 2;		}		aTick = makeLine(tGrp,tPoints,false,undefined,true,sW,sCol,lineEnd,			c_defaultLineMiter,c_defaultLineMiterLimit, c_hScaleTickN + i,c_hScaleTickN + i, dotArray);		// If this tick is the baseline, remember it...		if (loopDrawsBase) {			g_baselineTick = aTick;			loopDrawsBase = false;		}		// Reserve baseline in "left" slot of baseline positions array		if (g_hArray[i][0] == 0) {g_cbBase[0] = g_hArray[i][1]};	}	return true;}// DRAW HV-TICKS ends// CHECK GO LABEL// Called from drawHScaleNames to check whether to give current point// (a) a label, and (b) a long tick...// Returns true or falsefunction checkGoLabel(val,incr)// Args are	current value//			increment flag (2=5; 3=10){	var cgl = false;	if (incr == 2) {		if ((val % 5) == 0) {cgl = true};	}	else {		if ((val % 10) == 0) {cgl = true};	}	return cgl;}// CHECK GO LABEL ends// REVAMP FILTER TICK// REVAMP KLUDGE JAN 2017// Since the way I process ticks and labels is, at this stage in the game,// virtually unintelligible, I'm dealing with the ticklengths issue by// hitting the problem over the head with a hammer.// Function is passed://    tick element//    granularity ('years', 'months'...)//    the tick's length property (on the 1-4 scale)// It inferentially decides what length the tick should really, really be...// ...and resets one of the pathpoint.function revampFilterTick(tickO, tickSeries, tickBound) {  // Get both pathPoints, and their x and y anchor points  var pp1 = tickO.pathPoints[0];  var pp2 = tickO.pathPoints[1];  var ppA1 = pp1.anchor;  var ppA2 = pp2.anchor;  // X coord doesn't change (use pp1's anchor):  var xVal = ppA1[0];  // By granularity...  if ((tickSeries === '10years') || (tickSeries === '5years')) {    // ...and tick length    if (tickBound === 4) {      // Type 4 ticks to 3pts      // Ouch! Wrong end!!      // ppA1[1] -= 2;      // pp1.anchor = pp1.leftDirection = pp1.rightDirection = ppA1;      ppA2[1] += 2;      pp2.anchor = pp2.leftDirection = pp2.rightDirection = ppA2;    } else if (tickBound === 3) {      // Type 3 ticks (last tick) to 2pts      ppA2[1] += 1;      pp2.anchor = ppA2;      pp2.leftDirection = ppA2;      pp2.rightDirection = ppA2;    }  }}