/* Scatter and thermometer tracesCreated 09.01.06Updated 06.11.07 (scatterScaleLabels)Section 1: Scatters	- drawScatter		called from Main.Ilex to draw scatter trace(s)	- tScatObject		called from drawScatter to create trace attributes object		(defines all scatter dots and labels)	- scatterScaleLabels		called from VScales.drawCatStrings to extract scale labels from trace headersSection 2: shared	- drawSpot	- drawSpot		draws single dot (scatter or thermometer)Section 3: Thermometers	- tThermoSpotsObject		creates thermo trace attributes object*/// $.level=1;// DRAW SCATTER// Called from Main.Ilex to draw scatter trace(s)function drawScatter(ptsA, ptsB, tNo, tTot)// Args:	2 arrays of point values (I need 2 vals for each spot -- x & y)//			no. of this trace//			total number of traces{	var thisScatSet;						// An object whose properties define the trace of scatter spots	var scatArray = Array(ptsA.length);	// Array of combined values	for (i = 0; i < scatArray.length; i ++) {		scatArray[i] = Array(ptsA[i], ptsB[i]);	}	// Trace group	g_scatGroup = g_traceLayer.groupItems.add();	g_scatGroup.name = c_tScatGroupN + tNo;	// Properties object	thisScatSet = new tScatObject(scatArray, tNo, tTot)	// Loop spot by spot...	for (i = 0; i < thisScatSet.points.length; i ++) {		// Call spot builder (with trace group; attributes; spot number; scatter flag)		drawSpot(g_scatGroup, thisScatSet, i, true)	}	// Add key object to array... ---- CODE ENTERED 15.02.06 BUT NOT CHECKED	// Slight tweak 2.10.07 picks up on first trace label for each trace "pair"	// (keyObject is in	//	g_keyArray[tNo-1] = new keyObject(((tNo+1) / 2), c_scatterConst, thisScatSet);	g_keyArray[tNo-1] = new keyObject(tNo, c_scatterConst, thisScatSet, 0, true);	return g_scatGroup;}// DRAW SCATTER ends// T-SCAT OBJECT// Called from drawScatter// Constructor for an object whose properties define attributes for// all spots (with labels) in a single scatter trace// Attributes returned:function tScatObject(ptArray, tNo, allT)// Args are: 	array, each element consisting of x & y trace values//				trace number//				total number of traces{	var i;		// counter	var xArray = new Array(ptArray.length);		// horizontal coords	var yArray = new Array(ptArray.length);		// vertical coords	var myArray = new Array(ptArray.length);	// combined coord pairs	// Trace attributes loop after a certain point...	var tStyleNo = tNo;	while (tStyleNo > c_traceLoopNo) {tStyleNo -= c_traceLoopNo};	for (i in ptArray) {		if ((xArray[i] == c_noChartPoint) || (yArray[i] == c_noChartPoint)) {			continue;		}		xArray[i] = calcXValuePos(ptArray[i][0],true);		// Y-coord calc'd by function in Lines module		// False flag to use B-values		yArray[i] = calcYValuePos(ptArray[i][1],false);		myArray[i] = Array(xArray[i],yArray[i]);	}	this.points=myArray;	this.isScatter=true;	// OTHER ATTRIBUTES	// Shape (0=circle; 1=diamond)	this.shape = g_tScatterShape;	this.size = g_tScatterSize;	this.fFlag = g_tScatterFillFlag;	eval("this.fCol = g_tScatter" + tStyleNo + "FillCMYK");	// Stroke	this.sFlag = g_tScatterStrokeFlag;	eval("this.sWidth = g_tScatter" + tStyleNo + "StrokeWidth");	eval("this.sCol = g_tScatter" + tStyleNo + "StrokeCMYK");	// Other	this.lineEnd = c_defaultLineEnd;	this.lineMiter = c_defaultLineMiter;	this.miterLimit = c_defaultLineMiterLimit;	this.name = "";	this.note = this.name;}// T_SCAT OBJECT ends// SCATTER SCALE LABELS// Called from VScales.drawCatStrings// Checks colon-separated trace headers (Trace-name:Axis-name) for consistency// Assigns Axis-names to horizontal and vertical scale label globals for// placing by calling functionfunction scatterScaleLabels(){	var headStrA;		// Complete header strings	var headStrB;	var thisAxisA;	// Current axis labels (as we loop)	var thisAxisB;	var lastAxisA;	// Prev pair of axis labels	var lastAxisB;	var i;			// Counter	pattern = new RegExp(c_scatterHS);	// I have an array of trace headers. For multiple trace-pairs (remember: these are scatters)	// these would typically be:	//		Trace1:AxisA - Trace1:AxisB - Trace2:AxisA - Trace2:AxisB  etc.	// The 2 axes are assigned to the scale labels	// I'm dithering about what to do about scale labels yet. Choices are:	//		- worry about them later, when I place trace labels	//		- extract them now and reserve in globals for later	//		- delete Axis Names from headers as I go, for remainder of headers to be processed later	// For now, I'm going with option 3, which will hopefully yield consistency with other styles...	// Must have even number of headers	if ( (g_headArray.length % 2) == 1) {		myAlert("A scatter chart requires an even number of data columns; please ask the originator to fix the spreadsheet...",			"Scatter traces error");		return false;	}	// Only one trace pair? Nothing much to do here...	if (g_headArray.length < 3) {		// There may still be a colon...		g_catLabelH = g_headArray[0].split(pattern)[1];		g_catLabelV = g_headArray[1].split(pattern)[1];		return true;	}	// Still here? More than one trace pair...	// 		(Axis labels are actually isolated and assigned on first-pair loop;	//		but I loop through all to check for consistency)	try {		// Loop through elements in header array, by pairs		for (i = 0; i < g_headArray.length; i = i + 2) {			headStrA = g_headArray[i];			// 1st header in pair			headStrB = g_headArray[i + 1];		// 2nd header			// Axis-names are 2nd part of each colon-separated string			thisAxisA = headStrA.split(pattern)[1];			thisAxisB = headStrB.split(pattern)[1];			// Delete Axis-names from headers			g_headArray[i] = headStrA.split(pattern)[0];			g_headArray[i + 1] = headStrB.split(pattern)[0];			// Extract axis labels from first pair			if (i == 0) {				g_catLabelH = thisAxisA;				g_catLabelV = thisAxisB;			}			else {				// After first pair,  compare current axis labels with previous				// Provisionally, alert on mismatch; but error is not fatal...				if ( (!(lastAxisA == thisAxisA)) || (!(lastAxisB == thisAxisB )) ) {					myAlert("Axis labels do not match; I'll press on, but please check these on the page...", "Non-fatal anomaly")				}			}			// Reserve current axis labels for comparison on next loop...			lastAxisA = thisAxisA;			lastAxisB = thisAxisB;		}		// Still here?		return true;	}	catch (err) {return false};}// SCATTER SCALE LABELS ends// DRAW SPOT// Called from drawScatter// Draws a single spot for a scatter OR thermometer chartfunction drawSpot(spotTraceGroup, attributes, spotNo, isScatter)// Args://	1) group//	2) an object with these attributes://		points		array of trace-points length, each element consisting of an array of 2 co-ords//		shape		0=circle; 1=diamond; 2=crossbar (REVAMP)//		size		width & height (same)//		fFlag 		fill?//		fCol		fill CMYK//		sFlag		stroke?//		sWidth		stroke width//		sCol		stroke CMYK//		lineEnd//		lineMiter//		miterLimit//		name//		note//		isBar			bar/col flag for thermo 'crossbar' sthyle//		isScat		true=scatter; false = thermometer spot//		label 		(scatter only)//		trace number???????????????????????//	3) number of the spot to draw (from zero)//	4) true if scatter spot; false if thermometer{	var thisspot;	var subGroup;	var spotLink;	var spotLabel;	var linePts;	var rectPts    ;	var labPts;	var thesePoints;	var testVal;	var spotTweak;	// But first trap missing scatter values by adding x + y coords and	// baling out if the result isn't a number...	thesePoints = attributes.points[spotNo];	testVal = thesePoints[0] + thesePoints[1];	if (isNaN(testVal)) {return};	// Still here? I have two coords for centre position	// Depending on shape (circle, diamond)	switch(attributes.shape) {		case 0:			// Circle			thisspot = makeEllipse(spotTraceGroup, attributes.points[spotNo], attributes.size, attributes.size,				attributes.fFlag, attributes.fCol, attributes.sFlag, attributes.sWidth, attributes.sCol,				attributes.name + (spotNo + 1), attributes.note + (spotNo + 1));			break;		case 1:			// Diamond			// I have centre point (x,y) and size; I need top/left/width/height			rectPts = Array(				attributes.points[spotNo][1] + attributes.size/2,				attributes.points[spotNo][0] - attributes.size/2,				attributes.size,				attributes.size );			thisspot=makeRect(spotTraceGroup,rectPts,				attributes.fFlag, attributes.fCol, attributes.sFlag, attributes.sWidth, attributes.sCol,				attributes.name + (spotNo + 1), attributes.note + (spotNo + 1),				Array(0,0),45);			// Adjust size after rotation			// spotTweak = (thisspot.height - attributes.size) / 2;			break;		case 2:			// REVAMP crossbar			// I have centre point (x,y) and size. Get path:			pathArray = [];			if (attributes.isBar) {				pathArray.push([					attributes.points[spotNo][0],					attributes.points[spotNo][1]+(g_thermoCrossLength/2)				]);				pathArray.push([					attributes.points[spotNo][0],					attributes.points[spotNo][1]-(g_thermoCrossLength/2)				]);			}			else {				pathArray.push([					attributes.points[spotNo][0]-(g_thermoCrossLength/2),					attributes.points[spotNo][1]				]);				pathArray.push([					attributes.points[spotNo][0]+(g_thermoCrossLength/2),					attributes.points[spotNo][1]				]);			}			// Note that for this REVAMP style I'm switching fill and stroke...			thisspot=makeLine(spotTraceGroup,pathArray,false,attributes.fCol,				true,g_thermoCrossWidth,attributes.fCol,				0,0,0,attributes.name + (spotNo + 1),attributes.note + (spotNo + 1));			break;		default:			// If all else fails, circle			thisspot = makeEllipse(spotTraceGroup, attributes.points[spotNo], attributes.size, attributes.size,				attributes.fFlag, attributes.fCol, attributes.sFlag, attributes.sWidth, attributes.sCol,				attributes.name + (spotNo + 1), attributes.note + (spotNo + 1));	}	// Scatters add a label	if (isScatter) {		// Create a subgroup		subGroup = spotTraceGroup.groupItems.add();		subGroup.name = "Point " + spotNo;		// Add a pointer		// Coords lifted from spot centre point		linePts = Array(Array(attributes.points[spotNo][0], attributes.points[spotNo][1]),			Array(attributes.points[spotNo][0], attributes.points[spotNo][1] + g_keyLineLength));		// Link uses same stroke colour as spot...		spotLink = makeLine(subGroup,linePts,false,undefined,true,g_keyLinkStrokeWidth,attributes.sCol,c_defaultLineEnd,			c_defaultLineMiter,c_defaultLineMiterLimit, "","");		// Add label		labPts = linePts[1].reverse();		spotLabel = makeText(subGroup, labPts, g_keyFontCMYK, g_keyFontName, g_keyFontSize,			g_keyFontLeading, 1, 0, 100, false, 0, g_catArray[spotNo], "", "", false);		// Move spot into group, at front		thisspot.move(subGroup,ElementPlacement.PLACEATBEGINNING);	}}// DRAW SPOT ends// T-THERMO BLOBS OBJECT// Called from drawThermoColTrace// WHAT ABOUT BARS?// Constructor for an object whose properties define spots for a single// column-thermometer tracefunction tThermoSpotsObject(ptArray, tNo, allT, toLeft, subStyle)// Args are: 	array of trace values//				trace number//				total number of traces//				flag: left or right scale//				sub-style constant{	var i;					// counter	var j = 0;				// counter	// Trace attributes loop after a certain point...	var tStyleNo = tNo;	while (tStyleNo > c_traceLoopNo) {tStyleNo -= c_traceLoopNo};	var bsAllow = 0;			// broken scale margin depth (none by default)	var colTotal;				// number of traces	if ((g_isBS[0]) || (g_isBS[1])) {bsAllow += g_brokenScaleMargin};	// Baseline defaults to bottom of inner box (may be overwritten by zero line, see below)	var cBase = (g_innerBox.top - (g_innerBox.height + bsAllow));	// Two co-ord arrays (spot centres):	var xArray = new Array(ptArray.length);			// x co-ord	var yArray = new Array(ptArray.length);			// y	// The final array will have point-number elements, each consisting of	// a 2-slot array defining each spots centre position (x,y)	var cTraceArray = new Array(ptArray.length);	//	// Y co-ords: for each spot, call calcYValuePos in General module	for (i in ptArray) {		yArray[i] = calcYValuePos(ptArray[i],toLeft);	}	// X co-ords	colTotal = 0; // Set to zero to work round cluster handling by colLArray	xArray = colLArray(ptArray.length, tNo, colTotal, subStyle);	// Combine arrays	for (i = 0; i < ptArray.length; i ++) {		// If there is a skipped value ("*"), don't pass to		// combined array, which is shortened by 1 element		if (yArray[i] == undefined) {			cTraceArray.pop();		}		else {			// Combined array uses separate counter to allow for skipped values			cTraceArray[j] = Array(xArray[i],yArray[i]);			j ++;		}	}	this.points=cTraceArray;	// OTHER ATTRIBUTES	// Revamp introduced the 'crossbar' thermomenter option...	if (g_thermoCross) {		// In response to prompt (which is only seen on thermometers)		// user asked for 'crossbar'		this.shape = 2;	}	else {		// Otherwise use option set in section lookup (circle or diamond)		this.shape = g_tScatterShape;	}	this.size = g_tScatterSize;	// Fill/stroke	this.fFlag = g_tScatterFillFlag;	this.sFlag = g_tScatterStrokeFlag;	// Yes, I know eval is evil. For revamp use specific	// thermo properties. For old use scatter styles	if (g_isRevamp) {		var styleStr = 'g_tCBThermo';	}	else {		styleStr = 'g_tScatter';	}	eval("this.fCol = " + styleStr + tStyleNo + "FillCMYK");	eval("this.sWidth = " + styleStr + tStyleNo + "StrokeWidth");	eval("this.sCol = " + styleStr + tStyleNo + "StrokeCMYK");	// Other	this.lineEnd = c_defaultLineEnd;	this.lineMiter = c_defaultLineMiter;	this.miterLimit = c_defaultLineMiterLimit;	this.name = "to come ";	this.note = this.name;	// REVAMP flag for orientation of thermo crossbars	// (This does column thermos; bar thermos are in Bars > tBarThermoObject)	this.isBar = false;}// T-THERMO BLOBS OBJECT ends