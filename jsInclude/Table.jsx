/* TablesCreated 29.8.06Updated 27.02.07 (alternate tints)*/// DRAW TABLE// Called from Main.Ilex// Background boxes/panels and strings (Sub/Title, Source, Footnotes) have been drawn.// Inner box is set at top to bottom of subtitle string;// at bottom, to pref distance above source/footnotesfunction drawTable(){	var tRange;	// table range object	var tweak;	// adjustment for bottom of chart	var i;		// counter	var thisI;	// object holder	// Headers are already in 1-dim g_headArray;	// Combine  category and value strings into 2-dim g_tContentArray	if (!buildTContentArray()) {return false};	// Create text range with throwaway contents	if (!initTBlock()) {return false};	// Create group for rules	g_tableRuleGroup = g_backLayer.groupItems.add();	g_tableRuleGroup.name = c_tableRuleGroupN;	// Insert headers text	tRange = g_tableRange.textRanges[0];	tRange.contents = trans_String(g_headArray);	// Contents	if (!fillTRange(tRange)) {return false};	// Adjust chart size:	tweak = g_trHeight - (g_innerBox.top - g_innerBox.height) - g_tRuleBelow;	g_innerBox.height -= tweak	// Try to tweak positions of all items that might exist below content block	// Don't worry if they don't exist	// Panel bottom	// NEED TO FIX PANEL PROBLEM HERE	// alert("Panel depth problem still needs fixing...")	try {		for (i = 1; i <= g_totalPanelNo; i ++) {			thisI = g_backLayer.groupItems[c_backGroupN].pageItems[c_panelN + i];			thisI.height -= tweak;		}	}	catch (err) {};	// Source	try {		g_backLayer.textFrames[c_sourceN].top += tweak;	}	catch (err) {};	// Footnote	try {		g_backLayer.textFrames[c_footnoteN].top += tweak;	}	catch (err) {};	// Background box(es)	// Always extend background box 1 and any independent bottom stroke	try {		g_backLayer.groupItems[c_backGroupN].pageItems[c_backBoxN + 1].height -= tweak;	}	catch (err) {};	try {		g_backLayer.groupItems[c_backGroupN].pageItems[c_bb1BottomStrokeN].top += tweak;	}	catch (err) {};	// Bb2 is conditional	try {		thisI = g_backLayer.groupItems[c_backGroupN].pageItems[c_backBoxN + 2];		// Only tweak any background box whose bottom extends below the top of the data range		if ((thisI.top - thisI.height) < g_tableRange.top) {			if ((thisI.top - thisI.height) > g_trHeight) {				thisI.height -= tweak;			}			else if ((thisI.top - thisI.height) < g_trHeight) {				thisI.height += tweak;			}		}	}	catch (err) {};	return true;}// DRAW TABLE ends// BUILT T-CONTENT ARRAY// Called from drawTable to (re!)-combine category and value arrays// into a single array of table content datafunction buildTContentArray(){	var i;	try {		g_tContentArray = new Array(g_catArray.length - 1)		for (i = 0; i < g_catArray.length; i ++) {			// Pass cat string to "line" element as 1st "column" element			g_tContentArray[i] = 	g_catArray[i].split();			// App subsequent "column" elements to line			if (typeof g_valArray[i] == "string") {				// Just one col of value data				g_tContentArray[i].push(g_valArray[i]);			}			else {				// 1+ columns in an array				g_tContentArray[i] = g_tContentArray[i].concat(g_valArray[i]);			}			g_tContentArray[i] = g_tContentArray[i].join("\t")		}		// And while I'm here, delete table marker from 1st header string		// and convert header array to tab-sep'd string		g_headArray[0] = g_headArray[0].replace(c_tablePrefix, "");		g_headArray = g_headArray.join("\t");		return true;	}	catch (err) {		unexpectedErrorAlert(err,"Tables.buildTContentArray()","Data conversion error")	return false};}// BUILT T-CONTENT ARRAY ends// INIT T_BLOCK// Called from drawTable// Just creates a text range object with baseline at header positionfunction initTBlock(){	try {		var tOrigin = g_subtitleRange.anchor.reverse();		// But I have to allow for any extra subtitle lines...		var stXtra = ((g_subtitleRange.lines.length - 1) * g_subtitleFontLeading);		tOrigin[0] -= (g_tHeadSpaceAbove + stXtra);		// Baseline for decrementation		g_trHeight = tOrigin[0];		// Create range with throwaway content ("a"), but with header attributes		g_tableRange = makeText(g_panelLayer,tOrigin,g_tHeadFontCMYK,			g_tHeadFontName,g_tHeadFontSize,g_tHeadFontLeading,0,0,g_tHeadHScale,			0,false,"a",c_tableRangeN,c_tableRangeN,true);		// Check it exists:		if (g_tableRange == undefined) {return false};		else {return true};	}	catch (err) {		alert(err + "\nUnexpected error in Table.jsx / initTBlock. Unable to proceed...");		return false;	}}// INIT T_BLOCK ends// FILL T-RANGE// Called from drawTable// Appends contents paras to existing table rangefunction fillTRange(tR)// Arg is text range consisting of 1 line: header para{	var i;	var tLine;	var ruleNo = 1;	// Rule below headers:	drawRule(true, ruleNo);	try {		// Loop line by line, adding para and setting attributes		for (i = 0; i < g_tContentArray.length; i ++) {			tLine = tR.paragraphs.add(trans_String(g_tContentArray[i]));			// Set font (function in Utilities finds font object matching name)			tLine.characterAttributes.textFont = setFName(g_tContentFontName);			tLine.characterAttributes.size = g_tContentFontSize;			// font size			tLine.characterAttributes.autoLeading = false;					// leading			tLine.leading = g_tContentFontLeading;			tLine.characterAttributes.horizontalScale = g_tContentHScale;		// hScale			// Colour object (function in Utilities)			tLine.characterAttributes.fillColor = makeColourObject(g_tContentFontCMYK);			// Decrement baseline position			g_trHeight -= g_tContentFontLeading;			// Draw rule below line (incrementing rule no.)			ruleNo ++;			if (i < (g_tContentArray.length - 1)) {drawRule(false, ruleNo)};			// Last line uses top/bottom style			else {drawRule(true, ruleNo)};		}		return true;	}	catch (err) {		unexpectedErrorAlert(err,"Tables.fillTRange()","Table text error");	return false};	}// FILL T-RANGE// DRAW RULE// Called from fillTRange to draw rulesfunction drawRule(aRule, rNo)// Arg 1 is true for top/bottom rules; false for other rules// Arg 2 is line number{	var rWidth;	var rCMYK;	var rDash;	var rCap;	var it;	var i;	var dashObj;	if (aRule) {		rWidth = g_tRuleAWidth;		rCMYK = g_tRuleACMYK;		rDash = g_tRuleADash;		rCap = g_tRuleACap;	}	else {		rWidth = g_tRuleBWidth;		rCMYK = g_tRuleBCMYK;		rDash = g_tRuleBDash;		rCap = g_tRuleBCap;	}	// This originally created an empty or array object	// Now creates a simple array, empty or otherwise...	if ((rDash == undefined) || (rDash[0] == 0)) {		//dashObj = {};		dashObj = Array()	}	else {		// dashObj = new Array(rDash.length);		dashObj = Array(rDash.length);		for (i = 0; i < dashObj.length; i ++) {			dashObj[i] = rDash[i];		}	}	var rPts = Array(Array(1),Array(1))	rPts[0][0] = g_innerBox.left;	rPts[0][1] = g_trHeight - g_tRuleBelow;	rPts[1][0] = g_innerBox.left + g_innerBox.width;	rPts[1][1] = g_trHeight - g_tRuleBelow;	try {		makeLine(g_tableRuleGroup, rPts, false, Array(0,0,0,0),			true, rWidth, rCMYK,			rCap, 2, 4,			c_tableRuleN + rNo, c_tableRuleN + rNo, dashObj)		// Alternate tints behind?		if (g_tAlternateTints) {			doTint((g_trHeight - g_tRuleBelow), rNo)		}		return true;	}	catch (err) {return false};}// DRAW RULE ends// DO TINT// Function starts or ends a tinted box behind the data. Called from// drawRuleAcross whenever a dashed or solid under-rule is drawn// 	(Note: this function is virtually identical to one in "Indicators"// 	so if one changes, both should probably change...)function doTint(atHeight, tNo)// Args: current baseline & rule number{	var tb;	var tbArray = Array(3);	// Initially, "g_tintBoxTop" is undefined (not mentioned outside	// this function, apart from being init'd by "Declarations")	if (g_tintBoxTop == undefined) {		// undefined, so we're starting a tint box --		// redefine box top as current baseline		g_tintBoxTop = atHeight;	}	else {		// g_tintBoxTop has a value: the top of the tint box		// current baseline is bottom		// So create array (t,l,w,h)		tbArray[0] = g_tintBoxTop;		tbArray[1] = g_innerBox.left;		tbArray[2] = g_innerBox.width;		tbArray[3] = g_tintBoxTop - atHeight;		// Draw and stack tint box		tb = makeRect(g_tableRuleGroup, tbArray,			true, g_tAlternateTintCMYK,			false, 0, g_tAlternateTintCMYK,			c_tableTintN + tNo, c_tableTintN + tNo);		tb.move(g_tableRuleGroup, ElementPlacement.PLACEATEND);		// Reset top value as undefined		g_tintBoxTop = undefined;	}}// DO TINT