/* UtilitiesCreated 10.11.05Updated 27.07.10 (modded convertPath to handle FT error on workstation name)Updated 5 Mar 13 to add XMP library open/close-	getPreliminaries		Sets a few globals at startupOne group of functions deals with lookup files:-	parseLookup (called from Start_up.getPaths/getGeneralPrefs/getDataB/getSectionPrefs)		controls functions to extract and assign lookup values:--		- stripLookup			strips commented-out lines from multi-line string			converts to array		- assignVar			splits lookup pairs, assigning value to a declared variable			matching the label			Calls:--			- forceType				forces certain values (booleans, numbers) to typeDataA functions-	assignData		controls:--		- findBlobHead		Locates blob headers in DataA		- traceHasBlobs		Matches trace and blob header stringsOthers...-	formatNumberBy3		formats numbers ("1,000")-	italicise		italicises text range- 	makeSemiCircle		cuts ellipse in halfGeneral-purpose procedures-	readInFile		reads in text file-	checkPath		verifies that a file/folder exists-	checkSep		ensures path strings end with a single separator-	closeEnough		does fuzzy comparison of two numbers and returns true if		they are acceptably close in value. This was designed for		index checking -- I'm not sure that it's called any more...		...so alert inserted-	listArgs		debugging utility displays arguments passed to a function		(which must be modded to call it)-	makeSemiCircle-	isInteger		added Jan 08 to test for integers...-	realTextBounds		added Dec 08; returns outline-left,right,top,bottom of a text range object		(currently used to place global +/– relative to vScale strings...)-	tableToThousands		added Apr 09; in Tables, mediates conversion of numbers to '000 formatRedundant-	reformatVals		orig'y handled normal/thousands/millions scale values		but this is now done in Excel*/// $.level=1// GET PRELIMINARIES// Called from Main:Ilex and Economist:saveToCCI// Just fills in a few necessary globals...function getPreliminaries(){	try {		// Pre-lookup author name (defined in visible file)		g_authorContact = c_authorName;		// Operating system		var s = $.os;		var pattern = /Windows/;		if (s.search(pattern) < 0) {			g_isMac = true;			g_desktopPath = "~/Desktop/";		}		else {			g_isMac = false;			g_desktopPath = "~/Desktop/";		}		// Application version as whole number		g_appVersion = app.version.substr(0,2);		// Set the flag to prevent repeated Primitive error messages:		g_primitiveError = false;		// Reset this, for panel subtitles:		// (Some explanation in Declarations, but frankly not much)		g_panelSubtitleExtra = 0;		return true;	}	catch (err) {		myAlert("I tripped over my own feet in the start-up function Utilities:getPreliminaries " +			"Please contact Donald Hounam...","Fatal error")		return false;	}}// GET PRELIMINARIES ends//* PARSE LOOKUP// Converts contents of a lookup file (paths or prefs) to array, disregarding comments// Calls assignVars to assign individual values to variablesfunction parseLookup(pStr, luFile)// Arg 1 is multiline string// Arg 2 is name of lookup file{	// Convert to array, deleting comments	pStr = stripLookup(pStr);	// I now have an array of path definitions in the form:	// PathID=string (not trimmed...)	// Function passes paths to global vars	for (i in pStr) {		if (!assignVar(pStr[i], luFile)) {			return false;		}	}	return true;}// PARSE LOOKUP ends//* STRIP LOOKUP// Strips commented-out lines (preceded by ";;") from multi-line string// In the process, converts to an arrayfunction stripLookup(s)// Arg is multi-line string to parse{	var result;	var i;			// counter	// Zero-length array for result:	result = new Array(0);	// Convert multiline to array (RegExp is newline)	pattern = /\n/;	s = s.split(pattern);	// Define RegExp for comment marker:	pattern = new RegExp(c_comment);	// Transfer un-comm'd out strings to result array	for (i in s) {		if (!s[i].match(pattern)) {			result.push (s[i]);		}	}	return result;}// STRIP LOOKUP ends//* ASSIGN VAR// This uses the eval() method to assign lookup values// from preferences and paths lookup files to variables; it then// splits any itemised values into array elements// Also strong-arms strings into booleans and numbers// The *assumption* is that <variable-name> exactly matches the name of a global variable// If no match, generates an exception and everything falls over...function assignVar(s, avSource)// Args are: 	a string, theoretically in the form <variable-name>==<string>//				the name of the source file (for error alert){	var sKept;		// keep original string for error alert	var g = "g_"		// global var prefix	var item;		// refers to array elements	var tempHolder	// holder to get round all this eval() shuffling!	sKept = s;	try {		// Separate label from value (no separator --> error)		pattern = RegExp(c_lookupSep);		s = s.split(pattern);		// Pass value to temporary holder:		tempHolder = s[1]		// If there is no value (eg "footnote="), the value is undefined		// Trap and return		if (tempHolder == undefined) {			eval(g + s[0] + " = tempHolder");			return true;		}		// Some values are itemised (previously comma, now "|")		// So split assigned string into array elements		// (if only one item, no problem!)		// (-   "|" needs escape character   -)		pattern = RegExp("\\" + c_valSep);		if (s[1].search(pattern) < 0) {			// Just one value			tempHolder = forceType(s[1]);		}		else {			// Value is array			tempHolder = s[1].split(pattern);			for (item in tempHolder) {				// Non-itemised must be strong-armed into being booleans or numbers...				// ...unless they don't exist in the first place! Undefined values				// stay undefined and will be picked up later... (I hope!!)				tempHolder[item] = forceType(tempHolder[item])			}		}		// tempHolder now contains 1 or more array elements, appropriately typed		// Pass checked value back to eval'd global:		eval(g + s[0] + " = tempHolder");	}	catch (err) {		msg = c_I + " was unable to make sense of a line in a lookup file.\n";		msg += "The offending line is:\n   " + sKept;		msg += "\nThe lookup file is:\n   " + avSource;		msg += "\nThe reported error is:\n   " + err;		msg += "\n\nThis is a fatal error. Please contact " + c_authorName;		msg += " and advise him that this problem arose in assignVars()...";		myAlert(msg, "Fatal data error");		return false;	}	return true}// End ASSIGN VAR//* FORCE TYPE// Called from assignVar// Forces a string to boolean or number; leaves undefined values alonefunction forceType(luS)// Arg is a string (path or value) from a lookup file{	// Undefined	if (luS == undefined) {		return undefined;	}	// Trim	luS = trimAll(luS)	// Trap situation whereby value consisted only of 1 or more rogue space characters	if (luS.length == 0) {		return undefined;	}	// Boolean	else if (luS.toUpperCase() == "TRUE") {		return true;	}	else if (luS.toUpperCase() == "FALSE") {		return false;	}	// Number	// But also trap strings like "2005 score", which evaluate as !isNaN	// and which, converted to a number, will return "2005", by searching	// for any space character...	else if ( !isNaN(luS) && (luS.search(" ") < 0) ) {		return Number(luS);	}	// String	else if (luS.toLowerCase() == c_lConst) {return c_lConst};	else if (luS.toLowerCase() == c_rConst) {return c_rConst};	else if (luS.toLowerCase() == "centre") {return c_cConst};	else if (luS.toLowerCase() == "center") {return c_cConst};	else if (luS == " ") {return undefined};	else {		return luS;	}}// FORCE TYPE ends// ASSIGN DATA// Called from getDataA()// Function is passed a multi-line string of tab-separated items// It isolates and assigns://		top-row of headers (if any) to:	g_headArray & g_blobHeadArray//		categories (column 1) to:			g_catArray//		values to:						g_valArray (2-dimensional array of arrays)//		blobs (if any) to:				g_blobArray// Also trips table flagfunction assignData(theData){	var tempArray;	var itemPattern;		// delimiter	var i;	var j;	var eachLine;	var blobColumnNo;		// number of "column" where blobs start	var s;				// string holder	try {		itemPattern = new RegExp(c_dataSep);		// Headers		pattern = new RegExp("\n");		tempArray = theData.split(pattern);		// Check for blank row(s) at bottom...		for (i = tempArray.length - 1; i > 0; i --) {			if (tempArray[i] == undefined) {				tempArray.pop();			}			else {				break;			}		}		// search for headers marker in top row:		pattern = new RegExp(c_resPrefix);		if (tempArray[0].search(c_resPrefix) == 0) {			g_headArray = tempArray[0].split(itemPattern);			// Table? Trip flag			if (g_headArray[0].search(c_tablePrefix) == 0) {g_isTable = true};			if (g_isTable) {				// Tables keep any col A header, minus label				g_headArray[0] = g_headArray[0].replace(c_tablePrefix,"");			}			else {				// Charts look for blobs				if (g_blobFlag) {					blobColumnNo = findBlobHead();					if (blobColumnNo == undefined) {						// Despite blobs flag being set, no blob header found						// Complain:						msg = "I expected this data to contain a recognisable range of blobs, " +							"but I see no sign of them. Please try reflowing through Excel. " +							"If this problem persists, complain to " + c_authorName;						myAlert(msg, "Blobs error");						return false;					}				}				// Throw away the prefix:				g_headArray.shift();			}			// Delete first line of data			tempArray.shift();		}		else {			// no headers found, so...			g_headArray = Array("Trace 1")		}		// tempArray now contains row-prioritised data where each row		// includes a category, several values and -- possibly -- blob categories & values		// Convert each row to sub-array		for (i in tempArray) {			tempArray[i] = tempArray[i].split(itemPattern);		}		// Transpose tempArray		tempArray = transposeArray(tempArray);		// So array now contains cats, vals and blobs (?) by columns		// Separate blobs, if any		if (g_blobFlag) {			j = 0;			for (i =  blobColumnNo; i < tempArray.length; i ++) {				g_blobArray[j] = tempArray[i];				j ++ ;			}			tempArray = tempArray.slice(0, blobColumnNo);		}		// Separate values		j = 0;		for (i =  1; i < tempArray.length; i ++) {			g_valArray[j] = tempArray[i];			j ++ ;		}		tempArray = tempArray.slice(0,1);		// Temp array contains cats as a 2-D array in which a single element consists		// of row-number sub-elements. I want a 1-D array...		g_catArray = Array(tempArray[0].length - 1)		for (i in tempArray[0]) {			g_catArray[i] = tempArray[0][i]		}		// Charts (non-tables) only --		// Force numbers in values array (let blank point markers through)		if (!g_isTable) {			for (i in g_valArray) {				for (j in g_valArray[i]) {					// If I have a string starting with a number and space ("1 more time"), the string					// evaluates as a number; then forcing it to a number strips off the non-numeric section					// of the string...	(tables only)					// So remove spaces before testing:					s = g_valArray[i][j].replace(" ","")					if (!isNaN(s)) {						g_valArray[i][j] = Number(s);					}				}			}		}		// Tables only --		// Transpose values back to "row" priority (with '000 format)		else {			// Transpose...			g_valArray = transposeArray(g_valArray);			// Set numbers to 1,000 format if that preference is			// flagged for vertical scales (ie assume consistent house style)			// Function tableToThousands, in this module, calls FormatNumberBy3 in Utilities.jsx			if (g_vScaleCommas) {				tableToThousands();			}		}		return true;	}	catch(err) {		unexpectedErrorAlert(err,"Utilities.assignData()","Data assignment error ")		return false;	}}// ASSIGN DATA ends// TRIM ALL// Currently called only from forceType to trap rogue space lookup values// which get converted to a number!function trimAll(tString){	while(tString.substring(0,1) == " ") {		tString = tString.substring(1,tString.length);	}	while(tString.substring(tString.length - 1 ,tString.length) == " ") {		tString = tString.substring(0,tString.length - 1);	}	return tString;}// TRIM ALL ends// SET LAYER COLOR// Sets colour for a new layerfunction setLayerColor(theLayer,theRGB)// Args are layer object; array of RGB colours{	var myColor = new RGBColor()	myColor.red = theRGB[0]	myColor.green = theRGB[1]	myColor.blue = theRGB[2]	theLayer.color = myColor}// SET LAYER COLOR ends// MY ALERT// General alert allows for either platformfunction myAlert(myMsg, myHead)// Args are main message and header strings// Header is not shown on Macintosh, so is prefixed to message as separate line{	if (g_isMac) {		msg = myHead + "\n" + myMsg;	}	else {		msg = myMsg;	}	alert(msg, myHead, true);}// MY ALERT ends// UNEXPECTED ERROR ALERT// Error alertfunction unexpectedErrorAlert(what, where, eHead)// Args are error; function where it occurred; and header string// Header is not shown on Macintosh, so is prefixed to message{//	alert(what,eHead,true)	if (g_isMac) {		msg = eHead + "\n" + what + "\nThis unexpected error was reported by " + where;	}	else {		msg = what + "\nThis unexpected error was reported by " + where;	}	msg += "\n\nPlease advise " + c_authorName + " that this error occurred...";	alert(msg, eHead, true);}// UNEXPECTED ERROR ALERT ends// FORCE FOLDER// Checks whether a folder exists; if it doesn't, creates itfunction forceFolder(f)// Arg is folder path{	var fObj;	// If it doesn't exist, try to create it	fObj = new Folder(f)	if (!fObj.exists) {		if (!fObj.create()) {			return false;	// failed to create		}	}	return true;}// FORCE FOLDER ends// RESIZE GROUP// Resizes a group of items without squeezing/stretching individual items// Mainly designed for use with text...// There's an assumption that I always construct groups from bottom to top, or from left to right!// My "blPos" will always be bottom/left; "trPos" top/rightfunction resizeGroup(sG, amount, isV, moveTop, moveRight)// Args: group of items to squeeze//		amount by which group should be made bigger (minus value shrinks)//		vertically/horizontally//		move top/bottom item (i.e. if moveTop = true, top item moves)// 		move left/rightmost item{	var blPos;								// bottom left position	var trPos;								// top right position	var incr;								// increment	var total = sG.pageItems.length - 1;		// no of items in group (paths or text)	var newPosArray = new Array(total);		// array for new co-ords	// Designate first and last items in group	// (Order reverses from original construction order)	var blItem = sG.pageItems[total];	var trItem = sG.pageItems[0];	// And their current positions in whichever axis	if (isV) {		blPos = blItem.top;		trPos = trItem.top;		if (moveTop) {			// top moves up/down			trPos += amount;		}		else {			blPos -= amount;		}		incr = (trPos - blPos) / total;		// Loop through group, adjusting each item		for (var i = 0; i <= total; i++) {			sG.pageItems[i].top = trPos;			if (sG.pageItems[i].typename == "TextFrame") {				newPosArray[i] = sG.pageItems[i].anchor[1];			}			else {				newPosArray[i] = trPos;			}			trPos -= incr;		}	}	else {		blPos = blItem.left;		trPos = trItem.left;		if (moveRight) {			// right moves left/right			trPos += amount;		}		else {			blPos -= amount;		}		incr = (trPos - blPos) / total;		// Loop through group, adjusting each item		for (var i = 0; i <= total; i++) {			sG.pageItems[i].left = trPos;			if (sG.pageItems[i].typename == "TextFrame") {				newPosArray[i] = sG.pageItems[i].anchor[0];			}			else {				newPosArray[i] = trPos;			}			trPos -= incr;		}	}	// Return array of new positions	// For paths this is left/top; for text it is h- or v-origin	return newPosArray.reverse();}// RESIZE GROUP ends// GET T-FRAME SIZE// Returns the width, depth, left and right of a single textFrame by creating an outline (calls makeOutline)function getTFrameSize(string, fName, fSize, fScale, deleteOriginal, isTabular)// Args are 	string;//				font name, size and h-scaling//				true to delete original object//				tabular flag{	var sObj;	var anchorVPos;	// Just pick top layer, but make sure unlocked:	var tempLayer = activeDocument.layers[0];	var lockAgain = false;	if (tempLayer.locked) {		lockAgain = true;		tempLayer.locked = false;	}	if (isTabular === undefined) {		isTabular = false;	}	sObj = makeText(tempLayer,Array(0,0),Array(0,0,0,100),fName, fSize, fSize,0,		0,fScale,0,false,string,"","",isTabular);	anchorVPos = sObj.anchor[1];	var outline = makeOutline(sObj, true);	var w = outline.width;	var h = outline.height;	var l = outline.left;	var r = outline.left + outline.width;	this.width = w;	this.height = h;	this.left = l;	this.right = r;	this.tweak = anchorVPos - (outline.top - h);	outline.remove();	if (deleteOriginal) {sObj.remove()};	// Relock layer if necessary	if (lockAgain) {tempLayer.locked = true};}// GET T-FRAME SIZE ends// MAKE OUTLINE// Called from getTFrameSize (above)// Creates (temporary) outline(s) from text range/group for position adjustmentfunction makeOutline(theT,isRange)// Args are:		the object//				flag for range/group{	var theOut;	var i;	theOut = theT.duplicate();	if (isRange) {		// text range		theOut = theOut.createOutline();	}	else {				// group of text ranges		for (i = (theOut.textFrames.length - 1); i >= 0; i--) {			theOut.textFrames[i].createOutline();		}	}	return theOut;}// MAKE OUTLINE ends// V-CENTRE TEXT ON// Variously called to centre text vertically within a pathfunction vCentreTextOn(vTxt, vObj)// Args are text range and path, both as objects{	var vOutline = makeOutline(vTxt, true);	var outHalf = vOutline.height / 2;	var outTop = vOutline.top;	// In move, path's strokewidth has to be taken into account. However,	// if path has no stroke, there may be a default width setting, which	// has to be overridden...	var oSW;	if  (vObj.stroked) {oSW = vObj.strokeWidth / 2};	// No stroke set: use zero	else {oSW = 0};	var tMove = outTop - ( (vObj.top - oSW) - (vObj.height / 2) + outHalf );	// Move range; delete outline	vTxt.top -= tMove;	vOutline.remove();}// V-CENTRE TEXT ON ends// MONTH NAME// Converts month number (0-11) into namefunction monthName(mNo, format)// Args are month number; and flag for length of string to return{	var mList = Array("January","February","March","April","May","June","July",		"August","September","October","November","December");	var mStr = mList[mNo]	switch (format) {		case 1:		// "J"			return mStr.slice(0,1);		case 2:		// "Jan"			return mStr.slice(0,3);		default:	// "January"			return mStr;	}}// MONTH NAME ends// M-LENGTH// Returns number of days in a monthfunction mLength(mD)// Arg is date object{	var m = mD.getMonth()	if (m == 1) {		// Feb		if (yLength(mD) == 365) {return 28};		else {return 29};	}	else {				// look up other months in array constant		return c_mLengths[m];	}}// M-LENGTH ends// Y-LENGTH// Returns number of days in a yearfunction yLength(yD)// Arg is date object{	if ((yD.getFullYear() % 4) == 0) {		return 366;	}	else {		return 365;	}}// Y-LENGTH ends// COUNT DP// Returns number of decimal places in a number// (Currently used to determine # of dps to draw vertical scale labels, using increment value)function countDP(n){	var s = n.toString()	var origLen = s.length	var dp = /\./	var result = s.search(dp)	if (result < 0) {		{return 0};	}	else {		return (origLen - (result + 1));	}}// COUNT DP ends// TRANSPOSE ARRAY// Called from assignData to transpose DataA cats/values/blobsfunction transposeArray(inA){	var i;			// counters	var j;	var colNo = 0;	// Holds max no. of "cols"	// Init outgoing array	// I originally set its length to the no. of "cols" in 1st "row" of incoming;	// however, if this is a table, with blank elements in the first row, I can "lose"	// an entire column!	// So loop down thro' entire incoming array and get max no. of "cols"...	for (i = 0; i < inA.length; i++) {		if (inA[i].length > colNo) {colNo = inA[i].length};	}	// Init outgoing array to max no. of "cols"	//var outA = Array(inA[0].length);	var outA = Array(colNo);	// Transpose	for (i = 0; i < outA.length; i++) {			// loop by "cols"		outA[i] = Array(inA.length);				// "col" slot in outgoing has row-number elements		for (j = 0; j < inA.length; j++) {		// loop by "rows" in this "col"			outA[i][j] = inA[j][i];		}	}	return outA}// TRANSPOSE ARRAY ends// FIND BLOB HEAD// Called from assignData. Locates the blobs header element// in the array of headers. Returns the number of the "column"// where blobs start...function findBlobHead()// Global g_headArray already contains array of main and (hopefully) blob headers{	var hCount;							// counter for headers array	var bCount = 0;						// counter for blob headers array	var bPattern = RegExp(c_blobPrefix);	// blob header to search for	var bNo;	g_blobHeadArray = undefined;			// by default	for (hCount = 0; hCount < g_headArray.length; hCount ++) {		if (g_headArray[hCount].search(c_blobPrefix) > -1) {			// blob head found: remember "column"			bNo = hCount;			break;		}	}	// If blob header string found, reduce header arrays to required elements	if (!(bNo == undefined)) {		// Blob headers array only initialised if header was found		g_blobHeadArray = g_headArray;		g_headArray = g_headArray.slice(0,bNo);		g_blobHeadArray = g_blobHeadArray.slice(bNo);		// While we're still here, strip prefix from first element		g_blobHeadArray[0] = g_blobHeadArray[0].replace(c_blobPrefix,"")	}	// Return the number of the "column" where blobs begin	// If no blob header found, returns undefined, which is trapped by caller	return bNo;}// FIND BLOB HEAD ends// TRACE HAS BLOBS// Called from Bars.drawBars and Columns.drawColums// Returns blob values for this trace by matching current main trace header with// array of blob trace headers; no match returns undefinedfunction traceHasBlobs(t, tTotal)// Args:		trace number (from 1)//			total # of traces{	var s;	var i;	var result = undefined;	if (g_blobFlag) {		// There are blobs...		// If only one trace, return first column of blob vals found		// (Col 0 is col. of duplicated categories)		if (tTotal == 1) {			result = g_blobArray[1]		}		// More than one trace:		else {			// If only one column of blobs [as well as cat strings]			// (This is a forgiving workaround if the blob header for a single column			//		of blobs doesn't match one of several traces)			if (g_blobHeadArray.length < 3) {				result = g_blobArray[1]			}			// More than one column of blobs			else {				// Check main header for this trace against blob headers				// Use one that matches				s = g_headArray[t - 1]				for (i = 1; i < g_blobHeadArray.length; i ++) {					if (s == g_blobHeadArray[i]) {						// Main & blob headers match:						result = g_blobArray[i]					}				}			}		}	}	return result;}// TRACE HAS BLOBS ends/*FORMAT NUMBER BY 3Author: Robert Hashemianhttp://www.hashemian.com/You can use this code in any manner so long as the author'sname, Web address and this disclaimer is kept intact.********************************************************Usage Sample:<script language="JavaScript" src="http://www.hashemian.com/js/NumberFormat.js"></script><script language="JavaScript">document.write(FormatNumberBy3("1234512345.12345", ".", ","));</script>*/// function to format a number with separators. returns formatted number.// num - the number to be formatted// decpoint - the decimal point character. if skipped, "." is used// sep - the separator character. if skipped, "," is usedfunction FormatNumberBy3(num, decpoint, sep) {  // check for missing parameters and use defaults if so  if (arguments.length == 3) {	dPlaces = -1;  }  if (arguments.length == 2) {	dPlaces = -1;    sep = ",";  }  if (arguments.length == 1) {	dPlaces = -1;    sep = ",";    decpoint = ".";  }	// trap negatives before converting to string	// (to prevent scales displaying, e.g., "-,100")	var isNeg = false;	if (num < 0) {		isNeg = true;		num = Math.abs(num);	}  // need a string for operations  num = num.toString();  // separate the whole number and the fraction if possible  a = num.split(decpoint);  x = a[0]; // decimal  y = a[1]; // fraction  z = "";  if (typeof(x) != "undefined") {    // reverse the digits. regexp works from left to right.    for (i=x.length-1;i>=0;i--)      z += x.charAt(i);    // add separators. but undo the trailing one, if there    z = z.replace(/(\d{3})/g, "$1" + sep);    if (z.slice(-sep.length) == sep)      z = z.slice(0, -sep.length);    x = "";    // reverse again to get back the number    for (i=z.length-1;i>=0;i--)      x += z.charAt(i);    // add the fraction back in, if it was there    if (typeof(y) != "undefined" && y.length > 0)      x += decpoint + y;  }	if (isNeg) {		x = "-" + x;	}  return x;}// FORMAT NUMBERS BY 3 ends// ITALICISE// Utility function to convert a TEXTRANGE (probably a subrange) into italics// Uses various subterfuges to find the existing font's italic partner...// Very inferentialfunction italicise(iRange)// Arg is textRange object (ie a substring) to be italicised{	var myF;				// application font object	var fontFlag = false;	// success/failure flag	var originalFont;		// name of original font	var italFont;			// (hopeful) name of italic font	var i;					// counters	var j;	// Links and strings to build up possible italic font name...	var italLinks = Array("","-");					// blank and hyphen	var italStrings = Array("It","al","ic", "MT");	// elements of the word "Italic"													// plus "MT" (for Arial, anyway)	// Start with existing font name	var regFont = iRange.textFont.name;	// But remove any "MT" on the end of the standard font name	if (regFont.search("MT") > -1) {		regFont = regFont.replace(/MT/,"");	}	// ..................................................	// 1) Try adding "It"-"al"-"ic"-"MT" to existing font name	// with or without hyphens	// Loop by italic suffix sub-elements	for (j in italLinks) {		italFont = regFont + italLinks[j];		for (i in italStrings) {			// Append name element:			italFont = italFont + italStrings[i];			// Look for possible name of italic font in application list			try {				myF = app.textFonts[italFont];			}			catch (err) {}			// Did I find this possible name?			if (!(myF == undefined)) {				iRange.characterAttributes.textFont = myF;				fontFlag = true;				break;			}		}	}	// ..........................................	// 2) Try substituting "Italic" for "Regular"	if (!fontFlag) {		italFont = regFont.replace(/Regular/,"Italic")		try {			myF = app.textFonts[italFont];			iRange.characterAttributes.textFont = myF;			fontFlag = true;		}		catch (err) {};	}	// 3) Try rifling through the fonts immediately after the existing font in the application's list	//		(The danger is that if the existing font has no italic version, we'll latch on to the	//		italic version of the NEXT font...)	if (!fontFlag) {		j = 0;		// Loop through for the existing font		// When we found it, mark position and break		for (i = 0; i < app.textFonts.length; i ++) {			if (app.textFonts[i].name == regFont) {				// Font found --				j = i + 3;				break;			}		}		// Sift through next few fonts looking for "Italic" in the name		while (i < j) {			italFont = app.textFonts[i].name;			if (italFont.search("Italic") > -1) {				// Plausible suspect found! Use it and break				myF = app.textFonts[italFont];				iRange.characterAttributes.textFont = myF;				fontFlag = true;				break;			}			i ++;		}	}	if (!fontFlag) {		msg = "I was unable to find an italic match for the above font. " +			"So I have been unable to reformat the following (sub-)string:\n\n" +			iRange.content		// If no plausible font could be worked out, alert		myAlert(msg, regFont);	}	// Returns t/f, even if I don't do anything with it...	return fontFlag;}// ITALICISE ends// EMBOLDEN// Utility function to convert a TEXTRANGE (probably a subrange) into bold// Uses various subterfuges to find the existing font's bold partner...function embolden(iRange)// Arg is textRange object to be emboldened{	var myF;				// application font object	var fontFlag = false;	// success/failure flag	var originalFont;		// name of original font	var boldFont;			// (hopeful) name of italic font	var i;					// counter	var j;	// Links and strings to build up possible italic font name...	var boldLinks = Array("","-");					// blank and hyphen	var boldStrings = Array("Bold","MT");						//	// Start with existing font name	var regFont = iRange.textFont.name;	// But remove any "MT" on the end of the standard font name	if (regFont.search("MT") > -1) {		regFont = regFont.replace(/MT/,"");	}	// ..................................................	// 1) Try adding "Bold" to existing font name	// linked with nothing, then hyphen	for (j in boldLinks) {		boldFont = regFont + boldLinks[j];		for (i in boldStrings) {			//Append name element			boldFont = boldFont + boldStrings[i];			// Look for possible name of bold font in application list			try {				myF = app.textFonts[boldFont];			}			catch (err) {}			// Did I find this possible name?			if (!(myF == undefined)) {				iRange.characterAttributes.textFont = myF;				fontFlag = true;				break;			}		}	}	// ..........................................	// 2) Try substituting "Bold" for "Regular"	if (!fontFlag) {		boldFont = regFont.replace(/Regular/,"Bold")		try {			myF = app.textFonts[boldFont];			iRange.characterAttributes.textFont = myF;			fontFlag = true;		}		catch (err) {};	}	// 3) Try rifling through the fonts immediately after the existing font in the application's list	//		(The danger is that if the existing font has no bold version, we'll latch on to the	//		bold version of the NEXT font...)	if (!fontFlag) {		j = 0;		// Loop through for the existing font		// When we found it, mark position and break		for (i = 0; i < app.textFonts.length; i ++) {			if (app.textFonts[i].name == regFont) {				// Font found --				j = i + 3;				break;			}		}		// Sift through next few fonts looking for "Bold" in the name		while (i < j) {			boldFont = app.textFonts[i].name;			if (boldFont.search("Bold") > -1) {				// Plausible suspect found! Use it and break				myF = app.textFonts[boldFont];				iRange.characterAttributes.textFont = myF;				fontFlag = true;				break;			}			i ++;		}	}	if (!fontFlag) {		// If no plausible font could be worked out, alert		msg = "I was unable to find an italic match for the above font. " +			"So I have been unable to reformat the following (sub-)string:\n\n" +			iRange.content		myAlert(msg, regFont);	}	// Returns t/f, even if I don't do anything with it...	return fontFlag;}// EMBOLDEN ends// ENLIGHTEN// Utility function to convert a TEXTRANGE (probably a subrange) into REVAMP Light/75K// Utterly inferentialfunction enlighten(iRange)// Arg is textRange object (ie a substring) to be italicised{	if (!g_isRevamp) {return true;}	// Colour object	var myCol = makeColourObject([0,0,0,75]);	// Font object is a straight lift from AI_Primitives > makeText	try {		var myF = app.textFonts['EconSansCnd-Light'];	}	catch (err) {};	if (myF == undefined) {		// Supplied font string not matched; use first available as default		// and note substitution (up to 10 instances)		myF = app.textFonts[0];		if (g_fontSubstitutions.length < 10) {			g_fontSubstitutions.push(tName + ": font " + fName + " not installed -- \n" + c_msgIndent +			"substituted font " + myF.name);		}		else if (g_fontSubstitutions.length == 10) {			g_fontSubstitutions.push(c_fontSubString)		}	}	// Set attributes:	iRange.characterAttributes.textFont = myF;	iRange.characterAttributes.fillColor = myCol;	// Whatever happens, it's fine!	return true;}// ENLIGHTEN ends// GENERAL-PURPOSE// ^^^^^^^^^^^^^^^//* READ IN FILE// Reads in the contents of a file and returns themfunction readInFile(theFile)// Arg is name of file to read in{	var fileObj	var isOpen	var contents	try {		fileObj = new File (theFile);		isOpen = fileObj.open("r");		if (isOpen) {			contents = fileObj.read();		}	}	catch (err) {		myAlert ("This error occurred reading in file " + theFile, err);	}	finally {		fileObj.close()	}	// If file wasn't read in successfully, "contents"	// should be undefined (which will evaluate as false at	// the calling point); otherwise contains data	// from file	return contents}// READ IN FILE ends// CONVERT PATH// Called from Start_up/getPaths to convert three paths from Excel to JS format// On Mac, this should also prefix "Volumes" to any remote paths...// Windows paths start with volume letter ("C" etc)...function convertPath(p)// Arg is the path string to convert{	var pElement1;	var f;	if (g_isMac) {		// Convert  Excel/Mac colon-separated path to JS slash-sep'd		var pattern = /:/g;		var newP = p.replace(pattern, "/");		// What am I trying to find out? Whether path points locally or to a remote volume		// If server, top dir = "Volumes"; if local, "Users"		pattern = /\//g;		pElement1 = newP.split(pattern)[0];		//  The following is a "try" because if first element of path is THIS		// computer, "f" is undefined and throws an error...		try {			f = new Folder(pElement1);			if (f.parent.name = "Volumes") {				newP = "/Volumes/" + newP;			}			return newP;		}		catch (err) {			return "/" + newP;		}		return newP;	}	else {		// Windows starts as "C:\directory\filename.ext"		// So convert ":\"		var pattern = /:\\/g;		var newP = p.replace(pattern, "/");		// Convert all back- to forward-slashes		pattern = /\\/g;		var newP = newP.replace(pattern, "/");		// And preceding slash (unless it's a network server with two slashes already preceding path):		pattern = /\/\//;	// RegExp for "//"		if (newP.search(pattern) != 0 ) {			newP = "/" + newP;		}		return newP;	}}// CONVERT PATH ends//* CHECK PATH// Function verifies existence of a folder or file; returns true or falsefunction checkPath(thePath, mustExist)// Args:		path as string//			true if path must exist{	// This comm'd out Mar 07 and replaced as below...	//if (!mustExist) {	//	if (thePath == undefined) {return true};	//	if (thePath.length < 2) {return true};	//}	// Still here? Path is compulsory (or, if optional, seems to want to exist), so check it:	if (mustExist) {		if (!File(thePath).exists) {			msg = "Unable to find file or folder:\n     " + thePath;			msg += "\n\nIf it is on a server, make sure that this is mounted. ";			msg += "Otherwise please verify paths in the Excel module and try again. If this error ";			msg += "persists, contact " + c_authorName;			myAlert (msg, "Path error");			return false;		}	}	return true;}// CHECK PATH ends// CHECK SEP// Checks that any folder path ends with a separatorfunction checkSep(pToCheck)// Arg is path string{	var x;	var y;	// Get string length and position of last occurrence of separator	x = pToCheck.length - 1 ;	y = pToCheck.lastIndexOf(c_pS);	// If final char isn't separator, add one:	if(! (x == y)) {		pToCheck += c_pS;	}	return pToCheck;}// CHECK SEP ends// CLOSE ENOUGH// Does fuzzy comparison of two numbers, returning true if// they are within a margin of closeness// (Also in Convert Scale.jsx "extra"...)function closeEnough(n, compareTo, margin)// Args are the number to check; the value to compare it with; and the margin of closeness{//	alert("In Utilities.closeEnough, doing fuzzy check on 2 values: " + n + "/" + compareTo)	if ((n > (compareTo - margin)) && (n < (compareTo + margin))) {return true};//	if (((n - compareTo) < margin) || ((compareTo - n) < margin)) {return true};	else {return false};}// CLOSE ENOUGH ends// LIST ARGS// Debugging utility: call as "listArgs(arguments)" from any function// to display values of args passedfunction listArgs(aArray){	msg = ""	for (var i = 0; i < aArray.length; i ++) {		msg += aArray[i] + "\n"	}	alert(msg, "Arguments:")}// LIST ARGS ends// SET F-NAME// Called from Indicate.setAttributes and Tables.fillTRange.// (also from Indicators 2007)// Looks for font name in application's// list. If not found, sets font to first in list. Returns font object.function setFName(fName){	var fontFlag = false;	// Default font is first in application's list	var myF = app.textFonts[0];	var i;	for (i = 0; i < app.textFonts.length; i ++) {	    	if (app.textFonts[i].name == fName) {			// Font found -- apply	      	myF = app.textFonts[i];			return myF;   		}	}	// Still here? Font not found so return default font object	return myF;}// SET F-NAME ends// MAKE COLOUR OBJECT// Passed a CMYK array, returns a colour objectfunction makeColourObject(cA){	//Set color values for the CMYK object	// Then wrap the color in a standard color object	var myCol = new CMYKColor();	myCol.cyan = cA[0];	myCol.magenta = cA[1];	myCol.yellow = cA[2];	myCol.black = cA[3];	return myCol;}// MAKE COLOUR OBJECT ends// SKELETON SIZE// Returns the wire path size of an object by creating a duplicate,// unstroking, measuring (top,left,height,width) and deletingfunction skeletonSize(o)// Arg is object (path or group item){	var dupO = o.duplicate();	var i;	// Path or group?	if (dupO.typename == "PathItem") {		dupO.stroked == false;	}	else if (dupO.typename == "GroupItem") {	for (i = 0; i < dupO.pathItems.length; i ++) {			dupO.pathItems[i].stroked = false;		}	}	skeletonSize = Array(dupO.top, dupO.left, dupO.height, dupO.width);	dupO.remove();	return skeletonSize;}// SKELETON SIZE ends// MAKE SEMI-CIRCLE// Currently called for pies only; if drawing half-pie, kills bottom point of donut// to leave a semi-circlefunction makeSemiCircle(obj, position, makeGood, sW)// Args:		circle object//			which point to kill (12/3/6/9)//			true to close path//			stroke width to add{	var p;	// individual points	var i;	// counter	alert("Still working out how to make semicircle")	return	// Object must have 4 points; if not, abandon ship without warning	// (Fcn doesn't return anything, since failure is inconsequential)	if (!(obj.pathPoints.length == 4)) {return};	// I determine points' position by comparing them with the centre point.	// But when the path is stroked, there seems to be a slight rotation of the	// circle, so that the top point, for example, can register as slightly left	// of the centre, so is identified as the 9 o'clock point. So I allow a	// small, arbitrary margin...	var cAnd = obj.width / 100;	var swTweak = 0	// Centre coords (x/y)	// Width = by the wire; but left & top include strokewidth	if (obj.stroked) {		swTweak = obj.strokeWidth / 2	}	var c = new Array(1);	c[0] = obj.left - swTweak + (obj.width / 2);	c[1] = obj.top + swTweak - (obj.height / 2);	// Array to locate points to reset left/rightDirection	// This identifies 2 points by position (12/3/6/9)	// and true/false to move left/rightDirection coords to anchor...	var dArray = new Array(1)	// Array to hold points	// Each element will be a sub-array of point-object & position (12/3/6/9)	var pArray = new Array(3);	// Loop by points	for (i = 0; i < obj.pathPoints.length; i ++) {		// 2 sub-array elements		pArray[i] = new Array(1);		// Sub-element 0 is point object		p = obj.pathPoints[i];		pArray[i][0] = p;		// Evaluate by comparing with centre		if (p.anchor[1] > (c[1] + cAnd)) {			// top			// 2nd element is position (12/3/6/9)			pArray[i][1] = 12;			// If this is the point to be removed,			// Create an array identifying preceding and following points (going clockwise)			//	and whether to set left- or right-Direction to anchor			if (position == 12) {				dArray[0] = new Array(9, false)				dArray[1] = new Array(3, true)			}		}		else if (p.anchor[0] > (c[0] + cAnd)) {			// right			pArray[i][1] = 3;			if (position == 3) {				dArray[0] = new Array(12, false)				dArray[1] = new Array(6, true)			}		}		else if (p.anchor[1] < (c[1] - cAnd)) {			// bottom			pArray[i][1] = 6;			if (position == 6) {				dArray[0] = new Array(3, false)				dArray[1] = new Array(9, true)			}		}		else {			// left			pArray[i][1] = 9;			if (position == 9) {				dArray[0] = new Array(6, false)				dArray[1] = new Array(12, true)			}		}	}	// Deal with what will be end points AFTER one point has been removed.	// I set (eventual) end-points' left-/rightDirection (as appropriate)	// to same as anchor, effectively creating a corner	// Loop through points in array	//	for (i = 0; i < pArray.length; i ++) {		if (!(pArray[i] == undefined)) {			if (pArray[i][1] == dArray[0][0]) {				// Preceding point (going clockwise)				if (dArray[0][1]) {					pArray[i][0].leftDirection = pArray[i][0].anchor				}				else {					pArray[i][0].rightDirection = pArray[i][0].anchor				}			}			if (pArray[i][1] == dArray[1][0]) {				// Following point (going clockwise)				if (dArray[1][1]) {					pArray[i][0].leftDirection = pArray[i][0].anchor				}				else {					pArray[i][0].rightDirection = pArray[i][0].anchor				}			}		}	}	// Knock out unwanted point:	for (i = 0; i < pArray.length; i ++) {		if (!(pArray[i] == undefined)) {			if (pArray[i][1] == position) {				pArray[i][0].remove();			}		}	}	// Close path//	obj.closed = false;	obj.closed = true;	// Finally, stroke: same as fill colour	if (sW > 0) {		obj.	strokeColor = obj.fillColor		obj.strokeWidth = sW	}}// MAKE SEMI-CIRCLE ends// IS INTEGER NUMBER// Returns true if passed value is (a) a number and (b) an integer// (tests for both since dates can be passed...)// (NB: "12.0" and "1.9999999999999999" are interpreted as integers)function isIntegerNumber(it) {	// Default:	var iiResult = false;	// If this can be interpreted as a number	if (!isNaN(it)) {		var theCeil = Math.ceil(it);		if(!(theCeil>it)) {iiResult = true};	}	return iiResult;}// IS INTEGER	 ends// REAL TEXT BOUNDS// Returns the ACTUAL (outline) left, right, top and bottom of a text range objectfunction realTextBounds(tR)// Arg is one of three alignment constants (l/c/r){	var rteBounds = new Array(3);	var o;	try {		// Create outline (text range object, is range rather than group)		o = makeOutline(tR, true);		rteBounds[0] = o.left;			// left		rteBounds[1] = o.left + o.width;	// right		rteBounds[2] = o.top;				// top		rteBounds[3] = o.top - o.height;	// bottom		// Delete outline object		o.remove();	}	catch (err) {		alert("Text range boundary extraction error\nAn error occurred when I tried to determine the exact dimensions " +			"of the object " & tR & ". This does not affect this object; however, any object positioned in relation " +			"to it may be out of position... + \n\n(Error in Utilities.realTextEdge).)");		// Return original object's boundaries		rteBounds[0] = tR.left;			// left		rteBounds[1] = tR.left + o.width;	// right		rteBounds[2] = tR.top;				// top		rteBounds[3] = tR.top - o.height;	// bottom	}	return rteBounds;}// REAL TEXT BOUNDS ends// TABLE TO THOUSANDS// Called from assignData to convert vals>999 to "1,000" format (tables only)// Calls Utilities.FormatNumberBy3 to do actual reformatfunction tableToThousands(){	var i;	var j;	var it;	for (i = 0; i < g_valArray.length; i ++ ) {		for (j = 0; j < g_valArray[i].length; j ++ ) {			it = g_valArray[i][j];			if (!isNaN(it)) {				g_valArray[i][j] = FormatNumberBy3(it);			}		}	}}// TABLE TO THOUSANDS ends// *** Two functions added March 2013 to open and close XMP library ***// LOAD XMP LIBRARYfunction loadXMPLibrary(){	if ( !ExternalObject.AdobeXMPScript ){        try{ExternalObject.AdobeXMPScript = new ExternalObject('lib:AdobeXMPScript');}        catch (e){alert('Unable to load the AdobeXMPScript library!'); return false;}    }    return true;}// LOAD XMP LIBRARY ends// UNLOAD XMP LIBRARYfunction unloadXMPLibrary(){    if( ExternalObject.AdobeXMPScript ){        try{ExternalObject.AdobeXMPScript.unload(); ExternalObject.AdobeXMPScript = undefined;}        catch (e){alert('Unable to unload the AdobeXMPScript library!');}    }}// UNLOAD XMP LIBRARY ends