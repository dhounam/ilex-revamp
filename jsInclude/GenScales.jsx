/* General scale functions +++Created 03.01.06Updated 03.03.09 (tickStyle: setting style of top-value tick on broken/unbroken inverted scales...)Module contains functions called for both vertical and horizontal scales...- makeScaleArrayLog- makeScaleArrayNormal- tickStyle- stripMinus- isBrokenScale*/// $.level=1;// MAKE SCALE-ARRAY LOG// Called from VScales.populateVScale &  populateHScale to prepare an array for a//	LOG VALUES scale --// Each array-element corresponds to a scale tick and consists of three sub-elements://		scale string value//		vertical/horizontal position// 		flag for whether tick is default, index/zero, or baseline (ignored by scatters)// No checks on values (hopefully done in Excel!)function makeScaleArrayLog(low, high, incr, isVert, isAcross, isLeft)// Args are low value; high value; increment; vert/horiz scale flag; left/right flag// Vertical only -- so isVert argument is ignored{	var dp = countDP(incr);						// # of dec. places to show (func. in Utilities)	var mvA = Array();							// array to return	var i;	var lineStyle;	// First, create an array of plausible scale values	var logValArray = makeLogScaleVals(high, low, incr);	// Now I need a position for each tick	msg = ""	for (i = 0; i < logValArray.length; i ++) {		// Line style flag		if (i == 0) {lineStyle = 1};		else {lineStyle = 0};		mvA[i] = Array(logValArray[i], calcYValuePos(logValArray[i], isLeft),lineStyle)		// If 1000 changes to 1,000...		if (g_vScaleCommas) {			mvA[i][0] = FormatNumberBy3(mvA[i][0])		}	}	return mvA;}// MAKE SCALE-ARRAY LOG ends// MAKE SCALE-ARRAY NORMAL// Called from VScales.populateVScale & HScales.populateHScale to prepare an array for a//	NORMAL VALUES scale --// Each array-element corresponds to a scale tick and consists of three sub-elements://		scale string value//		vertical/horizontal position// 		flag for whether tick is default, index/zero, or baseline (ignored by scatters)// No checks on values (hopefully done in Excel!)function makeScaleArrayNormal(low, high, incr, isVert, isAcross, isLeft)// Args are low value; high value; increment; vert/horiz scale flag; left/right scale flag{	var thisVal;	var dp = countDP(incr);								// # of dec. places to show (func. in Utilities)	var aCount = Math.round((high - low) / incr);			// number of elements (force f.p. to integer)	var inverted;	// listArgs(arguments)	// Initialise array to return	var mvA = new Array(aCount + 1);						// array to return	// Vertical or horizontal array?	if (isVert) {		var thisPos = g_innerBox.top - g_innerBox.height;		// accumulating y-coord		var posIncr = g_innerBox.height / (mvA.length - 1);		// position increment	}	else {		// Horizontal scale: no messing with extra blank tick		var thisPos = g_innerBox.left;							// accumulating x-coord		var posIncr = g_innerBox.width / (mvA.length - 1);		// position increment	}	// Which scale might I be inverting?	if (isLeft) {inverted = g_invertedScaleA};	else {inverted = g_invertedScaleB};	// Accumulating value	if (inverted) {		// inverted scale works from top with negative increment		thisVal = high;		incr = 0 - incr;	}	else {		// not inverted		thisVal = low;	}	var i;													// counter	for (i = 0; i <= aCount; i++) {		mvA[i] = new Array(2);		// Fun with floating point maths. In some cases increment misses zero by a gnat's		// whisker (-5.55111512312578e-17). So add and subtract 1 to force zero:		var fakeZero = thisVal + 1 - 1;		if (fakeZero == 0) {      // If current value is zero			mvA[i][0] = fakeZero;	// use the 'fake' zero			// Until Aug 06 I reserved the baseline now; but this was premature			// Baseline now reserved in VScales.drawVTicks and ...bars?			// if (isLeft) {g_cbBase[0] = thisPos};		// Left/right --			// else {g_cbBase[1] = thisPos};				// remember vPos as possible column/bar baseline													// (bars always use left)		}		else {			// Non-zero			mvA[i][0] = stripMinus(thisVal).toFixed(dp);		// Check for global +/-; force no. of dec. places			if (g_vScaleCommas) {								// Commas in vals > 1000				mvA[i][0] = FormatNumberBy3(mvA[i][0]);			}		}		mvA[i][1] = thisPos;		mvA[i][2] = tickStyle(thisVal, low, high, isAcross);		thisPos += posIncr;		thisVal += incr;	}	// If extra blank tick set to zero value (will be deleted later)	//if (isVert && g_extraVTick) {	//	mvA[mvA.length - 1][0] = -1;		// Previously set to zero, but this acted as a magnet for the baseline assignation...	//}	return mvA;}// MAKE SCALE-ARRAY NORMAL ends// TICK STYLE// Called from makeVScaleArray; returns style of tick (default, baseline, index/zero)// 0 = default; 1 = baseline; 2 = index/mid-scale zerofunction tickStyle(tVal, tLow, tHigh, drawnAcross)// Args are 	value for this tick//				low val//				high val//				true=drawn across{	// Default style:	var tStyle = 0;	// These styles apply only if scale is drawn across chart;	if (drawnAcross) {		switch (tVal) {			case 100 :		// index?				if (g_isIndex) {tStyle = 2};				break;			case 0 :		// zero				// If both broken scale flags (left,right) are false...				if ((!g_isBS[0]) && (!g_isBS[1])) {					// Low value is zero					if (tLow == 0) {						// Emphasise zero on inverted scale; otherwise as baseline						if (g_invertedScaleA || g_invertedScaleB) {							tStyle = 2						}						else {							tStyle = 1						}					}					else if ((tLow < 0) && (tHigh > 0)) {						// Mid-scale zero, inverted or not						tStyle = 2					}					else if ((tLow < 0) && (tHigh == 0)) {						// Top-scale zero (this is probably the same as previous, but						// keep it separate...						tStyle = 2					}				}				else {					// This else covers scatters, where horiz scale can break, but					// there is a zero value on vertical scale					if ((g_overallStyle[0] == c_generalScatterConst) ||						(g_overallStyle[1] == c_generalScatterConst)) {							if (!g_isBS[1]) {								tStyle = 1;							}					}				}				break;			case tLow :		// lowest val				// Unless a bar chart (where non-zero low val uses default style)				// check for baseline				if (!((g_overallStyle[0] == c_generalBarConst) || (g_overallStyle[1] == c_generalBarConst))) {					if ( (!g_scaleTop) && !(g_isBS[0] || g_isBS[1]) ) {tStyle = 1};		// baseline style				}				break;			case tHigh :	// highest				// Inverted scale?				if ((g_invertedScaleA || g_invertedScaleB) && !g_scaleTop) {					// Modded 3.3.09. Broken or not?					if (g_isBS[0] || g_isBS[1]) {tStyle = 0};		// broken -- default					else {tStyle = 1};							// unbroken -- baseline style				}				else {					// Not inverted					if ( g_scaleTop && !(g_isBS[0] || g_isBS[1]) ) {tStyle = 1};			// high val				}				break;		}	}	else {		// Short ticks use baseline style		var tStyle = 1;	}	return tStyle;}// TICK STYLE ends// STRIP MINUS// Called from makeScaleArrayNormal. Checks general preference before// stripping minus signs from negative scale valuesfunction stripMinus(smNo)// Arg is a number{	// Check general preference	if (g_globalPlusMinus) {		if (smNo < 0) {smNo = (0 - smNo)};	}	return smNo;}// STRIP MINUS ends// IS BROKEN SCALE// Called from VScales.roomForScale & drawHScaleValues to check for broken scale// Returns array of 2 booleans: broken-scale flags for left + right scalesfunction isBrokenScale(){	var bsArray = new Array(false,false);	// If preference is no broken scale (margin = 0), bale out now:	if (g_brokenScaleMargin == 0) {return bsArray};	// Indices and log scales can't break either scale	// Index?	if (g_isIndex) {return bsArray};	// Log scale?	if (g_logScale) {return bsArray};	// Scale breaks if low value is greater than zero or (inverted scale)	// high value is less than zero	// Left	if (!(g_lowA == undefined)) {		if ((g_lowA > 0) || (g_highA < 0)) {			bsArray[0] = true;		}	}	// Right	if (!(g_lowB == undefined)) {		if ((g_lowB > 0) || (g_highB < 0)) {			bsArray[1] = true;		}	}	return bsArray;}// IS BROKEN SCALE ends