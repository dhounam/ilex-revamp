/* Vertical scalesCreated 21.11.05Updated 10.12.08 (modded plonkVPM to align global +/– to outline-left/right of vertical scale strings)Updated 03.02.09 (modded plonkVPM for smaller +/–)Updated 28.07.09 (drawVTicks trips duplicate baseline flag for zero in +/- scalesCHECK-CAT-STRINGS CALLS RESIZE-GROUP...AND THE PROBLEM WITH RESIZE-GROUP IS THAT WHEN IT SQUEEZES TEXT IT FORCES IT TO EQUAL INTERVALS...AND THAT'S NO USE WITH A LOG SCALE.FOR THE TIME BEING, I'VE SHORT-CIRCUITED CALLING RESIZE-GROUP FOR LOG SCALES;BUT I REALLY NEED PROVISION IN RESIZE-GROUP (which is in Utilities) TO HANDLE LOG SCALES....- drawVScales	top-level- drawCatStrings- roomForScale- populateVScale- checkCatStrings- tweakLabels- vScaleTicks*/// $.level=1;// DRAW V SCALES// Controls vertical values scale construction for lines, columns and scattersfunction drawVScales(){	// AT THIS POINT, INNER BOX TOP IS ON SUBTITLE BASELINE	// I need a couple of flags for whether to draw left and right scales	// Depends on whether scatter or not	// Flags are set to false if the data is missing	// MOVED TO Main.drawTraces, SO THAT BARS ENCOUNTER THIS (1 Mar 07)	// if (g_chartStyle[1] == c_scatterConst) {	// 	// Scatters: vertical scale is "B" set	// 	if (!(g_incrementB == undefined)) {	// 		g_dataAExists = false	// g_scaleLeft;	// 		g_dataBExists = true	// (!g_scaleLeft);	// 	}	// }	// else {	// 	// Lines/cols: check both sets	// 	g_dataAExists = (!(g_incrementA == undefined));	// 	g_dataBExists = (!(g_incrementB == undefined));	// }	// Category scale strings (h- and v-scales; initial position in case of h-scale...)	if (!drawCatStrings()) {return false};	// Room for scale	if (!roomForScale()) {return false};	// If labels are above/below ticks (i.e. not centred), ticks	// run to edge of current inner box. So remember it...	g_preScaleLabelPos = Array(g_innerBox.left, g_innerBox.left + g_innerBox.width);	// Vertical scale labels	if (!populateVScale()) {return false};	// Since the inner box has narrowed, we have to revisit the category scale label	// which may have wrapped. Function adjusts xPos of cat scale label and squeezes	// vertical scale up if necessary	if (!checkCatStrings()) {return false};	if (!tweakLabels()) {return false};	// Draw ticks	if (!vScaleTicks()) {return false};	// Broken scale base/symbol (if any)	// Function in site module	// At Economist, base and symbol are drawn now	if (g_isBS[0] || g_isBS[1]) {		if (!drawBrokenScale1()) {			myAlert ("Broken scale symbol (stage 1) not drawn...", "Non-fatal error");			// Failure is not fatal		}	}	// Global +/- (if any)	if (g_globalPlusMinus) {		if (!drawVScaleGlobalPlusMinus()) {return false};	}	return true;}// DRAW V-SCALES ends// Remaining functions in order in which they are called from drawVScales// DRAW CAT STRINGS// Called from drawVScales// Draws category info strings on horizontal and (scatter only) vertical scales// (For h-scale, this is not final position: xPos at least will change after scale labels have been drawn --// 	unless, of course, baseline is absolute [FT])function drawCatStrings(){	var xPos;		// co-ords	var yPos;	var csObj;		// text frame object	var s;			// name/note	var tweak;	var rotation;	var tempRange;	// outline for v-scale label tweak	// Are there labels in the first place?	if (g_chartStyle[1] == c_scatterConst) {		// Scatter		// Mod Nov 07 adds function (in Scatters module) to check headers for consistency and extract		// elements required for scale labels		if (!scatterScaleLabels()) {			return false;		}	}	else {		// Non-scatter: pass general Research label to horizontal scale		g_catLabelH = g_catLabel;	}	// Horiz scale:	if (!(g_catLabelH == undefined)) {		g_catLabelH = trans_String(g_catLabelH);		// Set y-coord at top or bottom		if (g_scaleTop) {			yPos = g_innerBox.top - g_catLabelSpaceAbove;		}		else {			yPos = g_innerBox.top - g_innerBox.height;		}		// X-pos		if (g_catHLabelAlignOnChart) {			// Label centres on chart outer box				xPos = g_originalInnerBox.left + (g_originalInnerBox.width / 2);			// if (!g_panelExists) {			// 	alert('no panel');			// 	xPos = g_backBox1.left + (g_backBox1.width / 2);			// }			// else {			// 	alert("looking for : " + g_originalInnerBox);			// 	xPos = g_originalInnerBox.left + (g_originalInnerBox.width / 2);			// }		}		else {			// Label in relation to inner box and axis			switch (g_catLabelAlign) {				case c_lConst:				// left					xPos = g_innerBox.left;					break;				case c_rConst:				// right					xPos = g_innerBox.left + g_innerBox.width;					break;				default:				// default=centre					xPos = g_innerBox.left + (g_innerBox.width /2);					break;			}		}		cOrigin = new Array(yPos,xPos);		s = c_catLabelN + g_thisPanelNo		g_catStringRangeH = makeText(g_panelLayer,cOrigin,g_catLabelFontCMYK,			g_catLabelFontName,g_catLabelFontSize,g_vScaleFontSize,g_catLabelAlign,			0,g_catLabelHScale,			g_innerBox.width,true,g_catLabelH,s,s,false);		// Check it exists:		if (g_catStringRangeH !== undefined) {			// Fine-tune position (unless absolute scale top / baseline)			tweak = g_catStringRangeH.textRange.characterAttributes.leading * (g_catStringRangeH.lines.length - 1)			if (g_scaleTop) {				// String at top				if (!g_absoluteScaleTop) {					g_innerBox.top -= (g_catLabelSpaceAbove + tweak);					g_innerBox.height -= (g_catLabelSpaceAbove + tweak);					g_catStringRangeH.top -= tweak;				}			}			else {				if (!g_absoluteBaseline) {					g_innerBox.height -= (g_catLabelSpaceAbove + tweak);					g_catStringRangeH.top += tweak;				}				else {					// Baseline is absolute; this feels a wee bit inferential, but					// drop by its spaceAbove. This is because in this situation it					// is currently sitting on the same "line" as the h-scale...					g_catStringRangeH.top -= g_catLabelSpaceAbove;				}			}		}		else {			// Failed to create			return false;		}	}	// If no vertical string, retire gracefully:	if (g_catLabelV == undefined) {return true};	// Still here? Scatter chart...	g_catLabelV = trans_String(g_catLabelV);	// Modded for REVAMP, Feb 2016	// V-scale label may go, unrotated and aligned right, at top...	if (g_scatterVScaleLabelAtTop) {		// Top		// For now, at least, put anchor 10pts above top of inner box		// ...		if (g_scatterScaleLeft) {			// Options doesn't exist. I have to assume that Matt's revamp style			// is in operation. Just point out the problem:			myAlert("Vertical scale label error: string not drawn. See VScales.jsx approx line 200...");			return true;		} else {			// Scatter v-scale at right, so there's room for the label			yPos = g_innerBox.top - 5;			// Allow for any extra space below subtitle:			// This requires user to intervene:			// yPos -= g_extraSubtitle;			// So instead:			yPos -= g_catLabelSpaceAbove;			xPos = g_innerBox.left + g_innerBox.width;			cOrigin = new Array(yPos,xPos);			rotation=0;			// Plonk it down:			s = c_catLabelN + g_thisPanelNo;			g_catStringRangeV = makeText(g_panelLayer,cOrigin,g_catLabelFontCMYK,				g_catLabelFontName,g_catLabelFontSize,g_vScaleFontSize,'right',				0,g_catLabelHScale,				g_innerBox.height,true,g_catLabelV,s,s,false);			// And adjust inner box			g_innerBox.top -= g_catLabelSpaceAbove;			g_innerBox.height -= g_catLabelSpaceAbove;		}	} else {		// Rotated, along the axis...		// X-coord, left or right		if (g_scatterScaleLeft) {			// Left			xPos = g_innerBox.left;			rotation = 90;		}		else {			// Right			xPos = g_innerBox.left + g_innerBox.width;			rotation = -90;		}		// Y-coord -- assume centre-aligned...		yPos = g_innerBox.top - (g_innerBox.height / 2);		// Plonk it down:		cOrigin = new Array(yPos,xPos);		s = c_catLabelN + g_thisPanelNo		g_catStringRangeV = makeText(g_panelLayer,cOrigin,g_catLabelFontCMYK,			g_catLabelFontName,g_catLabelFontSize,g_vScaleFontSize,g_catLabelAlign,			rotation,g_catLabelHScale,			g_innerBox.height,true,g_catLabelV,s,s,false);		// For reasons best known to itself, the text frame doesn't get put down on the nail		// Centre it vertically:		tweak = yPos - g_catStringRangeV.anchor[1];		g_catStringRangeV.top += tweak;		// Y-position needs an outline:		tempRange = makeOutline(g_catStringRangeV,true);		if (g_scatterScaleLeft) {			tweak = g_innerBox.left - tempRange.left;		}		else {			tweak = (g_innerBox.left + g_innerBox.width) - (tempRange.left + tempRange.width);		}		tempRange.remove();		g_catStringRangeV.left += tweak;		// and adjust inner box		if (g_scatterScaleLeft) {g_innerBox.left += g_catLabelSpaceAbove};		g_innerBox.width -= g_catLabelSpaceAbove;	}	// And report success!	return true;	// DON'T FORGET THAT V-STRING WILL NEED TWEAKING LATER TOO: checkCatStrings...}// DRAW CAT STRINGS ends// ROOM FOR SCALE// Called from drawVScale// Adjusts inner box scale to allow for://	scale (bottom or top)//	broken scale (bottom)// At this stage, scale height set to one line only --// will check for possible second line after v-scale LABELS// have been drawn  (see checkCatStrings)function roomForScale(){	var adjustment = 0;	// Inner box adjusts for:	// --	(1) scale's spaceAbove (at top)	// ...depending on whether panel or not...	with (g_innerBox) {		if (g_totalPanelNo > 1) {			top -= g_scaleSpaceAboveInPanel;			height -= g_scaleSpaceAboveInPanel;		} else {			top -= g_scaleSpaceAbove;			height -= g_scaleSpaceAbove;		}	}	// --	(2) scale depth	// ACTUALLY, THIS ENTIRE SWITCH SEEMS TOTALLY REDUNDANT: ADJUSTMENT IS SET TO G_HSCALEMAINSPACEABOVE	// IN ***ALL*** CIRCUMSTANCES.	// LAST FIX WAS 25 JULY 2917. I'VE LEFT THIS 'AS IS' SINCE I'VE A NASTY FEELING I MAY	// END UP REVISITING AGAIN BEFORE LONG...	switch (g_timeSeries[1]) {		case undefined:			// Scatter...?			adjustment = g_hScaleMainSpaceAbove;			break;		case c_nameConst:			adjustment = g_hScaleMainSpaceAbove;			break;		case c_yearConst:			adjustment = g_hScaleMainSpaceAbove;			break;		default:			// I have to trap "5Years" & "10Years" ('years' was covered above)			if (g_timeSeries[1].search(c_yearConst) > -1) {				// Mod June 2017. I can't quite follow my logic, but this seems				// to increase the gap above a category label if the time-scale				// is 5/10years. So reset to zero...				// if (g_isRevamp) {				// 	adjustment = g_hScaleMainSpaceAbove;				// } else {				// adjustment = 0;				// }        // It's the category label that messes it all up, so...        // ... major kludge! ...        try {        	if (g_catLabelH === undefined) {            // adjustment = 0;     // g_hScaleMainSpaceAbove;					 adjustment = g_hScaleMainSpaceAbove;          } else if (g_catLabelH.length === 0) {            // adjustment = 0;     // g_hScaleMainSpaceAbove;					 adjustment = g_hScaleMainSpaceAbove;          } else {					 adjustment = g_hScaleMainSpaceAbove;				}       }       catch (e) {}     } else {			// All other cases: complex date scale			// adjustment = g_hScaleMainSpaceAbove + g_hScaleInternalSpaceAbove;			// adjustment = calcScaleAdjustment();			adjustment = g_hScaleMainSpaceAbove;		}		break;	}	// Adjust height of inner box	g_innerBox.height -= adjustment;	// If scale is drawn at top, inner box moves down	// baseline at top	if (g_scaleTop) {		g_innerBox.top -= adjustment;		g_hScaleBase = g_innerBox.top;	}	else {		// Baseline at bottom		g_hScaleBase = g_innerBox.top - g_innerBox.height;	}	// Revamp: Jan 17 - inverted scale? Don't allow for broken scale	if (g_invertedScaleA || g_invertedScaleB) {		return true;	}	// --	(3) broken scale?	// (I don't actually draw broken scale until margins have been adjusted)	// Function (in GenScales) returns a 2-element array of booleans	g_isBS  = isBrokenScale();	// Scatters: only do break for vertical scale here	if ((g_overallStyle[0] == c_generalScatterConst) || (g_overallStyle[1] == c_generalScatterConst)) {		if (g_isBS[1]) {			g_innerBox.height -= g_brokenScaleMargin;		}	}	else {		if ((g_isBS[0]) || (g_isBS[1])) {			g_innerBox.height -= g_brokenScaleMargin;		}	}	return true;}// ROOM FOR SCALE ends// CALC SCALE ADJUSTMENT// Called from roomForScale (above) to work out whether a time-scale// will be drawn on 1 or 2 lines// Specifically, I'm trying to trap quarterly and monthly scales with so many// points that 2nd level must be omitted...// So deal with those only and see how the land lies on days/hours...function calcScaleAdjustment(){	// Default value to return: depth of 2 scale lines	var adj = g_hScaleMainSpaceAbove + g_hScaleInternalSpaceAbove;	switch (g_timeSeries[1]) {		case c_quarterConst :			break;		case c_monthConst :			break;		default :			adj = g_hScaleMainSpaceAbove + g_hScaleInternalSpaceAbove;			break;	}	return adj;}// CALC SCALE ADJUSTMENT ends// POPULATE V-SCALE// Called from drawVScales// Define arrays for left and/or right scales. These will be 2-dimensional://		dim 1: each element = one scale tick//		dim 2: three elements -- value; vertical co-ord; tick style (default/index/baseline)// Calls drawScale to draw actual scale(s)function populateVScale(){	var scatterTempArray;	// Populate both arrays with list of values and y-coords	// (If no increment: no scale that side)	// makeScaleArrayNormal_Normal/Log (in GenScales) populates an array with label values and anchor positions	//	// I have separate rules for Scatters, as opposed to lines/columns	if (g_chartStyle[1] == c_scatterConst) {		// Scatters: vertical scale is "B" set		if (g_dataBExists) {			scatterTempArray = makeScaleArrayNormal(g_lowB,g_highB,g_incrementB,true,g_vScaleAcross,false)			// Left or right? (prev'y used g_scaleLeft; but now scatters have own left/right option)			if (g_scatterScaleLeft) {				g_leftArray = scatterTempArray;			}			else {				g_rightArray = scatterTempArray;			}		// ...leaving one "side" undefined and therefore not drawn...		}		// I used to set the extra tick flag off		//g_extraVTick = false;		// Comm'd out Feb 07; but alternate flag not set		//g_showVTopLabel... is unset	}	else {		// Lines/columns test both sides		if (g_dataAExists) {			if (g_logScale) {				g_leftArray = makeScaleArrayLog(g_lowA,g_highA,g_incrementA,true,g_vScaleAcross,true);				// Force "show top value tick"				g_showVTopLabel = true;			}			else {				g_leftArray = makeScaleArrayNormal(g_lowA,g_highA,g_incrementA,true,g_vScaleAcross,true);			}		}		if (g_dataBExists) {			if (g_logScale) {				g_rightArray = makeScaleArrayLog(g_lowB,g_highB,g_incrementB,true,g_vScaleAcross,false);				g_showVTopLabel = true;			}			else {				g_rightArray = makeScaleArrayNormal(g_lowB,g_highB,g_incrementB,true,g_vScaleAcross,false);			}		}	}	// If left/right array exists, draw scale	if (!(g_leftArray == undefined)) {		if (!drawVScale(g_leftArray,true)) {return false};	}	if (!(g_rightArray == undefined)) {		if (!drawVScale(g_rightArray,false)) {return false};	}	return true;}// POPULATE V-SCALE ends// DRAW V-SCALE// Called from populateVScale// Draws scale labels for left and right scalesfunction drawVScale(dsArray,isLeft)// Args are:		array of values & y-coords//				true if left scale{	var myS;	var sOrigin = new Array(1)	// anchor	var n;						// counter	var str;						// name/note string	var align;					// align string l/r	var s;	var vCMYK;					// colour (allows for override for doublescale)	if (isLeft) {s = c_lConst};	else {s = c_rConst};	// Draw scale strings, anchored horizontally on the inner box left/right	// and vertically (and temporarily) on my array of co-ords	// Scale string group	g_vScaleStringGroup = g_panelLayer.groupItems.add();	g_vScaleStringGroup.name = c_vScaleStringGroupN + s;	// Origin and alignment	if (isLeft) {		sOrigin[1] = g_innerBox.left;		if (g_leftScaleAlignLeft) {align = c_lConst};		else {align = c_rConst};	}	else {		sOrigin[1] = g_innerBox.left + g_innerBox.width;		if (g_rightScaleAlignLeft) {align = c_lConst};		else {align = c_rConst};	}	// Colour	if (g_doubleScale == 0) {		// No double scale, use default		vCMYK = g_vScaleFontCMYK;	}	else {		// Double scale: use 2 colours		if (isLeft) {vCMYK = g_doubleScaleLeftTextCMYK};		else {vCMYK = g_doubleScaleRightTextCMYK};	}	// Name and note	str = c_vScaleStringN;	n = 1	for (i in dsArray) {		if (!(dsArray[i][0] == undefined)) {			sOrigin[0] = dsArray[i][1];			myS = makeText(g_vScaleStringGroup,sOrigin,vCMYK,				g_vScaleFontName,g_vScaleFontSize,g_vScaleFontSize,align,0,100,				0,false,dsArray[i][0],str + n,str + n, true);			n ++;		}	}	// Scale labels form a group. Create an outline to get exact dimensions.	// Reposition, then adjust inner box	moveVStrings(g_vScaleStringGroup,isLeft)	// If top label not show, tick, delete...	// Comm'd out: -- if (g_extraVTick) {	if (!(g_showVTopLabel)) {		g_vScaleStringGroup.textFrames[0].remove();	}	return true;}// DRAW V-SCALE ends// MOVE V-STRINGS// Called from drawScale to adjust horizontal and vertical position of scale labels// Adjusts position of scale labels block; tweaks inner box to left & right positions// for trace area (would be left and right ends of ticks running across...)// Then gets a vertical tweak...function moveVStrings(myG,lSide)// Args are 	group of vertical scale strings//						side (left=true){	// Mods Jan 7 2015 to fix moving strings and adjusting inner box	// Make and measure an outline	var outline = makeOutline(myG, false);	var w = outline.width;	if (lSide) {		// Left; but only move if aligned right		// (this fixes a long-standing bug, never spotted!)		if (!g_leftScaleAlignLeft) {			// Move group			myG.left += w;		}		// Adjust inner box position and width		// REVAMP: if broken scale symbol width > labels, use that:		if (g_isBS[0]) {			if (g_brokenScaleSymbolWidth > w) {w = g_brokenScaleSymbolWidth;}		}		g_innerBox.left += (w + g_outTickMargin);		g_innerBox.width -= (w + g_outTickMargin);	}	else {		// Right; but only move if aligned left		if (g_rightScaleAlignLeft) {			myG.left -= w;		}		// Adjust inner box width only (with check on BS symbol width)		if (g_isBS[1]) {			if (g_brokenScaleSymbolWidth > w) {w = g_brokenScaleSymbolWidth;}		}		g_innerBox.width -= (w + g_outTickMargin);	}	outline.remove();	// Vertical position	var tF = myG.textFrames[0];	// Use a zero to test height (to avoid including descending comma in height calculation)	var holdString = tF.contents;	tF.contents = "0";	outline = makeOutline(tF, true);	g_labHeight = outline.height;	// Tidy up: delete outline and replace original contents of	// top textFrame in labels group	outline.remove();	tF.contents = holdString;}// MOVE V-STRINGS ends// CHECK CAT STRING// Called from drawScales after scale(s) labels (but NOT ticks) have been drawn// The inner box has narrowed, so the category string along the bottom scale// may need to wrap, in which case the scales labels will have to squeeze up/down//// This also looks like the right place to check whether the scale will be drawn// over 2 lines (default adjustment for one line has been made, so I'm just// checking for a 2nd line here...)function checkCatStrings(){	var ccsTweak = 0;			// amount by which to tweak the vertical scale labels	var scaleGroup;	var vTickArray;	// If scale top or baseline is absolute:	if (g_absoluteScaleTop || g_absoluteBaseline) {return true};	// Does category label string even exist?	if (!(g_catStringRangeH == undefined)) {		var lCount = g_catStringRangeH.lines.length;		// Horizontal reposition (unless aligned to chart outer box)		if (!g_catHLabelAlignOnChart) {			switch (g_catLabelAlign) {				case c_lConst:				// left					g_catStringRangeH.left = g_innerBox.left;					break;				case c_rConst:				// right					g_catStringRangeH.left = (g_innerBox.left + g_innerBox.width) - g_catStringRangeH.width;					break;				default:				// default=centre					g_catStringRangeH.left -= (g_catStringRangeH.anchor[0] - (g_innerBox.left + (g_innerBox.width / 2)));					break;			}		}		// Do I need to wrap?		if (g_catStringRangeH.width > g_innerBox.width) {			// Apparently so: wrap string and, if necessary, move it up			wrapText(g_catStringRangeH.contents, g_catStringRangeH, g_innerBox.width, g_catLabelHScale, (!g_scaleTop));			// (String, object, wrap width, horizontal-scale, move?)			// How many lines more?			lCount = (g_catStringRangeH.lines.length - lCount);			ccsTweak = lCount * g_catStringRangeH.textRange.characterAttributes.leading;		}	}	// Now, do I need a 2nd line of scale labels?	// I have a global which is set to:	//	2 = long format ("Jun"); 1 = short format ("J"); 0 = no sub-scale	// Function in this module works out how many sub-scale strings I'm likely	// to need.	g_line2ScaleFormat = willFit();	// Allow the global to be set; but if baseline is absolute bale out	// now before any actual tweaking is done...	if (g_absoluteBaseline) {return true};	// Bale out if date scale forced on to one line	if (g_oneLineDateScale) {return true};	if (g_line2ScaleFormat > 0) {		ccsTweak += g_hScaleInternalSpaceAbove;	}	// Adjust inner box and h-scale baseline	g_innerBox.height -= ccsTweak;	// Scale at top, move innerbox down	if (g_scaleTop) {		g_innerBox.top -= ccsTweak;		g_hScaleBase -= ccsTweak;	}	// Scale at bottom, move reserved baseline up	else {g_hScaleBase += ccsTweak};	// For non-log scales, I make no attempt to squeeze the scale	// This needs fixing...	if (g_logScale) {return true};	// Squeeze labels up/down	// Args: group, amount, vertically/horizontally, up/down, left/right	// Either group may not exist...	// Left:	try {		scaleGroup = g_panelLayer.groupItems[c_vScaleStringGroupN + c_lConst];		vTickArray = resizeGroup(scaleGroup, 0-ccsTweak, true, g_scaleTop, true);		if (!(vTickArray == undefined)) {			// resizeGroup (in Utilities) returned an array of the vertical origins of all the labels			// These are still set to the correct v-pos for each tick, so reset array			// for ticks accordingly:			for (i in vTickArray) {				g_leftArray[i][1] = vTickArray[i];			}		}	}	catch (err) {};	// Right:	try {		scaleGroup = g_panelLayer.groupItems[c_vScaleStringGroupN + c_rConst];		vTickArray = resizeGroup(scaleGroup, 0-ccsTweak, true, g_scaleTop, true);		if (!(vTickArray == undefined)) {			for (i in vTickArray) {				g_rightArray[i][1] = vTickArray[i];			}		}	}	catch (err) {};	return true;}// CHECK CAT STRING ends// TWEAK LABELS// Called from drawScales.// Labels are drawn with the vertical origin set level with (eventual) ticks. To summarise:// I allow for any h-Scale category label (1 line) and a basic scale (1 line)// I put the labels on the page with their v-origins set to the tick-positions.// I check the category for wrapping (which can create extra line(s) and the scale for a// 2nd line.// I squeeze the labels up as necessary. Having reserved their v-origins as definitive positions// for ticks...// I NOW tweak the labels' vertical alignment relative to the ticks...function tweakLabels(){	var it = Array(c_lConst, c_rConst);	var i;	var labGrp;	for (i = 0; i < 2; i ++) {		try {			// labGrp = g_myDoc.groupItems[c_vScaleStringGroupN + it[i]];			labGrp = g_panelLayer.groupItems[c_vScaleStringGroupN + it[i]];			// Draw labels above, centred or below tick?			if (g_vScaleLabelAlign > 0) {				// above ticks				labGrp.top += g_vScaleLabelAlign;			}			else if (g_vScaleLabelAlign == 0) {				// centred				labGrp.top -= g_labHeight/2;			}			else {				// below ticks				// (g_vScaleLabelAlign is a negative val, so SUBTRACTED from h)				labGrp.top -= (g_labHeight - g_vScaleLabelAlign);			}		}		catch (err) {};	}	return true;}// TWEAK LABELS ends// V-SCALE TICKS// Called from drawVScales to draw scale ticks. Simply defines a group// and calls sub-function for left/right scale (if there is one)// (Inner box has been resized after labels and catString re-wrap...)function vScaleTicks(){	// For each side (left=element 0; right = element 1),	// "control" controls whether:	//		0	-	no ticks	//		1	-	no ticks, but reserve baseline	//		2	-	ticks and reserve baseline	// (this is allow for "across" double scales, where only one stack of ticks is drawn	//  but I may want to remember a baseline to anchor columns or drop in global +/-)	var control = new Array(0,0);	if (g_doubleScale) {		// Double scale -- always do left, test for right		control[0] = 2;		if (g_vScaleAcross) {			control[1] = 1;	// reserve baseline		}		else {			control[1] = 2;	// ticks and reserve baseline		}	}	else {		// Not double scale -- one or the other		if (g_dataAExists) {control[0] = 2};		else {control[1] = 2};	}	// Left//	if (g_dataAExists) {	if (control[0] == 2) {		// Redefine vertical array, using new inner box -- or not...		g_vScaleTickGroup = g_panelLayer.groupItems.add();		g_vScaleTickGroup.name = c_vScaleTickGroupN + c_lConst;		drawVTicks(g_vScaleTickGroup,true,true);	}	else if (control[0] == 1) {		// Just get a baseline position		drawVTicks(g_vScaleTickGroup,true,false);	}	// Only draw right scale if left doesn't exist (on a double-scale, both scales	// are identical -- checked in Excel)//	else {//		if (g_dataBExists) {	if (control[1] == 2) {			// Redefine vertical array, using new inner box -- or not...			g_vScaleTickGroup = g_panelLayer.groupItems.add();			g_vScaleTickGroup.name = c_vScaleTickGroupN + c_rConst;			drawVTicks(g_vScaleTickGroup,false,true)		}	else if (control[1] == 1) {		// Just get a baseline position		drawVTicks(g_vScaleTickGroup,false,false);	}//	}	return true;}// V-SCALE TICKS ends// DRAW V-TICKS// Called from vScaleTicks. Always extracts a baseline position from the left/right array;// may or may not actually draw left/right scale ticksfunction drawVTicks(tGrp,drawLeft,actuallyDraw)// Args are: 	group context//			left/right scale flag//			true to draw ticks; false just to reserve baseline{	var tickArray;	var aTick;	var tPoints;	var hStart;					// general start/end	var hEnd;	var myL;	var myR;	var loopDrawsBase = false;	// flags loop on which baseline is drawn	var i;	// Mod March 2013 to allow dotted lines on SR charts. If a dotted style	// is defined, it's used; if none found in lookup, scale ticks are solid.	var lineEnd;	var dotArray;	// Left or right?	if (g_chartStyle[1] == c_scatterConst) {		// Scatters pick up on their own flag:		if (g_scatterScaleLeft) {			tickArray = g_leftArray;		}		else {			tickArray = g_rightArray;		}	}	else {		// Non-scatters pick up on general l/r flag		if (drawLeft) {			tickArray = g_leftArray;		}		else {			tickArray = g_rightArray;		}	}	// Baseline	// (done first, since it may be all I want)	// Set default to bottom of inner box, in case no baseline set (e.g. broken scale)	if (drawLeft) {g_cbBase[0] = g_innerBox.top - g_innerBox.height};	else {g_cbBase[1] = g_innerBox.top - g_innerBox.height};	// NOW look for zero tick...	for (i = 0; i < tickArray.length; i++) {		// Remember baseline, if any, left or right...		if (tickArray[i][0] == 0) {			if (drawLeft) {g_cbBase[0] = tickArray[i][1]};			else {g_cbBase[1] = tickArray[i][1]};		}	}	// If just reserving baseline, no need to stick around	if (!actuallyDraw) {		return;	}	// Still here? Draw ticks...	// If labels are above/below ticks, ticks extend	// to the previous inner box (before labels were drawn)	if (!(g_vScaleLabelAlign == 0)) {		myL = g_preScaleLabelPos[0];		myR = g_preScaleLabelPos[1];	}	else {		// Labels are centred: use current inner box		myL = g_innerBox.left;		myR = g_innerBox.left + g_innerBox.width;	}	// Tick length	if (g_vScaleAcross) {		hStart = myL;		//g_innerBox.left;		hEnd = myR;			//g_innerBox.left + g_innerBox.width;	}	else {//		if (g_scaleLeft) {		if (drawLeft) {			hStart = myL;				//g_innerBox.left;			hEnd = myL + g_vScaleLength;	//g_innerBox.left + g_vScaleLength;		}		else {			hStart = myR  - g_vScaleLength;		// g_innerBox.left  + g_innerBox.width - vScaleLength;			hEnd = myR;						// g_innerBox.left + g_innerBox.width;		}	}	for (i = 0; i < tickArray.length; i++) {		str = c_vScaleTickN + (i + 1);		// Normally:		tPoints = new Array(Array(hStart,tickArray[i][1]),Array(hEnd,tickArray[i][1]));		// But baseline (top or bottom) always runs right across		// so overwrite tPoints for top/bottom		if (g_scaleTop) {			// Scale at top: last tick			if (i == (tickArray.length - 1)) {				tPoints = new Array(Array(myL,tickArray[i][1]),Array(myR,tickArray[i][1]));				//loopDrawsBase = true;			}		}		else {			// Scale at bottom: first tick			if (i == 0) {				tPoints = new Array(Array(myL,tickArray[i][1]),Array(myR,tickArray[i][1]));				//loopDrawsBase = true;			}		}    // REVAMP KLUDGE for scatters, which don't highlight base zero    // if ((g_chartStyle[1] == c_scatterConst) && g_scatterHScaleAcross) {    //   tickArray[i][2] = 0;    // }		// Width & colour		switch (tickArray[i][2]) {			case 2:		// index or (zero for +/- scale)				sW = g_vScaleIndexStrokeWidth;				sCol = g_vScaleIndexCMYK;				dotArray = undefined;				if (tickArray[i][0] == 0) {					loopDrawsBase = true;				}				else {					loopDrawsBase = false;				}				break;			case 1:		// zero baseline				sW = g_vScaleBaseStrokeWidth;				sCol = g_vScaleBaseCMYK;				dotArray = undefined;				loopDrawsBase = true;				break;			default:				sW = g_vScaleDefaultStrokeWidth;				sCol = g_vScaleDefaultCMYK;				dotArray = g_vScaleDefaultStrokeDash;				loopDrawsBase = false;		}		if (dotArray === undefined) {			lineEnd = c_defaultLineEnd;		}		else {			// Dotted line forces round line end			lineEnd = 2;		}		aTick = makeLine(tGrp,tPoints,false,undefined,true,sW,sCol,lineEnd,			c_defaultLineMiter,c_defaultLineMiterLimit, c_vScaleTickN + i,c_vScaleTickN + i,			dotArray);		// If this tick is the baseline, remember it...		if (loopDrawsBase) {			g_baselineTick = aTick;			loopDrawsBase = false;		}	}}// DRAW V-TICKS ends// DRAW V-SCALE GLOBAL PLUS_MINUS// Called from drawVScales// Currently plonks +/- down at top of vertical scale// Ideally, we can improve on this...function drawVScaleGlobalPlusMinus(){	if (!(g_lowA == undefined)) {		if (g_lowA < 0) {			plonkVPM(true)		}	}	if (!(g_lowB == undefined)) {		if (g_lowB < 0) {			plonkVPM(false)		}	}	return true;}// DRAW V-SCALE GLOBAL PLUS_MINUS ends// PLONK V-PM// Called from globalPlusMinus to draw +/- for left or right scalefunction plonkVPM(plonkLeft)// Arg: true = left scale{	var sLabels;				// Existing scale	var pmPos = new Array(1);	// +/- origin	var myS;					// symbol object	var myPos;				// baseline vPos (if undefined, set to top of inner box)	var sMove;				// initial vPos (anchor)	var tweak;				// adjustment distances	var testItem;				// textrange in existing scale from which to derive...	var xAnchor;				// ...horizontal anchor	var pmCMYK = g_vScaleFontCMYK	var thisBase;				// holds left or right baseline definition	var pmSize;				// Size of global +/–	if (plonkLeft) {		// Left scale		thisBase = g_cbBase[0];		// I depend upon being able to find an existing group of vertical scale		// label strings. On scatters, I am called twice -- "left" and "right" -- when		// only one vertical scale exists (the other is horizontal). So return if		// either left or right scale is not found...		try {			testItem = g_panelLayer.groupItems[c_vScaleStringGroupN + c_lConst].pageItems[0];		}		catch (err) {return};		// Still here? Left scale exists		// Mod Dec 08 uses outline-right of existing scale ranges		// pmPos[1] = testItem.anchor[0];		pmPos[1] = realTextBounds(testItem)[1];		// Align left/right		if (g_leftScaleAlignLeft) {			align = c_lConst;		}		else {			align = c_rConst;		}		// Vertical position based on half distance between 2 ticks		sMove = (g_leftArray[1][1] - g_leftArray[0][1]) / 2;		// Inverted scale reverses		if (g_invertedScaleA) {sMove = (0 - sMove)};		if (g_doubleScale > 0) {pmCMYK =  g_doubleScaleLeftTextCMYK};	}	else {		// Right scale		thisBase = g_cbBase[1];		try {			testItem = g_panelLayer.groupItems[c_vScaleStringGroupN + c_rConst].pageItems[0];		}		catch (err) {return};		// Still here? Right scale exists		// Mod Dec 08 uses outline-left of existing scale ranges		// pmPos[1] = testItem.anchor[0];		pmPos[1] = realTextBounds(testItem)[0];		if (g_rightScaleAlignLeft) {			align = c_lConst;		}		else {			align = c_rConst;		}		sMove = (g_rightArray[1][1] - g_rightArray[0][1]) / 2;		if (g_invertedScaleB) {sMove = (0 - sMove)};		if (g_doubleScale > 0) {pmCMYK =  g_doubleScaleRightTextCMYK};	}	// Insurance	if (thisBase == undefined) {myPos = g_innerBox.top};	else {myPos = thisBase};	// Fontsize for +/–	// Trap possibility that pref var added Feb 09 hasn't made it into	// lookup file; but basically, subtract amount from scale font size...	if (g_plusMinusSmallerBy == undefined) {		pmSize = g_vScaleFontSize	}	else {		pmSize = g_vScaleFontSize - g_plusMinusSmallerBy	}	// Plus: place, then get height & tweak	pmPos[0] = myPos + sMove;	myS = makeText(g_panelLayer,pmPos,pmCMYK,			g_vScaleFontName,pmSize,pmSize,align,0,100,			0,false,"+","","", false);	tweak = myPos + sMove + (myS.height / 2);	myS.position = Array(myS.position[0],tweak);	// (Actually the tweak comes out a smidgin low: really I should use	// my outline-get dimensions functions...)	// Minus:	pmPos[0] = myPos - sMove;	myS = makeText(g_panelLayer,pmPos,pmCMYK,		g_vScaleFontName,pmSize,pmSize,align,0,100,		0,false,"–","","", false);	tweak = myPos - sMove + (myS.height / 2)	myS.position = Array(myS.position[0],tweak)}// PLONK V-PM ends// 2 functions work out whether I can fit in the strings on a SUB-SCALE// (currently just quarters and months)// WILL FIT// Returns://		0: neither short nor long strings will fit//		1: short strings fit//		2: long strings fitfunction willFit(){	var wfResult = 0;						// Result to return	// Extract first and last dates from array	var tA = new Date(g_catArray[0]);	var tB = new Date(g_catArray[g_catArray.length - 1]);	//	var oneDay = 1000*60*60*24;				// 1 day in ms	var iMS;									// time series increment in ms	// Booleans are true if long/short strings will fit...	var testLong;	var testShort;	var dCount;								// number of months/quarters in the time period	var duration = tB - tA;					// interval between first and last dates	// If we're doing a years or names scale, there's no reason to hang about	// Otherwise I look for a quarterly series (test "Q4")	// If it isn't that, I assume I'll want to draw month strings ("May" and "M")	// for ANY series...	switch (g_timeSeries[1]) {		case c_nameConst:			return wfResult;			break;		case c_yearConst:			return wfResult;			break;		case c_quarterConst:			iMS = oneDay * 90;			// Number of strings:			dCount = (duration/iMS).toFixed(0);			testLong = checkFit("Q4", dCount);			testShort = testLong;			break;		default:			// Defaults to months...			iMS = oneDay * 30;			// Number of strings:			dCount = (duration/iMS).toFixed(0);			testLong = checkFit("May", dCount);			testShort = checkFit("M", dCount);			break;	}	// Result to return defaults to zero (no fit). But maybe...	// I get T/F on fitting in long and short strings	// If long will fit, return true	if (testLong) {		wfResult = 2;	}	// If long don't fit, test short	else {		if (testShort) {			wfResult = 1;		}	}	return wfResult;}// WILL FIT ends// CHECK FIT// Called from willFit (above)function checkFit(str, strNo){	var canFit = false;	var chW = g_innerBox.width;	var strW;	// Here I'd draw an outline and get its width. But for now	// I'm using hard-settings from current Eco style...	// Actual widths + 2pts	switch (str) {		case "Q4":			sW = 7 + 2;			break;		case "May":			sW = 11 + 2;			break;		case "M":			sW = 4 + 2;			break;	}	 if ((sW * strNo) < chW) {canFit = true};	 return canFit;}// CHECK FIT ends